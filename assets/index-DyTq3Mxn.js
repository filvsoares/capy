const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./_beans-CfCNPWRd.js","./codegen-hook-PMV6UFv2.js","./symbol-processor-TWQTEQy9.js","./_beans-BUNWTXnV.js","./expression-item-processor-u9WVjWwB.js","./expression-processor-DQ-gQ6lR.js","./expression-reader-D_oDuUvA.js","./identifier-resolver-CZD0pzuw.js","./operation-processor-D2Wlskad.js","./_beans-CyXv1buW.js","./toplevel-reader-BMha_raw.js","./type-reader-BgLSKYrq.js","./_beans-DrWhs8Lt.js","./library-Be0wFXzF.js","./_beans-CM3-gej0.js","./callable-type-reader-CHAWhWqV.js","./runner-args-provider-DNwi-xSl.js","./use-provider-Mt4SMmyo.js","./_beans-DKlJfwLP.js","./parser-hook-DQR4w9rn.js","./statement-reader-DEl4Ch8T.js","./type-item-reader-NiAJqXja.js","./_beans-BKorO9SS.js","./_beans-D5qDzQp1.js","./tokenizer-BrFqumHj.js","./_beans-B71FwR43.js","./_beans-C8msONes.js","./_beans-BSqjJ_Ny.js","./_beans-CLdlX0cW.js","./_beans-RJm3-CdN.js"])))=>i.map(i=>d[i]);
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var REACT_ELEMENT_TYPE$2 = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE$2 = Symbol.for("react.fragment");
function jsxProd(type, config, maybeKey) {
  var key = null;
  void 0 !== maybeKey && (key = "" + maybeKey);
  void 0 !== config.key && (key = "" + config.key);
  if ("key" in config) {
    maybeKey = {};
    for (var propName in config)
      "key" !== propName && (maybeKey[propName] = config[propName]);
  } else maybeKey = config;
  config = maybeKey.ref;
  return {
    $$typeof: REACT_ELEMENT_TYPE$2,
    type,
    key,
    ref: void 0 !== config ? config : null,
    props: maybeKey
  };
}
reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE$2;
reactJsxRuntime_production.jsx = jsxProd;
reactJsxRuntime_production.jsxs = jsxProd;
{
  jsxRuntime.exports = reactJsxRuntime_production;
}
var jsxRuntimeExports = jsxRuntime.exports;
var client = { exports: {} };
var reactDomClient_production = {};
var scheduler = { exports: {} };
var scheduler_production = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function push2(heap, node) {
    var index2 = heap.length;
    heap.push(node);
    a: for (; 0 < index2; ) {
      var parentIndex = index2 - 1 >>> 1, parent = heap[parentIndex];
      if (0 < compare(parent, node))
        heap[parentIndex] = node, heap[index2] = parent, index2 = parentIndex;
      else break a;
    }
  }
  function peek(heap) {
    return 0 === heap.length ? null : heap[0];
  }
  function pop2(heap) {
    if (0 === heap.length) return null;
    var first = heap[0], last = heap.pop();
    if (last !== first) {
      heap[0] = last;
      a: for (var index2 = 0, length = heap.length, halfLength = length >>> 1; index2 < halfLength; ) {
        var leftIndex = 2 * (index2 + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
        if (0 > compare(left, last))
          rightIndex < length && 0 > compare(right, left) ? (heap[index2] = right, heap[rightIndex] = last, index2 = rightIndex) : (heap[index2] = left, heap[leftIndex] = last, index2 = leftIndex);
        else if (rightIndex < length && 0 > compare(right, last))
          heap[index2] = right, heap[rightIndex] = last, index2 = rightIndex;
        else break a;
      }
    }
    return first;
  }
  function compare(a, b) {
    var diff = a.sortIndex - b.sortIndex;
    return 0 !== diff ? diff : a.id - b.id;
  }
  exports.unstable_now = void 0;
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var localPerformance = performance;
    exports.unstable_now = function() {
      return localPerformance.now();
    };
  } else {
    var localDate = Date, initialTime = localDate.now();
    exports.unstable_now = function() {
      return localDate.now() - initialTime;
    };
  }
  var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
  function advanceTimers(currentTime) {
    for (var timer = peek(timerQueue); null !== timer; ) {
      if (null === timer.callback) pop2(timerQueue);
      else if (timer.startTime <= currentTime)
        pop2(timerQueue), timer.sortIndex = timer.expirationTime, push2(taskQueue, timer);
      else break;
      timer = peek(timerQueue);
    }
  }
  function handleTimeout(currentTime) {
    isHostTimeoutScheduled = false;
    advanceTimers(currentTime);
    if (!isHostCallbackScheduled)
      if (null !== peek(taskQueue))
        isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
      else {
        var firstTimer = peek(timerQueue);
        null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
      }
  }
  var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
  function shouldYieldToHost() {
    return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
  }
  function performWorkUntilDeadline() {
    needsPaint = false;
    if (isMessageLoopRunning) {
      var currentTime = exports.unstable_now();
      startTime = currentTime;
      var hasMoreWork = true;
      try {
        a: {
          isHostCallbackScheduled = false;
          isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            b: {
              advanceTimers(currentTime);
              for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                var callback = currentTask.callback;
                if ("function" === typeof callback) {
                  currentTask.callback = null;
                  currentPriorityLevel = currentTask.priorityLevel;
                  var continuationCallback = callback(
                    currentTask.expirationTime <= currentTime
                  );
                  currentTime = exports.unstable_now();
                  if ("function" === typeof continuationCallback) {
                    currentTask.callback = continuationCallback;
                    advanceTimers(currentTime);
                    hasMoreWork = true;
                    break b;
                  }
                  currentTask === peek(taskQueue) && pop2(taskQueue);
                  advanceTimers(currentTime);
                } else pop2(taskQueue);
                currentTask = peek(taskQueue);
              }
              if (null !== currentTask) hasMoreWork = true;
              else {
                var firstTimer = peek(timerQueue);
                null !== firstTimer && requestHostTimeout(
                  handleTimeout,
                  firstTimer.startTime - currentTime
                );
                hasMoreWork = false;
              }
            }
            break a;
          } finally {
            currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
          }
          hasMoreWork = void 0;
        }
      } finally {
        hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
      }
    }
  }
  var schedulePerformWorkUntilDeadline;
  if ("function" === typeof localSetImmediate)
    schedulePerformWorkUntilDeadline = function() {
      localSetImmediate(performWorkUntilDeadline);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var channel = new MessageChannel(), port = channel.port2;
    channel.port1.onmessage = performWorkUntilDeadline;
    schedulePerformWorkUntilDeadline = function() {
      port.postMessage(null);
    };
  } else
    schedulePerformWorkUntilDeadline = function() {
      localSetTimeout(performWorkUntilDeadline, 0);
    };
  function requestHostTimeout(callback, ms) {
    taskTimeoutID = localSetTimeout(function() {
      callback(exports.unstable_now());
    }, ms);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(task) {
    task.callback = null;
  };
  exports.unstable_forceFrameRate = function(fps) {
    0 > fps || 125 < fps ? console.error(
      "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
    ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return currentPriorityLevel;
  };
  exports.unstable_next = function(eventHandler) {
    switch (currentPriorityLevel) {
      case 1:
      case 2:
      case 3:
        var priorityLevel = 3;
        break;
      default:
        priorityLevel = currentPriorityLevel;
    }
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = priorityLevel;
    try {
      return eventHandler();
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
  exports.unstable_requestPaint = function() {
    needsPaint = true;
  };
  exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
    switch (priorityLevel) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        priorityLevel = 3;
    }
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = priorityLevel;
    try {
      return eventHandler();
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
  exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
    var currentTime = exports.unstable_now();
    "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
    switch (priorityLevel) {
      case 1:
        var timeout = -1;
        break;
      case 2:
        timeout = 250;
        break;
      case 5:
        timeout = 1073741823;
        break;
      case 4:
        timeout = 1e4;
        break;
      default:
        timeout = 5e3;
    }
    timeout = options + timeout;
    priorityLevel = {
      id: taskIdCounter++,
      callback,
      priorityLevel,
      startTime: options,
      expirationTime: timeout,
      sortIndex: -1
    };
    options > currentTime ? (priorityLevel.sortIndex = options, push2(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push2(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
    return priorityLevel;
  };
  exports.unstable_shouldYield = shouldYieldToHost;
  exports.unstable_wrapCallback = function(callback) {
    var parentPriorityLevel = currentPriorityLevel;
    return function() {
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = parentPriorityLevel;
      try {
        return callback.apply(this, arguments);
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
  };
})(scheduler_production);
{
  scheduler.exports = scheduler_production;
}
var schedulerExports = scheduler.exports;
var react = { exports: {} };
var react_production = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var REACT_ELEMENT_TYPE$1 = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE$2 = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE$1 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE$1 = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE$1 = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE$1 = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE$1 = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE$1 = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE$1 = Symbol.for("react.suspense"), REACT_MEMO_TYPE$1 = Symbol.for("react.memo"), REACT_LAZY_TYPE$1 = Symbol.for("react.lazy"), MAYBE_ITERATOR_SYMBOL$1 = Symbol.iterator;
function getIteratorFn$1(maybeIterable) {
  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
  maybeIterable = MAYBE_ITERATOR_SYMBOL$1 && maybeIterable[MAYBE_ITERATOR_SYMBOL$1] || maybeIterable["@@iterator"];
  return "function" === typeof maybeIterable ? maybeIterable : null;
}
var ReactNoopUpdateQueue = {
  isMounted: function() {
    return false;
  },
  enqueueForceUpdate: function() {
  },
  enqueueReplaceState: function() {
  },
  enqueueSetState: function() {
  }
}, assign$1 = Object.assign, emptyObject = {};
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
Component.prototype.isReactComponent = {};
Component.prototype.setState = function(partialState, callback) {
  if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
    throw Error(
      "takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, partialState, callback, "setState");
};
Component.prototype.forceUpdate = function(callback) {
  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
};
function ComponentDummy() {
}
ComponentDummy.prototype = Component.prototype;
function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent;
assign$1(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = true;
var isArrayImpl$1 = Array.isArray, ReactSharedInternals$2 = { H: null, A: null, T: null, S: null, V: null }, hasOwnProperty$1 = Object.prototype.hasOwnProperty;
function ReactElement(type, key, self2, source, owner, props) {
  self2 = props.ref;
  return {
    $$typeof: REACT_ELEMENT_TYPE$1,
    type,
    key,
    ref: void 0 !== self2 ? self2 : null,
    props
  };
}
function cloneAndReplaceKey(oldElement, newKey) {
  return ReactElement(
    oldElement.type,
    newKey,
    void 0,
    void 0,
    void 0,
    oldElement.props
  );
}
function isValidElement(object) {
  return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE$1;
}
function escape(key) {
  var escaperLookup = { "=": "=0", ":": "=2" };
  return "$" + key.replace(/[=:]/g, function(match) {
    return escaperLookup[match];
  });
}
var userProvidedKeyEscapeRegex = /\/+/g;
function getElementKey(element, index2) {
  return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index2.toString(36);
}
function noop$1$1() {
}
function resolveThenable(thenable) {
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw thenable.reason;
    default:
      switch ("string" === typeof thenable.status ? thenable.then(noop$1$1, noop$1$1) : (thenable.status = "pending", thenable.then(
        function(fulfilledValue) {
          "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
        },
        function(error) {
          "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
        }
      )), thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
      }
  }
  throw thenable;
}
function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;
  if ("undefined" === type || "boolean" === type) children = null;
  var invokeCallback = false;
  if (null === children) invokeCallback = true;
  else
    switch (type) {
      case "bigint":
      case "string":
      case "number":
        invokeCallback = true;
        break;
      case "object":
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE$1:
          case REACT_PORTAL_TYPE$2:
            invokeCallback = true;
            break;
          case REACT_LAZY_TYPE$1:
            return invokeCallback = children._init, mapIntoArray(
              invokeCallback(children._payload),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
        }
    }
  if (invokeCallback)
    return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl$1(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
      return c;
    })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
      callback,
      escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
        userProvidedKeyEscapeRegex,
        "$&/"
      ) + "/") + invokeCallback
    )), array.push(callback)), 1;
  invokeCallback = 0;
  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
  if (isArrayImpl$1(children))
    for (var i = 0; i < children.length; i++)
      nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
        nameSoFar,
        array,
        escapedPrefix,
        type,
        callback
      );
  else if (i = getIteratorFn$1(children), "function" === typeof i)
    for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
      nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
        nameSoFar,
        array,
        escapedPrefix,
        type,
        callback
      );
  else if ("object" === type) {
    if ("function" === typeof children.then)
      return mapIntoArray(
        resolveThenable(children),
        array,
        escapedPrefix,
        nameSoFar,
        callback
      );
    array = String(children);
    throw Error(
      "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
    );
  }
  return invokeCallback;
}
function mapChildren(children, func, context) {
  if (null == children) return children;
  var result = [], count = 0;
  mapIntoArray(children, result, "", "", function(child) {
    return func.call(context, child, count++);
  });
  return result;
}
function lazyInitializer(payload) {
  if (-1 === payload._status) {
    var ctor = payload._result;
    ctor = ctor();
    ctor.then(
      function(moduleObject) {
        if (0 === payload._status || -1 === payload._status)
          payload._status = 1, payload._result = moduleObject;
      },
      function(error) {
        if (0 === payload._status || -1 === payload._status)
          payload._status = 2, payload._result = error;
      }
    );
    -1 === payload._status && (payload._status = 0, payload._result = ctor);
  }
  if (1 === payload._status) return payload._result.default;
  throw payload._result;
}
var reportGlobalError$1 = "function" === typeof reportError ? reportError : function(error) {
  if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
    var event = new window.ErrorEvent("error", {
      bubbles: true,
      cancelable: true,
      message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
      error
    });
    if (!window.dispatchEvent(event)) return;
  } else if ("object" === typeof process && "function" === typeof process.emit) {
    process.emit("uncaughtException", error);
    return;
  }
  console.error(error);
};
function noop$5() {
}
react_production.Children = {
  map: mapChildren,
  forEach: function(children, forEachFunc, forEachContext) {
    mapChildren(
      children,
      function() {
        forEachFunc.apply(this, arguments);
      },
      forEachContext
    );
  },
  count: function(children) {
    var n = 0;
    mapChildren(children, function() {
      n++;
    });
    return n;
  },
  toArray: function(children) {
    return mapChildren(children, function(child) {
      return child;
    }) || [];
  },
  only: function(children) {
    if (!isValidElement(children))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return children;
  }
};
react_production.Component = Component;
react_production.Fragment = REACT_FRAGMENT_TYPE$1;
react_production.Profiler = REACT_PROFILER_TYPE$1;
react_production.PureComponent = PureComponent;
react_production.StrictMode = REACT_STRICT_MODE_TYPE$1;
react_production.Suspense = REACT_SUSPENSE_TYPE$1;
react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals$2;
react_production.__COMPILER_RUNTIME = {
  __proto__: null,
  c: function(size) {
    return ReactSharedInternals$2.H.useMemoCache(size);
  }
};
react_production.cache = function(fn) {
  return function() {
    return fn.apply(null, arguments);
  };
};
react_production.cloneElement = function(element, config, children) {
  if (null === element || void 0 === element)
    throw Error(
      "The argument must be a React element, but you passed " + element + "."
    );
  var props = assign$1({}, element.props), key = element.key, owner = void 0;
  if (null != config)
    for (propName in void 0 !== config.ref && (owner = void 0), void 0 !== config.key && (key = "" + config.key), config)
      !hasOwnProperty$1.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
  var propName = arguments.length - 2;
  if (1 === propName) props.children = children;
  else if (1 < propName) {
    for (var childArray = Array(propName), i = 0; i < propName; i++)
      childArray[i] = arguments[i + 2];
    props.children = childArray;
  }
  return ReactElement(element.type, key, void 0, void 0, owner, props);
};
react_production.createContext = function(defaultValue) {
  defaultValue = {
    $$typeof: REACT_CONTEXT_TYPE$1,
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    _threadCount: 0,
    Provider: null,
    Consumer: null
  };
  defaultValue.Provider = defaultValue;
  defaultValue.Consumer = {
    $$typeof: REACT_CONSUMER_TYPE$1,
    _context: defaultValue
  };
  return defaultValue;
};
react_production.createElement = function(type, config, children) {
  var propName, props = {}, key = null;
  if (null != config)
    for (propName in void 0 !== config.key && (key = "" + config.key), config)
      hasOwnProperty$1.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
  var childrenLength = arguments.length - 2;
  if (1 === childrenLength) props.children = children;
  else if (1 < childrenLength) {
    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
      childArray[i] = arguments[i + 2];
    props.children = childArray;
  }
  if (type && type.defaultProps)
    for (propName in childrenLength = type.defaultProps, childrenLength)
      void 0 === props[propName] && (props[propName] = childrenLength[propName]);
  return ReactElement(type, key, void 0, void 0, null, props);
};
react_production.createRef = function() {
  return { current: null };
};
react_production.forwardRef = function(render) {
  return { $$typeof: REACT_FORWARD_REF_TYPE$1, render };
};
react_production.isValidElement = isValidElement;
react_production.lazy = function(ctor) {
  return {
    $$typeof: REACT_LAZY_TYPE$1,
    _payload: { _status: -1, _result: ctor },
    _init: lazyInitializer
  };
};
react_production.memo = function(type, compare) {
  return {
    $$typeof: REACT_MEMO_TYPE$1,
    type,
    compare: void 0 === compare ? null : compare
  };
};
react_production.startTransition = function(scope) {
  var prevTransition = ReactSharedInternals$2.T, currentTransition = {};
  ReactSharedInternals$2.T = currentTransition;
  try {
    var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals$2.S;
    null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
    "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop$5, reportGlobalError$1);
  } catch (error) {
    reportGlobalError$1(error);
  } finally {
    ReactSharedInternals$2.T = prevTransition;
  }
};
react_production.unstable_useCacheRefresh = function() {
  return ReactSharedInternals$2.H.useCacheRefresh();
};
react_production.use = function(usable) {
  return ReactSharedInternals$2.H.use(usable);
};
react_production.useActionState = function(action, initialState, permalink) {
  return ReactSharedInternals$2.H.useActionState(action, initialState, permalink);
};
react_production.useCallback = function(callback, deps) {
  return ReactSharedInternals$2.H.useCallback(callback, deps);
};
react_production.useContext = function(Context) {
  return ReactSharedInternals$2.H.useContext(Context);
};
react_production.useDebugValue = function() {
};
react_production.useDeferredValue = function(value, initialValue) {
  return ReactSharedInternals$2.H.useDeferredValue(value, initialValue);
};
react_production.useEffect = function(create, createDeps, update) {
  var dispatcher = ReactSharedInternals$2.H;
  if ("function" === typeof update)
    throw Error(
      "useEffect CRUD overload is not enabled in this build of React."
    );
  return dispatcher.useEffect(create, createDeps);
};
react_production.useId = function() {
  return ReactSharedInternals$2.H.useId();
};
react_production.useImperativeHandle = function(ref, create, deps) {
  return ReactSharedInternals$2.H.useImperativeHandle(ref, create, deps);
};
react_production.useInsertionEffect = function(create, deps) {
  return ReactSharedInternals$2.H.useInsertionEffect(create, deps);
};
react_production.useLayoutEffect = function(create, deps) {
  return ReactSharedInternals$2.H.useLayoutEffect(create, deps);
};
react_production.useMemo = function(create, deps) {
  return ReactSharedInternals$2.H.useMemo(create, deps);
};
react_production.useOptimistic = function(passthrough, reducer) {
  return ReactSharedInternals$2.H.useOptimistic(passthrough, reducer);
};
react_production.useReducer = function(reducer, initialArg, init) {
  return ReactSharedInternals$2.H.useReducer(reducer, initialArg, init);
};
react_production.useRef = function(initialValue) {
  return ReactSharedInternals$2.H.useRef(initialValue);
};
react_production.useState = function(initialState) {
  return ReactSharedInternals$2.H.useState(initialState);
};
react_production.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
  return ReactSharedInternals$2.H.useSyncExternalStore(
    subscribe,
    getSnapshot,
    getServerSnapshot
  );
};
react_production.useTransition = function() {
  return ReactSharedInternals$2.H.useTransition();
};
react_production.version = "19.1.1";
{
  react.exports = react_production;
}
var reactExports = react.exports;
const React$2 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
var reactDom = { exports: {} };
var reactDom_production = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var React$1 = reactExports;
function formatProdErrorMessage$1(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2; i < arguments.length; i++)
      url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
function noop$4() {
}
var Internals = {
  d: {
    f: noop$4,
    r: function() {
      throw Error(formatProdErrorMessage$1(522));
    },
    D: noop$4,
    C: noop$4,
    L: noop$4,
    m: noop$4,
    X: noop$4,
    S: noop$4,
    M: noop$4
  },
  p: 0,
  findDOMNode: null
}, REACT_PORTAL_TYPE$1 = Symbol.for("react.portal");
function createPortal$1(children, containerInfo, implementation) {
  var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return {
    $$typeof: REACT_PORTAL_TYPE$1,
    key: null == key ? null : "" + key,
    children,
    containerInfo,
    implementation
  };
}
var ReactSharedInternals$1 = React$1.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
function getCrossOriginStringAs(as, input) {
  if ("font" === as) return "";
  if ("string" === typeof input)
    return "use-credentials" === input ? input : "";
}
reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
reactDom_production.createPortal = function(children, container2) {
  var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!container2 || 1 !== container2.nodeType && 9 !== container2.nodeType && 11 !== container2.nodeType)
    throw Error(formatProdErrorMessage$1(299));
  return createPortal$1(children, container2, null, key);
};
reactDom_production.flushSync = function(fn) {
  var previousTransition = ReactSharedInternals$1.T, previousUpdatePriority = Internals.p;
  try {
    if (ReactSharedInternals$1.T = null, Internals.p = 2, fn) return fn();
  } finally {
    ReactSharedInternals$1.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
  }
};
reactDom_production.preconnect = function(href, options) {
  "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
};
reactDom_production.prefetchDNS = function(href) {
  "string" === typeof href && Internals.d.D(href);
};
reactDom_production.preinit = function(href, options) {
  if ("string" === typeof href && options && "string" === typeof options.as) {
    var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
    "style" === as ? Internals.d.S(
      href,
      "string" === typeof options.precedence ? options.precedence : void 0,
      {
        crossOrigin,
        integrity,
        fetchPriority
      }
    ) : "script" === as && Internals.d.X(href, {
      crossOrigin,
      integrity,
      fetchPriority,
      nonce: "string" === typeof options.nonce ? options.nonce : void 0
    });
  }
};
reactDom_production.preinitModule = function(href, options) {
  if ("string" === typeof href)
    if ("object" === typeof options && null !== options) {
      if (null == options.as || "script" === options.as) {
        var crossOrigin = getCrossOriginStringAs(
          options.as,
          options.crossOrigin
        );
        Internals.d.M(href, {
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    } else null == options && Internals.d.M(href);
};
reactDom_production.preload = function(href, options) {
  if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
    var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
    Internals.d.L(href, as, {
      crossOrigin,
      integrity: "string" === typeof options.integrity ? options.integrity : void 0,
      nonce: "string" === typeof options.nonce ? options.nonce : void 0,
      type: "string" === typeof options.type ? options.type : void 0,
      fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
      referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
      imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
      imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
      media: "string" === typeof options.media ? options.media : void 0
    });
  }
};
reactDom_production.preloadModule = function(href, options) {
  if ("string" === typeof href)
    if (options) {
      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
      Internals.d.m(href, {
        as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
        crossOrigin,
        integrity: "string" === typeof options.integrity ? options.integrity : void 0
      });
    } else Internals.d.m(href);
};
reactDom_production.requestFormReset = function(form) {
  Internals.d.r(form);
};
reactDom_production.unstable_batchedUpdates = function(fn, a) {
  return fn(a);
};
reactDom_production.useFormState = function(action, initialState, permalink) {
  return ReactSharedInternals$1.H.useFormState(action, initialState, permalink);
};
reactDom_production.useFormStatus = function() {
  return ReactSharedInternals$1.H.useHostTransitionStatus();
};
reactDom_production.version = "19.1.1";
function checkDCE$1() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE$1);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE$1();
  reactDom.exports = reactDom_production;
}
var reactDomExports = reactDom.exports;
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Scheduler = schedulerExports, React = reactExports, ReactDOM = reactDomExports;
function formatProdErrorMessage(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2; i < arguments.length; i++)
      url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
function isValidContainer(node) {
  return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
}
function getNearestMountedFiber(fiber) {
  var node = fiber, nearestMounted = fiber;
  if (fiber.alternate) for (; node.return; ) node = node.return;
  else {
    fiber = node;
    do
      node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
    while (fiber);
  }
  return 3 === node.tag ? nearestMounted : null;
}
function getSuspenseInstanceFromFiber(fiber) {
  if (13 === fiber.tag) {
    var suspenseState = fiber.memoizedState;
    null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
    if (null !== suspenseState) return suspenseState.dehydrated;
  }
  return null;
}
function assertIsMounted(fiber) {
  if (getNearestMountedFiber(fiber) !== fiber)
    throw Error(formatProdErrorMessage(188));
}
function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    alternate = getNearestMountedFiber(fiber);
    if (null === alternate) throw Error(formatProdErrorMessage(188));
    return alternate !== fiber ? null : fiber;
  }
  for (var a = fiber, b = alternate; ; ) {
    var parentA = a.return;
    if (null === parentA) break;
    var parentB = parentA.alternate;
    if (null === parentB) {
      b = parentA.return;
      if (null !== b) {
        a = b;
        continue;
      }
      break;
    }
    if (parentA.child === parentB.child) {
      for (parentB = parentA.child; parentB; ) {
        if (parentB === a) return assertIsMounted(parentA), fiber;
        if (parentB === b) return assertIsMounted(parentA), alternate;
        parentB = parentB.sibling;
      }
      throw Error(formatProdErrorMessage(188));
    }
    if (a.return !== b.return) a = parentA, b = parentB;
    else {
      for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
        if (child$0 === a) {
          didFindChild = true;
          a = parentA;
          b = parentB;
          break;
        }
        if (child$0 === b) {
          didFindChild = true;
          b = parentA;
          a = parentB;
          break;
        }
        child$0 = child$0.sibling;
      }
      if (!didFindChild) {
        for (child$0 = parentB.child; child$0; ) {
          if (child$0 === a) {
            didFindChild = true;
            a = parentB;
            b = parentA;
            break;
          }
          if (child$0 === b) {
            didFindChild = true;
            b = parentB;
            a = parentA;
            break;
          }
          child$0 = child$0.sibling;
        }
        if (!didFindChild) throw Error(formatProdErrorMessage(189));
      }
    }
    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
  }
  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
  return a.stateNode.current === a ? fiber : alternate;
}
function findCurrentHostFiberImpl(node) {
  var tag = node.tag;
  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
  for (node = node.child; null !== node; ) {
    tag = findCurrentHostFiberImpl(node);
    if (null !== tag) return tag;
    node = node.sibling;
  }
  return null;
}
var assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
function getIteratorFn(maybeIterable) {
  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
  maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
  return "function" === typeof maybeIterable ? maybeIterable : null;
}
var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
function getComponentNameFromType(type) {
  if (null == type) return null;
  if ("function" === typeof type)
    return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
  if ("string" === typeof type) return type;
  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return "Fragment";
    case REACT_PROFILER_TYPE:
      return "Profiler";
    case REACT_STRICT_MODE_TYPE:
      return "StrictMode";
    case REACT_SUSPENSE_TYPE:
      return "Suspense";
    case REACT_SUSPENSE_LIST_TYPE:
      return "SuspenseList";
    case REACT_ACTIVITY_TYPE:
      return "Activity";
  }
  if ("object" === typeof type)
    switch (type.$$typeof) {
      case REACT_PORTAL_TYPE:
        return "Portal";
      case REACT_CONTEXT_TYPE:
        return (type.displayName || "Context") + ".Provider";
      case REACT_CONSUMER_TYPE:
        return (type._context.displayName || "Context") + ".Consumer";
      case REACT_FORWARD_REF_TYPE:
        var innerType = type.render;
        type = type.displayName;
        type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
        return type;
      case REACT_MEMO_TYPE:
        return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
      case REACT_LAZY_TYPE:
        innerType = type._payload;
        type = type._init;
        try {
          return getComponentNameFromType(type(innerType));
        } catch (x) {
        }
    }
  return null;
}
var isArrayImpl = Array.isArray, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
  pending: false,
  data: null,
  method: null,
  action: null
}, valueStack = [], index = -1;
function createCursor(defaultValue) {
  return { current: defaultValue };
}
function pop(cursor) {
  0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
}
function push(cursor, value) {
  index++;
  valueStack[index] = cursor.current;
  cursor.current = value;
}
var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
function pushHostContainer(fiber, nextRootInstance) {
  push(rootInstanceStackCursor, nextRootInstance);
  push(contextFiberStackCursor, fiber);
  push(contextStackCursor, null);
  switch (nextRootInstance.nodeType) {
    case 9:
    case 11:
      fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
      break;
    default:
      if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
        nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
      else
        switch (fiber) {
          case "svg":
            fiber = 1;
            break;
          case "math":
            fiber = 2;
            break;
          default:
            fiber = 0;
        }
  }
  pop(contextStackCursor);
  push(contextStackCursor, fiber);
}
function popHostContainer() {
  pop(contextStackCursor);
  pop(contextFiberStackCursor);
  pop(rootInstanceStackCursor);
}
function pushHostContext(fiber) {
  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
  var context = contextStackCursor.current;
  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
  context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
}
function popHostContext(fiber) {
  contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
  hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
}
var hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
function setIsStrictModeForDevtools(newIsStrictMode) {
  "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
  if (injectedHook && "function" === typeof injectedHook.setStrictMode)
    try {
      injectedHook.setStrictMode(rendererID, newIsStrictMode);
    } catch (err) {
    }
}
var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
function clz32Fallback(x) {
  x >>>= 0;
  return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
}
var nextTransitionLane = 256, nextRetryLane = 4194304;
function getHighestPriorityLanes(lanes) {
  var pendingSyncLanes = lanes & 42;
  if (0 !== pendingSyncLanes) return pendingSyncLanes;
  switch (lanes & -lanes) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
      return 64;
    case 128:
      return 128;
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return lanes & 4194048;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return lanes & 62914560;
    case 67108864:
      return 67108864;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 0;
    default:
      return lanes;
  }
}
function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
  var pendingLanes = root2.pendingLanes;
  if (0 === pendingLanes) return 0;
  var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
  root2 = root2.warmLanes;
  var nonIdlePendingLanes = pendingLanes & 134217727;
  0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
  return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
}
function checkIfRootIsPrerendering(root2, renderLanes2) {
  return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
}
function computeExpirationTime(lane, currentTime) {
  switch (lane) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 64:
      return currentTime + 250;
    case 16:
    case 32:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return currentTime + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return -1;
    case 67108864:
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function claimNextTransitionLane() {
  var lane = nextTransitionLane;
  nextTransitionLane <<= 1;
  0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
  return lane;
}
function claimNextRetryLane() {
  var lane = nextRetryLane;
  nextRetryLane <<= 1;
  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
  return lane;
}
function createLaneMap(initial) {
  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
  return laneMap;
}
function markRootUpdated$1(root2, updateLane) {
  root2.pendingLanes |= updateLane;
  268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
}
function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
  var previouslyPendingLanes = root2.pendingLanes;
  root2.pendingLanes = remainingLanes;
  root2.suspendedLanes = 0;
  root2.pingedLanes = 0;
  root2.warmLanes = 0;
  root2.expiredLanes &= remainingLanes;
  root2.entangledLanes &= remainingLanes;
  root2.errorRecoveryDisabledLanes &= remainingLanes;
  root2.shellSuspendCounter = 0;
  var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
  for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
    var index$5 = 31 - clz32(remainingLanes), lane = 1 << index$5;
    entanglements[index$5] = 0;
    expirationTimes[index$5] = -1;
    var hiddenUpdatesForLane = hiddenUpdates[index$5];
    if (null !== hiddenUpdatesForLane)
      for (hiddenUpdates[index$5] = null, index$5 = 0; index$5 < hiddenUpdatesForLane.length; index$5++) {
        var update = hiddenUpdatesForLane[index$5];
        null !== update && (update.lane &= -536870913);
      }
    remainingLanes &= ~lane;
  }
  0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
  0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
}
function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
  root2.pendingLanes |= spawnedLane;
  root2.suspendedLanes &= ~spawnedLane;
  var spawnedLaneIndex = 31 - clz32(spawnedLane);
  root2.entangledLanes |= spawnedLane;
  root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
}
function markRootEntangled(root2, entangledLanes) {
  var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
  for (root2 = root2.entanglements; rootEntangledLanes; ) {
    var index$6 = 31 - clz32(rootEntangledLanes), lane = 1 << index$6;
    lane & entangledLanes | root2[index$6] & entangledLanes && (root2[index$6] |= entangledLanes);
    rootEntangledLanes &= ~lane;
  }
}
function getBumpedLaneForHydrationByLane(lane) {
  switch (lane) {
    case 2:
      lane = 1;
      break;
    case 8:
      lane = 4;
      break;
    case 32:
      lane = 16;
      break;
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      lane = 128;
      break;
    case 268435456:
      lane = 134217728;
      break;
    default:
      lane = 0;
  }
  return lane;
}
function lanesToEventPriority(lanes) {
  lanes &= -lanes;
  return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
}
function resolveUpdatePriority() {
  var updatePriority = ReactDOMSharedInternals.p;
  if (0 !== updatePriority) return updatePriority;
  updatePriority = window.event;
  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
}
function runWithPriority(priority, fn) {
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    return ReactDOMSharedInternals.p = priority, fn();
  } finally {
    ReactDOMSharedInternals.p = previousPriority;
  }
}
var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
function detachDeletedInstance(node) {
  delete node[internalInstanceKey];
  delete node[internalPropsKey];
  delete node[internalEventHandlersKey];
  delete node[internalEventHandlerListenersKey];
  delete node[internalEventHandlesSetKey];
}
function getClosestInstanceFromNode(targetNode) {
  var targetInst = targetNode[internalInstanceKey];
  if (targetInst) return targetInst;
  for (var parentNode = targetNode.parentNode; parentNode; ) {
    if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
      parentNode = targetInst.alternate;
      if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
        for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
          if (parentNode = targetNode[internalInstanceKey]) return parentNode;
          targetNode = getParentSuspenseInstance(targetNode);
        }
      return targetInst;
    }
    targetNode = parentNode;
    parentNode = targetNode.parentNode;
  }
  return null;
}
function getInstanceFromNode(node) {
  if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
    var tag = node.tag;
    if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
      return node;
  }
  return null;
}
function getNodeFromInstance(inst) {
  var tag = inst.tag;
  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
  throw Error(formatProdErrorMessage(33));
}
function getResourcesFromRoot(root2) {
  var resources = root2[internalRootNodeResourcesKey];
  resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
  return resources;
}
function markNodeAsHoistable(node) {
  node[internalHoistableMarker] = true;
}
var allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {};
function registerTwoPhaseEvent(registrationName, dependencies) {
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + "Capture", dependencies);
}
function registerDirectEvent(registrationName, dependencies) {
  registrationNameDependencies[registrationName] = dependencies;
  for (registrationName = 0; registrationName < dependencies.length; registrationName++)
    allNativeEvents.add(dependencies[registrationName]);
}
var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
  "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
    return true;
  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
    return validatedAttributeNameCache[attributeName] = true;
  illegalAttributeNameCache[attributeName] = true;
  return false;
}
function setValueForAttribute(node, name, value) {
  if (isAttributeNameSafe(name))
    if (null === value) node.removeAttribute(name);
    else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
          node.removeAttribute(name);
          return;
        case "boolean":
          var prefix$8 = name.toLowerCase().slice(0, 5);
          if ("data-" !== prefix$8 && "aria-" !== prefix$8) {
            node.removeAttribute(name);
            return;
          }
      }
      node.setAttribute(name, "" + value);
    }
}
function setValueForKnownAttribute(node, name, value) {
  if (null === value) node.removeAttribute(name);
  else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        node.removeAttribute(name);
        return;
    }
    node.setAttribute(name, "" + value);
  }
}
function setValueForNamespacedAttribute(node, namespace, name, value) {
  if (null === value) node.removeAttribute(name);
  else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        node.removeAttribute(name);
        return;
    }
    node.setAttributeNS(namespace, name, "" + value);
  }
}
var prefix, suffix;
function describeBuiltInComponentFrame(name) {
  if (void 0 === prefix)
    try {
      throw Error();
    } catch (x) {
      var match = x.stack.trim().match(/\n( *(at )?)/);
      prefix = match && match[1] || "";
      suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
    }
  return "\n" + prefix + name + suffix;
}
var reentry = false;
function describeNativeComponentFrame(fn, construct) {
  if (!fn || reentry) return "";
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    var RunInRootFrame = {
      DetermineComponentFrameRoot: function() {
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if ("object" === typeof Reflect && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                var control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x$9) {
                control = x$9;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x$10) {
              control = x$10;
            }
            (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
            });
          }
        } catch (sample) {
          if (sample && control && "string" === typeof sample.stack)
            return [sample.stack, control.stack];
        }
        return [null, null];
      }
    };
    RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
    var namePropDescriptor = Object.getOwnPropertyDescriptor(
      RunInRootFrame.DetermineComponentFrameRoot,
      "name"
    );
    namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
      RunInRootFrame.DetermineComponentFrameRoot,
      "name",
      { value: "DetermineComponentFrameRoot" }
    );
    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
    if (sampleStack && controlStack) {
      var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
      for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
        RunInRootFrame++;
      for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
        "DetermineComponentFrameRoot"
      ); )
        namePropDescriptor++;
      if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
        for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
          namePropDescriptor--;
      for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
            do
              if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                return frame;
              }
            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
          }
          break;
        }
    }
  } finally {
    reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
  }
  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
}
function describeFiber(fiber) {
  switch (fiber.tag) {
    case 26:
    case 27:
    case 5:
      return describeBuiltInComponentFrame(fiber.type);
    case 16:
      return describeBuiltInComponentFrame("Lazy");
    case 13:
      return describeBuiltInComponentFrame("Suspense");
    case 19:
      return describeBuiltInComponentFrame("SuspenseList");
    case 0:
    case 15:
      return describeNativeComponentFrame(fiber.type, false);
    case 11:
      return describeNativeComponentFrame(fiber.type.render, false);
    case 1:
      return describeNativeComponentFrame(fiber.type, true);
    case 31:
      return describeBuiltInComponentFrame("Activity");
    default:
      return "";
  }
}
function getStackByFiberInDevAndProd(workInProgress2) {
  try {
    var info = "";
    do
      info += describeFiber(workInProgress2), workInProgress2 = workInProgress2.return;
    while (workInProgress2);
    return info;
  } catch (x) {
    return "\nError generating stack: " + x.message + "\n" + x.stack;
  }
}
function getToStringValue(value) {
  switch (typeof value) {
    case "bigint":
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return value;
    case "object":
      return value;
    default:
      return "";
  }
}
function isCheckable(elem) {
  var type = elem.type;
  return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
}
function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
    node.constructor.prototype,
    valueField
  ), currentValue = "" + node[valueField];
  if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
    var get = descriptor.get, set = descriptor.set;
    Object.defineProperty(node, valueField, {
      configurable: true,
      get: function() {
        return get.call(this);
      },
      set: function(value) {
        currentValue = "" + value;
        set.call(this, value);
      }
    });
    Object.defineProperty(node, valueField, {
      enumerable: descriptor.enumerable
    });
    return {
      getValue: function() {
        return currentValue;
      },
      setValue: function(value) {
        currentValue = "" + value;
      },
      stopTracking: function() {
        node._valueTracker = null;
        delete node[valueField];
      }
    };
  }
}
function track(node) {
  node._valueTracker || (node._valueTracker = trackValueOnNode(node));
}
function updateValueIfChanged(node) {
  if (!node) return false;
  var tracker = node._valueTracker;
  if (!tracker) return true;
  var lastValue = tracker.getValue();
  var value = "";
  node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
  node = value;
  return node !== lastValue ? (tracker.setValue(node), true) : false;
}
function getActiveElement(doc) {
  doc = doc || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof doc) return null;
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}
var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
  return value.replace(
    escapeSelectorAttributeValueInsideDoubleQuotesRegex,
    function(ch) {
      return "\\" + ch.charCodeAt(0).toString(16) + " ";
    }
  );
}
function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
  element.name = "";
  null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
  if (null != value)
    if ("number" === type) {
      if (0 === value && "" === element.value || element.value != value)
        element.value = "" + getToStringValue(value);
    } else
      element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
  else
    "submit" !== type && "reset" !== type || element.removeAttribute("value");
  null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
  null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
  null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
  null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
}
function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
  null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
  if (null != value || null != defaultValue) {
    if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value))
      return;
    defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    value = null != value ? "" + getToStringValue(value) : defaultValue;
    isHydrating2 || value === element.value || (element.value = value);
    element.defaultValue = value;
  }
  checked = null != checked ? checked : defaultChecked;
  checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
  element.checked = isHydrating2 ? element.checked : !!checked;
  element.defaultChecked = !!checked;
  null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
}
function setDefaultValue(node, type, value) {
  "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
}
function updateOptions(node, multiple, propValue, setDefaultSelected) {
  node = node.options;
  if (multiple) {
    multiple = {};
    for (var i = 0; i < propValue.length; i++)
      multiple["$" + propValue[i]] = true;
    for (propValue = 0; propValue < node.length; propValue++)
      i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
  } else {
    propValue = "" + getToStringValue(propValue);
    multiple = null;
    for (i = 0; i < node.length; i++) {
      if (node[i].value === propValue) {
        node[i].selected = true;
        setDefaultSelected && (node[i].defaultSelected = true);
        return;
      }
      null !== multiple || node[i].disabled || (multiple = node[i]);
    }
    null !== multiple && (multiple.selected = true);
  }
}
function updateTextarea(element, value, defaultValue) {
  if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
    element.defaultValue !== value && (element.defaultValue = value);
    return;
  }
  element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
}
function initTextarea(element, value, defaultValue, children) {
  if (null == value) {
    if (null != children) {
      if (null != defaultValue) throw Error(formatProdErrorMessage(92));
      if (isArrayImpl(children)) {
        if (1 < children.length) throw Error(formatProdErrorMessage(93));
        children = children[0];
      }
      defaultValue = children;
    }
    null == defaultValue && (defaultValue = "");
    value = defaultValue;
  }
  defaultValue = getToStringValue(value);
  element.defaultValue = defaultValue;
  children = element.textContent;
  children === defaultValue && "" !== children && null !== children && (element.value = children);
}
function setTextContent(node, text) {
  if (text) {
    var firstChild = node.firstChild;
    if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
}
var unitlessNumbers = new Set(
  "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
    " "
  )
);
function setValueForStyle(style2, styleName, value) {
  var isCustomProperty = 0 === styleName.indexOf("--");
  null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
}
function setValueForStyles(node, styles, prevStyles) {
  if (null != styles && "object" !== typeof styles)
    throw Error(formatProdErrorMessage(62));
  node = node.style;
  if (null != prevStyles) {
    for (var styleName in prevStyles)
      !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
    for (var styleName$16 in styles)
      styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
  } else
    for (var styleName$17 in styles)
      styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
}
function isCustomElement(tagName) {
  if (-1 === tagName.indexOf("-")) return false;
  switch (tagName) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var aliases = /* @__PURE__ */ new Map([
  ["acceptCharset", "accept-charset"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
  ["crossOrigin", "crossorigin"],
  ["accentHeight", "accent-height"],
  ["alignmentBaseline", "alignment-baseline"],
  ["arabicForm", "arabic-form"],
  ["baselineShift", "baseline-shift"],
  ["capHeight", "cap-height"],
  ["clipPath", "clip-path"],
  ["clipRule", "clip-rule"],
  ["colorInterpolation", "color-interpolation"],
  ["colorInterpolationFilters", "color-interpolation-filters"],
  ["colorProfile", "color-profile"],
  ["colorRendering", "color-rendering"],
  ["dominantBaseline", "dominant-baseline"],
  ["enableBackground", "enable-background"],
  ["fillOpacity", "fill-opacity"],
  ["fillRule", "fill-rule"],
  ["floodColor", "flood-color"],
  ["floodOpacity", "flood-opacity"],
  ["fontFamily", "font-family"],
  ["fontSize", "font-size"],
  ["fontSizeAdjust", "font-size-adjust"],
  ["fontStretch", "font-stretch"],
  ["fontStyle", "font-style"],
  ["fontVariant", "font-variant"],
  ["fontWeight", "font-weight"],
  ["glyphName", "glyph-name"],
  ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
  ["glyphOrientationVertical", "glyph-orientation-vertical"],
  ["horizAdvX", "horiz-adv-x"],
  ["horizOriginX", "horiz-origin-x"],
  ["imageRendering", "image-rendering"],
  ["letterSpacing", "letter-spacing"],
  ["lightingColor", "lighting-color"],
  ["markerEnd", "marker-end"],
  ["markerMid", "marker-mid"],
  ["markerStart", "marker-start"],
  ["overlinePosition", "overline-position"],
  ["overlineThickness", "overline-thickness"],
  ["paintOrder", "paint-order"],
  ["panose-1", "panose-1"],
  ["pointerEvents", "pointer-events"],
  ["renderingIntent", "rendering-intent"],
  ["shapeRendering", "shape-rendering"],
  ["stopColor", "stop-color"],
  ["stopOpacity", "stop-opacity"],
  ["strikethroughPosition", "strikethrough-position"],
  ["strikethroughThickness", "strikethrough-thickness"],
  ["strokeDasharray", "stroke-dasharray"],
  ["strokeDashoffset", "stroke-dashoffset"],
  ["strokeLinecap", "stroke-linecap"],
  ["strokeLinejoin", "stroke-linejoin"],
  ["strokeMiterlimit", "stroke-miterlimit"],
  ["strokeOpacity", "stroke-opacity"],
  ["strokeWidth", "stroke-width"],
  ["textAnchor", "text-anchor"],
  ["textDecoration", "text-decoration"],
  ["textRendering", "text-rendering"],
  ["transformOrigin", "transform-origin"],
  ["underlinePosition", "underline-position"],
  ["underlineThickness", "underline-thickness"],
  ["unicodeBidi", "unicode-bidi"],
  ["unicodeRange", "unicode-range"],
  ["unitsPerEm", "units-per-em"],
  ["vAlphabetic", "v-alphabetic"],
  ["vHanging", "v-hanging"],
  ["vIdeographic", "v-ideographic"],
  ["vMathematical", "v-mathematical"],
  ["vectorEffect", "vector-effect"],
  ["vertAdvY", "vert-adv-y"],
  ["vertOriginX", "vert-origin-x"],
  ["vertOriginY", "vert-origin-y"],
  ["wordSpacing", "word-spacing"],
  ["writingMode", "writing-mode"],
  ["xmlnsXlink", "xmlns:xlink"],
  ["xHeight", "x-height"]
]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
function sanitizeURL(url) {
  return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
}
var currentReplayingEvent = null;
function getEventTarget(nativeEvent) {
  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
  nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
}
var restoreTarget = null, restoreQueue = null;
function restoreStateOfTarget(target) {
  var internalInstance = getInstanceFromNode(target);
  if (internalInstance && (target = internalInstance.stateNode)) {
    var props = target[internalPropsKey] || null;
    a: switch (target = internalInstance.stateNode, internalInstance.type) {
      case "input":
        updateInput(
          target,
          props.value,
          props.defaultValue,
          props.defaultValue,
          props.checked,
          props.defaultChecked,
          props.type,
          props.name
        );
        internalInstance = props.name;
        if ("radio" === props.type && null != internalInstance) {
          for (props = target; props.parentNode; ) props = props.parentNode;
          props = props.querySelectorAll(
            'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
              "" + internalInstance
            ) + '"][type="radio"]'
          );
          for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
            var otherNode = props[internalInstance];
            if (otherNode !== target && otherNode.form === target.form) {
              var otherProps = otherNode[internalPropsKey] || null;
              if (!otherProps) throw Error(formatProdErrorMessage(90));
              updateInput(
                otherNode,
                otherProps.value,
                otherProps.defaultValue,
                otherProps.defaultValue,
                otherProps.checked,
                otherProps.defaultChecked,
                otherProps.type,
                otherProps.name
              );
            }
          }
          for (internalInstance = 0; internalInstance < props.length; internalInstance++)
            otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
        }
        break a;
      case "textarea":
        updateTextarea(target, props.value, props.defaultValue);
        break a;
      case "select":
        internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
    }
  }
}
var isInsideEventHandler = false;
function batchedUpdates$1(fn, a, b) {
  if (isInsideEventHandler) return fn(a, b);
  isInsideEventHandler = true;
  try {
    var JSCompiler_inline_result = fn(a);
    return JSCompiler_inline_result;
  } finally {
    if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
      if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
    }
  }
}
function getListener(inst, registrationName) {
  var stateNode = inst.stateNode;
  if (null === stateNode) return null;
  var props = stateNode[internalPropsKey] || null;
  if (null === props) return null;
  stateNode = props[registrationName];
  a: switch (registrationName) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
      inst = !props;
      break a;
    default:
      inst = false;
  }
  if (inst) return null;
  if (stateNode && "function" !== typeof stateNode)
    throw Error(
      formatProdErrorMessage(231, registrationName, typeof stateNode)
    );
  return stateNode;
}
var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
if (canUseDOM)
  try {
    var options = {};
    Object.defineProperty(options, "passive", {
      get: function() {
        passiveBrowserEventsSupported = true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (e) {
    passiveBrowserEventsSupported = false;
  }
var root = null, startText = null, fallbackText = null;
function getData() {
  if (fallbackText) return fallbackText;
  var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
  for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
  var minEnd = startLength - start;
  for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
  return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
}
function getEventCharCode(nativeEvent) {
  var keyCode = nativeEvent.keyCode;
  "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
  10 === nativeEvent && (nativeEvent = 13);
  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
}
function functionThatReturnsTrue() {
  return true;
}
function functionThatReturnsFalse() {
  return false;
}
function createSyntheticEvent(Interface) {
  function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
    this._reactName = reactName;
    this._targetInst = targetInst;
    this.type = reactEventType;
    this.nativeEvent = nativeEvent;
    this.target = nativeEventTarget;
    this.currentTarget = null;
    for (var propName in Interface)
      Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
    this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }
  assign(SyntheticBaseEvent.prototype, {
    preventDefault: function() {
      this.defaultPrevented = true;
      var event = this.nativeEvent;
      event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
    },
    stopPropagation: function() {
      var event = this.nativeEvent;
      event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
    },
    persist: function() {
    },
    isPersistent: functionThatReturnsTrue
  });
  return SyntheticBaseEvent;
}
var EventInterface = {
  eventPhase: 0,
  bubbles: 0,
  cancelable: 0,
  timeStamp: function(event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: 0,
  isTrusted: 0
}, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
  screenX: 0,
  screenY: 0,
  clientX: 0,
  clientY: 0,
  pageX: 0,
  pageY: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  getModifierState: getEventModifierState,
  button: 0,
  buttons: 0,
  relatedTarget: function(event) {
    return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
  },
  movementX: function(event) {
    if ("movementX" in event) return event.movementX;
    event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
    return lastMovementX;
  },
  movementY: function(event) {
    return "movementY" in event ? event.movementY : lastMovementY;
  }
}), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
  animationName: 0,
  elapsedTime: 0,
  pseudoElement: 0
}), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
  clipboardData: function(event) {
    return "clipboardData" in event ? event.clipboardData : window.clipboardData;
  }
}), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, translateToKey = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, modifierKeyToProp = {
  Alt: "altKey",
  Control: "ctrlKey",
  Meta: "metaKey",
  Shift: "shiftKey"
};
function modifierStateGetter(keyArg) {
  var nativeEvent = this.nativeEvent;
  return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
}
function getEventModifierState() {
  return modifierStateGetter;
}
var KeyboardEventInterface = assign({}, UIEventInterface, {
  key: function(nativeEvent) {
    if (nativeEvent.key) {
      var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
      if ("Unidentified" !== key) return key;
    }
    return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
  },
  code: 0,
  location: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  repeat: 0,
  locale: 0,
  getModifierState: getEventModifierState,
  charCode: function(event) {
    return "keypress" === event.type ? getEventCharCode(event) : 0;
  },
  keyCode: function(event) {
    return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
  },
  which: function(event) {
    return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
  }
}), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
  pointerId: 0,
  width: 0,
  height: 0,
  pressure: 0,
  tangentialPressure: 0,
  tiltX: 0,
  tiltY: 0,
  twist: 0,
  pointerType: 0,
  isPrimary: 0
}), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
  touches: 0,
  targetTouches: 0,
  changedTouches: 0,
  altKey: 0,
  metaKey: 0,
  ctrlKey: 0,
  shiftKey: 0,
  getModifierState: getEventModifierState
}), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
  propertyName: 0,
  elapsedTime: 0,
  pseudoElement: 0
}), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
  deltaX: function(event) {
    return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function(event) {
    return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
  newState: 0,
  oldState: 0
}), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
function isFallbackCompositionEnd(domEventName, nativeEvent) {
  switch (domEventName) {
    case "keyup":
      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
    case "keydown":
      return 229 !== nativeEvent.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function getDataFromCustomEvent(nativeEvent) {
  nativeEvent = nativeEvent.detail;
  return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
}
var isComposing = false;
function getNativeBeforeInputChars(domEventName, nativeEvent) {
  switch (domEventName) {
    case "compositionend":
      return getDataFromCustomEvent(nativeEvent);
    case "keypress":
      if (32 !== nativeEvent.which) return null;
      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;
    case "textInput":
      return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
    default:
      return null;
  }
}
function getFallbackBeforeInputChars(domEventName, nativeEvent) {
  if (isComposing)
    return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
  switch (domEventName) {
    case "paste":
      return null;
    case "keypress":
      if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
        if (nativeEvent.char && 1 < nativeEvent.char.length)
          return nativeEvent.char;
        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case "compositionend":
      return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
    default:
      return null;
  }
}
var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  "datetime-local": true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};
function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
}
function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
  restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
  inst = accumulateTwoPhaseListeners(inst, "onChange");
  0 < inst.length && (nativeEvent = new SyntheticEvent(
    "onChange",
    "change",
    null,
    nativeEvent,
    target
  ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
}
var activeElement$1 = null, activeElementInst$1 = null;
function runEventInBatch(dispatchQueue) {
  processDispatchQueue(dispatchQueue, 0);
}
function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance(targetInst);
  if (updateValueIfChanged(targetNode)) return targetInst;
}
function getTargetInstForChangeEvent(domEventName, targetInst) {
  if ("change" === domEventName) return targetInst;
}
var isInputEventSupported = false;
if (canUseDOM) {
  var JSCompiler_inline_result$jscomp$282;
  if (canUseDOM) {
    var isSupported$jscomp$inline_417 = "oninput" in document;
    if (!isSupported$jscomp$inline_417) {
      var element$jscomp$inline_418 = document.createElement("div");
      element$jscomp$inline_418.setAttribute("oninput", "return;");
      isSupported$jscomp$inline_417 = "function" === typeof element$jscomp$inline_418.oninput;
    }
    JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;
  } else JSCompiler_inline_result$jscomp$282 = false;
  isInputEventSupported = JSCompiler_inline_result$jscomp$282 && (!document.documentMode || 9 < document.documentMode);
}
function stopWatchingForValueChange() {
  activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
}
function handlePropertyChange(nativeEvent) {
  if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
    var dispatchQueue = [];
    createAndAccumulateChangeEvent(
      dispatchQueue,
      activeElementInst$1,
      nativeEvent,
      getEventTarget(nativeEvent)
    );
    batchedUpdates$1(runEventInBatch, dispatchQueue);
  }
}
function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
  "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
}
function getTargetInstForInputEventPolyfill(domEventName) {
  if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
    return getInstIfValueChanged(activeElementInst$1);
}
function getTargetInstForClickEvent(domEventName, targetInst) {
  if ("click" === domEventName) return getInstIfValueChanged(targetInst);
}
function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
  if ("input" === domEventName || "change" === domEventName)
    return getInstIfValueChanged(targetInst);
}
function is(x, y) {
  return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
}
var objectIs = "function" === typeof Object.is ? Object.is : is;
function shallowEqual(objA, objB) {
  if (objectIs(objA, objB)) return true;
  if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
    return false;
  var keysA = Object.keys(objA), keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return false;
  for (keysB = 0; keysB < keysA.length; keysB++) {
    var currentKey = keysA[keysB];
    if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
      return false;
  }
  return true;
}
function getLeafNode(node) {
  for (; node && node.firstChild; ) node = node.firstChild;
  return node;
}
function getNodeForCharacterOffset(root2, offset) {
  var node = getLeafNode(root2);
  root2 = 0;
  for (var nodeEnd; node; ) {
    if (3 === node.nodeType) {
      nodeEnd = root2 + node.textContent.length;
      if (root2 <= offset && nodeEnd >= offset)
        return { node, offset: offset - root2 };
      root2 = nodeEnd;
    }
    a: {
      for (; node; ) {
        if (node.nextSibling) {
          node = node.nextSibling;
          break a;
        }
        node = node.parentNode;
      }
      node = void 0;
    }
    node = getLeafNode(node);
  }
}
function containsNode(outerNode, innerNode) {
  return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
}
function getActiveElementDeep(containerInfo) {
  containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
  for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
    try {
      var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
    } catch (err) {
      JSCompiler_inline_result = false;
    }
    if (JSCompiler_inline_result) containerInfo = element.contentWindow;
    else break;
    element = getActiveElement(containerInfo.document);
  }
  return element;
}
function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
}
var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
  var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
  mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
    anchorNode: doc.anchorNode,
    anchorOffset: doc.anchorOffset,
    focusNode: doc.focusNode,
    focusOffset: doc.focusOffset
  }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
    "onSelect",
    "select",
    null,
    nativeEvent,
    nativeEventTarget
  ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
}
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit" + styleProp] = "webkit" + eventName;
  prefixes["Moz" + styleProp] = "moz" + eventName;
  return prefixes;
}
var vendorPrefixes = {
  animationend: makePrefixMap("Animation", "AnimationEnd"),
  animationiteration: makePrefixMap("Animation", "AnimationIteration"),
  animationstart: makePrefixMap("Animation", "AnimationStart"),
  transitionrun: makePrefixMap("Transition", "TransitionRun"),
  transitionstart: makePrefixMap("Transition", "TransitionStart"),
  transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
  transitionend: makePrefixMap("Transition", "TransitionEnd")
}, prefixedEventNames = {}, style = {};
canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
  if (!vendorPrefixes[eventName]) return eventName;
  var prefixMap = vendorPrefixes[eventName], styleProp;
  for (styleProp in prefixMap)
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
      return prefixedEventNames[eventName] = prefixMap[styleProp];
  return eventName;
}
var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
  " "
);
simpleEventPluginEvents.push("scrollEnd");
function registerSimpleEvent(domEventName, reactName) {
  topLevelEventsToReactNames.set(domEventName, reactName);
  registerTwoPhaseEvent(reactName, [domEventName]);
}
var CapturedStacks = /* @__PURE__ */ new WeakMap();
function createCapturedValueAtFiber(value, source) {
  if ("object" === typeof value && null !== value) {
    var existing = CapturedStacks.get(value);
    if (void 0 !== existing) return existing;
    source = {
      value,
      source,
      stack: getStackByFiberInDevAndProd(source)
    };
    CapturedStacks.set(value, source);
    return source;
  }
  return {
    value,
    source,
    stack: getStackByFiberInDevAndProd(source)
  };
}
var concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
function finishQueueingConcurrentUpdates() {
  for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
    var fiber = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var queue = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var update = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var lane = concurrentQueues[i];
    concurrentQueues[i++] = null;
    if (null !== queue && null !== update) {
      var pending = queue.pending;
      null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
      queue.pending = update;
    }
    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
  }
}
function enqueueUpdate$1(fiber, queue, update, lane) {
  concurrentQueues[concurrentQueuesIndex++] = fiber;
  concurrentQueues[concurrentQueuesIndex++] = queue;
  concurrentQueues[concurrentQueuesIndex++] = update;
  concurrentQueues[concurrentQueuesIndex++] = lane;
  concurrentlyUpdatedLanes |= lane;
  fiber.lanes |= lane;
  fiber = fiber.alternate;
  null !== fiber && (fiber.lanes |= lane);
}
function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
  enqueueUpdate$1(fiber, queue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
function enqueueConcurrentRenderForLane(fiber, lane) {
  enqueueUpdate$1(fiber, null, null, lane);
  return getRootForUpdatedFiber(fiber);
}
function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
  sourceFiber.lanes |= lane;
  var alternate = sourceFiber.alternate;
  null !== alternate && (alternate.lanes |= lane);
  for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
    parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
  return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
}
function getRootForUpdatedFiber(sourceFiber) {
  if (50 < nestedUpdateCount)
    throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
  for (var parent = sourceFiber.return; null !== parent; )
    sourceFiber = parent, parent = sourceFiber.return;
  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
}
var emptyContextObject = {};
function FiberNode(tag, pendingProps, key, mode) {
  this.tag = tag;
  this.key = key;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.refCleanup = this.ref = null;
  this.pendingProps = pendingProps;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = mode;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function createFiberImplClass(tag, pendingProps, key, mode) {
  return new FiberNode(tag, pendingProps, key, mode);
}
function shouldConstruct(Component2) {
  Component2 = Component2.prototype;
  return !(!Component2 || !Component2.isReactComponent);
}
function createWorkInProgress(current, pendingProps) {
  var workInProgress2 = current.alternate;
  null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
    current.tag,
    pendingProps,
    current.key,
    current.mode
  ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
  workInProgress2.flags = current.flags & 65011712;
  workInProgress2.childLanes = current.childLanes;
  workInProgress2.lanes = current.lanes;
  workInProgress2.child = current.child;
  workInProgress2.memoizedProps = current.memoizedProps;
  workInProgress2.memoizedState = current.memoizedState;
  workInProgress2.updateQueue = current.updateQueue;
  pendingProps = current.dependencies;
  workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
  workInProgress2.sibling = current.sibling;
  workInProgress2.index = current.index;
  workInProgress2.ref = current.ref;
  workInProgress2.refCleanup = current.refCleanup;
  return workInProgress2;
}
function resetWorkInProgress(workInProgress2, renderLanes2) {
  workInProgress2.flags &= 65011714;
  var current = workInProgress2.alternate;
  null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
    lanes: renderLanes2.lanes,
    firstContext: renderLanes2.firstContext
  });
  return workInProgress2;
}
function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
  var fiberTag = 0;
  owner = type;
  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
  else if ("string" === typeof type)
    fiberTag = isHostHoistableType(
      type,
      pendingProps,
      contextStackCursor.current
    ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
  else
    a: switch (type) {
      case REACT_ACTIVITY_TYPE:
        return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
      case REACT_STRICT_MODE_TYPE:
        fiberTag = 8;
        mode |= 24;
        break;
      case REACT_PROFILER_TYPE:
        return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
      case REACT_SUSPENSE_TYPE:
        return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
      case REACT_SUSPENSE_LIST_TYPE:
        return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
      default:
        if ("object" === typeof type && null !== type)
          switch (type.$$typeof) {
            case REACT_PROVIDER_TYPE:
            case REACT_CONTEXT_TYPE:
              fiberTag = 10;
              break a;
            case REACT_CONSUMER_TYPE:
              fiberTag = 9;
              break a;
            case REACT_FORWARD_REF_TYPE:
              fiberTag = 11;
              break a;
            case REACT_MEMO_TYPE:
              fiberTag = 14;
              break a;
            case REACT_LAZY_TYPE:
              fiberTag = 16;
              owner = null;
              break a;
          }
        fiberTag = 29;
        pendingProps = Error(
          formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
        );
        owner = null;
    }
  key = createFiberImplClass(fiberTag, pendingProps, key, mode);
  key.elementType = type;
  key.type = owner;
  key.lanes = lanes;
  return key;
}
function createFiberFromFragment(elements, mode, lanes, key) {
  elements = createFiberImplClass(7, elements, key, mode);
  elements.lanes = lanes;
  return elements;
}
function createFiberFromText(content, mode, lanes) {
  content = createFiberImplClass(6, content, null, mode);
  content.lanes = lanes;
  return content;
}
function createFiberFromPortal(portal, mode, lanes) {
  mode = createFiberImplClass(
    4,
    null !== portal.children ? portal.children : [],
    portal.key,
    mode
  );
  mode.lanes = lanes;
  mode.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null,
    implementation: portal.implementation
  };
  return mode;
}
var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
function pushTreeFork(workInProgress2, totalChildren) {
  forkStack[forkStackIndex++] = treeForkCount;
  forkStack[forkStackIndex++] = treeForkProvider;
  treeForkProvider = workInProgress2;
  treeForkCount = totalChildren;
}
function pushTreeId(workInProgress2, totalChildren, index2) {
  idStack[idStackIndex++] = treeContextId;
  idStack[idStackIndex++] = treeContextOverflow;
  idStack[idStackIndex++] = treeContextProvider;
  treeContextProvider = workInProgress2;
  var baseIdWithLeadingBit = treeContextId;
  workInProgress2 = treeContextOverflow;
  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
  baseIdWithLeadingBit &= ~(1 << baseLength);
  index2 += 1;
  var length = 32 - clz32(totalChildren) + baseLength;
  if (30 < length) {
    var numberOfOverflowBits = baseLength - baseLength % 5;
    length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
    baseIdWithLeadingBit >>= numberOfOverflowBits;
    baseLength -= numberOfOverflowBits;
    treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
    treeContextOverflow = length + workInProgress2;
  } else
    treeContextId = 1 << length | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
}
function pushMaterializedTreeId(workInProgress2) {
  null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
}
function popTreeContext(workInProgress2) {
  for (; workInProgress2 === treeForkProvider; )
    treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
  for (; workInProgress2 === treeContextProvider; )
    treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
}
var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
function throwOnHydrationMismatch(fiber) {
  var error = Error(formatProdErrorMessage(418, ""));
  queueHydrationError(createCapturedValueAtFiber(error, fiber));
  throw HydrationMismatchException;
}
function prepareToHydrateHostInstance(fiber) {
  var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
  instance[internalInstanceKey] = fiber;
  instance[internalPropsKey] = props;
  switch (type) {
    case "dialog":
      listenToNonDelegatedEvent("cancel", instance);
      listenToNonDelegatedEvent("close", instance);
      break;
    case "iframe":
    case "object":
    case "embed":
      listenToNonDelegatedEvent("load", instance);
      break;
    case "video":
    case "audio":
      for (type = 0; type < mediaEventTypes.length; type++)
        listenToNonDelegatedEvent(mediaEventTypes[type], instance);
      break;
    case "source":
      listenToNonDelegatedEvent("error", instance);
      break;
    case "img":
    case "image":
    case "link":
      listenToNonDelegatedEvent("error", instance);
      listenToNonDelegatedEvent("load", instance);
      break;
    case "details":
      listenToNonDelegatedEvent("toggle", instance);
      break;
    case "input":
      listenToNonDelegatedEvent("invalid", instance);
      initInput(
        instance,
        props.value,
        props.defaultValue,
        props.checked,
        props.defaultChecked,
        props.type,
        props.name,
        true
      );
      track(instance);
      break;
    case "select":
      listenToNonDelegatedEvent("invalid", instance);
      break;
    case "textarea":
      listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children), track(instance);
  }
  type = props.children;
  "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
  instance || throwOnHydrationMismatch(fiber);
}
function popToNextHostParent(fiber) {
  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
    switch (hydrationParentFiber.tag) {
      case 5:
      case 13:
        rootOrSingletonContext = false;
        return;
      case 27:
      case 3:
        rootOrSingletonContext = true;
        return;
      default:
        hydrationParentFiber = hydrationParentFiber.return;
    }
}
function popHydrationState(fiber) {
  if (fiber !== hydrationParentFiber) return false;
  if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
  var tag = fiber.tag, JSCompiler_temp;
  if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
    if (JSCompiler_temp = 5 === tag)
      JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
    JSCompiler_temp = !JSCompiler_temp;
  }
  JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
  popToNextHostParent(fiber);
  if (13 === tag) {
    fiber = fiber.memoizedState;
    fiber = null !== fiber ? fiber.dehydrated : null;
    if (!fiber) throw Error(formatProdErrorMessage(317));
    a: {
      fiber = fiber.nextSibling;
      for (tag = 0; fiber; ) {
        if (8 === fiber.nodeType)
          if (JSCompiler_temp = fiber.data, "/$" === JSCompiler_temp) {
            if (0 === tag) {
              nextHydratableInstance = getNextHydratable(fiber.nextSibling);
              break a;
            }
            tag--;
          } else
            "$" !== JSCompiler_temp && "$!" !== JSCompiler_temp && "$?" !== JSCompiler_temp || tag++;
        fiber = fiber.nextSibling;
      }
      nextHydratableInstance = null;
    }
  } else
    27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
  return true;
}
function resetHydrationState() {
  nextHydratableInstance = hydrationParentFiber = null;
  isHydrating = false;
}
function upgradeHydrationErrorsToRecoverable() {
  var queuedErrors = hydrationErrors;
  null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
    workInProgressRootRecoverableErrors,
    queuedErrors
  ), hydrationErrors = null);
  return queuedErrors;
}
function queueHydrationError(error) {
  null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
}
var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null;
function pushProvider(providerFiber, context, nextValue) {
  push(valueCursor, context._currentValue);
  context._currentValue = nextValue;
}
function popProvider(context) {
  context._currentValue = valueCursor.current;
  pop(valueCursor);
}
function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
  for (; null !== parent; ) {
    var alternate = parent.alternate;
    (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
    if (parent === propagationRoot) break;
    parent = parent.return;
  }
}
function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
  var fiber = workInProgress2.child;
  null !== fiber && (fiber.return = workInProgress2);
  for (; null !== fiber; ) {
    var list2 = fiber.dependencies;
    if (null !== list2) {
      var nextFiber = fiber.child;
      list2 = list2.firstContext;
      a: for (; null !== list2; ) {
        var dependency = list2;
        list2 = fiber;
        for (var i = 0; i < contexts.length; i++)
          if (dependency.context === contexts[i]) {
            list2.lanes |= renderLanes2;
            dependency = list2.alternate;
            null !== dependency && (dependency.lanes |= renderLanes2);
            scheduleContextWorkOnParentPath(
              list2.return,
              renderLanes2,
              workInProgress2
            );
            forcePropagateEntireTree || (nextFiber = null);
            break a;
          }
        list2 = dependency.next;
      }
    } else if (18 === fiber.tag) {
      nextFiber = fiber.return;
      if (null === nextFiber) throw Error(formatProdErrorMessage(341));
      nextFiber.lanes |= renderLanes2;
      list2 = nextFiber.alternate;
      null !== list2 && (list2.lanes |= renderLanes2);
      scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
      nextFiber = null;
    } else nextFiber = fiber.child;
    if (null !== nextFiber) nextFiber.return = fiber;
    else
      for (nextFiber = fiber; null !== nextFiber; ) {
        if (nextFiber === workInProgress2) {
          nextFiber = null;
          break;
        }
        fiber = nextFiber.sibling;
        if (null !== fiber) {
          fiber.return = nextFiber.return;
          nextFiber = fiber;
          break;
        }
        nextFiber = nextFiber.return;
      }
    fiber = nextFiber;
  }
}
function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
  current = null;
  for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
    if (!isInsidePropagationBailout) {
      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
      else if (0 !== (parent.flags & 262144)) break;
    }
    if (10 === parent.tag) {
      var currentParent = parent.alternate;
      if (null === currentParent) throw Error(formatProdErrorMessage(387));
      currentParent = currentParent.memoizedProps;
      if (null !== currentParent) {
        var context = parent.type;
        objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
      }
    } else if (parent === hostTransitionProviderCursor.current) {
      currentParent = parent.alternate;
      if (null === currentParent) throw Error(formatProdErrorMessage(387));
      currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
    }
    parent = parent.return;
  }
  null !== current && propagateContextChanges(
    workInProgress2,
    current,
    renderLanes2,
    forcePropagateEntireTree
  );
  workInProgress2.flags |= 262144;
}
function checkIfContextChanged(currentDependencies) {
  for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
    if (!objectIs(
      currentDependencies.context._currentValue,
      currentDependencies.memoizedValue
    ))
      return true;
    currentDependencies = currentDependencies.next;
  }
  return false;
}
function prepareToReadContext(workInProgress2) {
  currentlyRenderingFiber$1 = workInProgress2;
  lastContextDependency = null;
  workInProgress2 = workInProgress2.dependencies;
  null !== workInProgress2 && (workInProgress2.firstContext = null);
}
function readContext(context) {
  return readContextForConsumer(currentlyRenderingFiber$1, context);
}
function readContextDuringReconciliation(consumer, context) {
  null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
  return readContextForConsumer(consumer, context);
}
function readContextForConsumer(consumer, context) {
  var value = context._currentValue;
  context = { context, memoizedValue: value, next: null };
  if (null === lastContextDependency) {
    if (null === consumer) throw Error(formatProdErrorMessage(308));
    lastContextDependency = context;
    consumer.dependencies = { lanes: 0, firstContext: context };
    consumer.flags |= 524288;
  } else lastContextDependency = lastContextDependency.next = context;
  return value;
}
var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
  var listeners = [], signal = this.signal = {
    aborted: false,
    addEventListener: function(type, listener) {
      listeners.push(listener);
    }
  };
  this.abort = function() {
    signal.aborted = true;
    listeners.forEach(function(listener) {
      return listener();
    });
  };
}, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
  $$typeof: REACT_CONTEXT_TYPE,
  Consumer: null,
  Provider: null,
  _currentValue: null,
  _currentValue2: null,
  _threadCount: 0
};
function createCache() {
  return {
    controller: new AbortControllerLocal(),
    data: /* @__PURE__ */ new Map(),
    refCount: 0
  };
}
function releaseCache(cache) {
  cache.refCount--;
  0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
    cache.controller.abort();
  });
}
var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
function entangleAsyncAction(transition, thenable) {
  if (null === currentEntangledListeners) {
    var entangledListeners = currentEntangledListeners = [];
    currentEntangledPendingCount = 0;
    currentEntangledLane = requestTransitionLane();
    currentEntangledActionThenable = {
      status: "pending",
      value: void 0,
      then: function(resolve) {
        entangledListeners.push(resolve);
      }
    };
  }
  currentEntangledPendingCount++;
  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
  return thenable;
}
function pingEngtangledActionScope() {
  if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
    null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
    var listeners = currentEntangledListeners;
    currentEntangledListeners = null;
    currentEntangledLane = 0;
    currentEntangledActionThenable = null;
    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
  }
}
function chainThenableValue(thenable, result) {
  var listeners = [], thenableWithOverride = {
    status: "pending",
    value: null,
    reason: null,
    then: function(resolve) {
      listeners.push(resolve);
    }
  };
  thenable.then(
    function() {
      thenableWithOverride.status = "fulfilled";
      thenableWithOverride.value = result;
      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
    },
    function(error) {
      thenableWithOverride.status = "rejected";
      thenableWithOverride.reason = error;
      for (error = 0; error < listeners.length; error++)
        (0, listeners[error])(void 0);
    }
  );
  return thenableWithOverride;
}
var prevOnStartTransitionFinish = ReactSharedInternals.S;
ReactSharedInternals.S = function(transition, returnValue) {
  "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
  null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
};
var resumedCache = createCursor(null);
function peekCacheFromPool() {
  var cacheResumedFromPreviousRender = resumedCache.current;
  return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
}
function pushTransition(offscreenWorkInProgress, prevCachePool) {
  null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
}
function getSuspendedCache() {
  var cacheFromPool = peekCacheFromPool();
  return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
}
var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {
} };
function isThenableResolved(thenable) {
  thenable = thenable.status;
  return "fulfilled" === thenable || "rejected" === thenable;
}
function noop$3() {
}
function trackUsedThenable(thenableState2, thenable, index2) {
  index2 = thenableState2[index2];
  void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$3, noop$3), thenable = index2);
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
    default:
      if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
      else {
        thenableState2 = workInProgressRoot;
        if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
          throw Error(formatProdErrorMessage(482));
        thenableState2 = thenable;
        thenableState2.status = "pending";
        thenableState2.then(
          function(fulfilledValue) {
            if ("pending" === thenable.status) {
              var fulfilledThenable = thenable;
              fulfilledThenable.status = "fulfilled";
              fulfilledThenable.value = fulfilledValue;
            }
          },
          function(error) {
            if ("pending" === thenable.status) {
              var rejectedThenable = thenable;
              rejectedThenable.status = "rejected";
              rejectedThenable.reason = error;
            }
          }
        );
      }
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
      }
      suspendedThenable = thenable;
      throw SuspenseException;
  }
}
var suspendedThenable = null;
function getSuspendedThenable() {
  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
  var thenable = suspendedThenable;
  suspendedThenable = null;
  return thenable;
}
function checkIfUseWrappedInAsyncCatch(rejectedReason) {
  if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
    throw Error(formatProdErrorMessage(483));
}
var hasForceUpdate = false;
function initializeUpdateQueue(fiber) {
  fiber.updateQueue = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, lanes: 0, hiddenCallbacks: null },
    callbacks: null
  };
}
function cloneUpdateQueue(current, workInProgress2) {
  current = current.updateQueue;
  workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
    baseState: current.baseState,
    firstBaseUpdate: current.firstBaseUpdate,
    lastBaseUpdate: current.lastBaseUpdate,
    shared: current.shared,
    callbacks: null
  });
}
function createUpdate(lane) {
  return { lane, tag: 0, payload: null, callback: null, next: null };
}
function enqueueUpdate(fiber, update, lane) {
  var updateQueue = fiber.updateQueue;
  if (null === updateQueue) return null;
  updateQueue = updateQueue.shared;
  if (0 !== (executionContext & 2)) {
    var pending = updateQueue.pending;
    null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
    updateQueue.pending = update;
    update = getRootForUpdatedFiber(fiber);
    markUpdateLaneFromFiberToRoot(fiber, null, lane);
    return update;
  }
  enqueueUpdate$1(fiber, updateQueue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
function entangleTransitions(root2, fiber, lane) {
  fiber = fiber.updateQueue;
  if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
    var queueLanes = fiber.lanes;
    queueLanes &= root2.pendingLanes;
    lane |= queueLanes;
    fiber.lanes = lane;
    markRootEntangled(root2, lane);
  }
}
function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
  var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
  if (null !== current && (current = current.updateQueue, queue === current)) {
    var newFirst = null, newLast = null;
    queue = queue.firstBaseUpdate;
    if (null !== queue) {
      do {
        var clone = {
          lane: queue.lane,
          tag: queue.tag,
          payload: queue.payload,
          callback: null,
          next: null
        };
        null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
        queue = queue.next;
      } while (null !== queue);
      null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
    } else newFirst = newLast = capturedUpdate;
    queue = {
      baseState: current.baseState,
      firstBaseUpdate: newFirst,
      lastBaseUpdate: newLast,
      shared: current.shared,
      callbacks: current.callbacks
    };
    workInProgress2.updateQueue = queue;
    return;
  }
  workInProgress2 = queue.lastBaseUpdate;
  null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
  queue.lastBaseUpdate = capturedUpdate;
}
var didReadFromEntangledAsyncAction = false;
function suspendIfUpdateReadFromEntangledAsyncAction() {
  if (didReadFromEntangledAsyncAction) {
    var entangledActionThenable = currentEntangledActionThenable;
    if (null !== entangledActionThenable) throw entangledActionThenable;
  }
}
function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
  didReadFromEntangledAsyncAction = false;
  var queue = workInProgress$jscomp$0.updateQueue;
  hasForceUpdate = false;
  var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
  if (null !== pendingQueue) {
    queue.shared.pending = null;
    var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = null;
    null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
    lastBaseUpdate = lastPendingUpdate;
    var current = workInProgress$jscomp$0.alternate;
    null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
  }
  if (null !== firstBaseUpdate) {
    var newState = queue.baseState;
    lastBaseUpdate = 0;
    current = firstPendingUpdate = lastPendingUpdate = null;
    pendingQueue = firstBaseUpdate;
    do {
      var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
      if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
        0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
        null !== current && (current = current.next = {
          lane: 0,
          tag: pendingQueue.tag,
          payload: pendingQueue.payload,
          callback: null,
          next: null
        });
        a: {
          var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
          updateLane = props;
          var instance = instance$jscomp$0;
          switch (update.tag) {
            case 1:
              workInProgress2 = update.payload;
              if ("function" === typeof workInProgress2) {
                newState = workInProgress2.call(instance, newState, updateLane);
                break a;
              }
              newState = workInProgress2;
              break a;
            case 3:
              workInProgress2.flags = workInProgress2.flags & -65537 | 128;
            case 0:
              workInProgress2 = update.payload;
              updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
              if (null === updateLane || void 0 === updateLane) break a;
              newState = assign({}, newState, updateLane);
              break a;
            case 2:
              hasForceUpdate = true;
          }
        }
        updateLane = pendingQueue.callback;
        null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
      } else
        isHiddenUpdate = {
          lane: updateLane,
          tag: pendingQueue.tag,
          payload: pendingQueue.payload,
          callback: pendingQueue.callback,
          next: null
        }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
      pendingQueue = pendingQueue.next;
      if (null === pendingQueue)
        if (pendingQueue = queue.shared.pending, null === pendingQueue)
          break;
        else
          isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
    } while (1);
    null === current && (lastPendingUpdate = newState);
    queue.baseState = lastPendingUpdate;
    queue.firstBaseUpdate = firstPendingUpdate;
    queue.lastBaseUpdate = current;
    null === firstBaseUpdate && (queue.shared.lanes = 0);
    workInProgressRootSkippedLanes |= lastBaseUpdate;
    workInProgress$jscomp$0.lanes = lastBaseUpdate;
    workInProgress$jscomp$0.memoizedState = newState;
  }
}
function callCallback(callback, context) {
  if ("function" !== typeof callback)
    throw Error(formatProdErrorMessage(191, callback));
  callback.call(context);
}
function commitCallbacks(updateQueue, context) {
  var callbacks = updateQueue.callbacks;
  if (null !== callbacks)
    for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
      callCallback(callbacks[updateQueue], context);
}
var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
function pushHiddenContext(fiber, context) {
  fiber = entangledRenderLanes;
  push(prevEntangledRenderLanesCursor, fiber);
  push(currentTreeHiddenStackCursor, context);
  entangledRenderLanes = fiber | context.baseLanes;
}
function reuseHiddenContextOnStack() {
  push(prevEntangledRenderLanesCursor, entangledRenderLanes);
  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
}
function popHiddenContext() {
  entangledRenderLanes = prevEntangledRenderLanesCursor.current;
  pop(currentTreeHiddenStackCursor);
  pop(prevEntangledRenderLanesCursor);
}
var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter$1 = 0, thenableState$1 = null, globalClientIdCounter = 0;
function throwInvalidHookError() {
  throw Error(formatProdErrorMessage(321));
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (null === prevDeps) return false;
  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
    if (!objectIs(nextDeps[i], prevDeps[i])) return false;
  return true;
}
function renderWithHooks(current, workInProgress2, Component2, props, secondArg, nextRenderLanes) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress2;
  workInProgress2.memoizedState = null;
  workInProgress2.updateQueue = null;
  workInProgress2.lanes = 0;
  ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
  shouldDoubleInvokeUserFnsInHooksDEV = false;
  nextRenderLanes = Component2(props, secondArg);
  shouldDoubleInvokeUserFnsInHooksDEV = false;
  didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
    workInProgress2,
    Component2,
    props,
    secondArg
  ));
  finishRenderingHooks(current);
  return nextRenderLanes;
}
function finishRenderingHooks(current) {
  ReactSharedInternals.H = ContextOnlyDispatcher;
  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
  renderLanes = 0;
  workInProgressHook = currentHook = currentlyRenderingFiber = null;
  didScheduleRenderPhaseUpdate = false;
  thenableIndexCounter$1 = 0;
  thenableState$1 = null;
  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
  null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
}
function renderWithHooksAgain(workInProgress2, Component2, props, secondArg) {
  currentlyRenderingFiber = workInProgress2;
  var numberOfReRenders = 0;
  do {
    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
    thenableIndexCounter$1 = 0;
    didScheduleRenderPhaseUpdateDuringThisPass = false;
    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
    numberOfReRenders += 1;
    workInProgressHook = currentHook = null;
    if (null != workInProgress2.updateQueue) {
      var children = workInProgress2.updateQueue;
      children.lastEffect = null;
      children.events = null;
      children.stores = null;
      null != children.memoCache && (children.memoCache.index = 0);
    }
    ReactSharedInternals.H = HooksDispatcherOnRerender;
    children = Component2(props, secondArg);
  } while (didScheduleRenderPhaseUpdateDuringThisPass);
  return children;
}
function TransitionAwareHostComponent() {
  var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
  maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
  dispatcher = dispatcher.useState()[0];
  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
  return maybeThenable;
}
function checkDidRenderIdHook() {
  var didRenderIdHook = 0 !== localIdCounter;
  localIdCounter = 0;
  return didRenderIdHook;
}
function bailoutHooks(current, workInProgress2, lanes) {
  workInProgress2.updateQueue = current.updateQueue;
  workInProgress2.flags &= -2053;
  current.lanes &= ~lanes;
}
function resetHooksOnUnwind(workInProgress2) {
  if (didScheduleRenderPhaseUpdate) {
    for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
      var queue = workInProgress2.queue;
      null !== queue && (queue.pending = null);
      workInProgress2 = workInProgress2.next;
    }
    didScheduleRenderPhaseUpdate = false;
  }
  renderLanes = 0;
  workInProgressHook = currentHook = currentlyRenderingFiber = null;
  didScheduleRenderPhaseUpdateDuringThisPass = false;
  thenableIndexCounter$1 = localIdCounter = 0;
  thenableState$1 = null;
}
function mountWorkInProgressHook() {
  var hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
  return workInProgressHook;
}
function updateWorkInProgressHook() {
  if (null === currentHook) {
    var nextCurrentHook = currentlyRenderingFiber.alternate;
    nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
  } else nextCurrentHook = currentHook.next;
  var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
  if (null !== nextWorkInProgressHook)
    workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
  else {
    if (null === nextCurrentHook) {
      if (null === currentlyRenderingFiber.alternate)
        throw Error(formatProdErrorMessage(467));
      throw Error(formatProdErrorMessage(310));
    }
    currentHook = nextCurrentHook;
    nextCurrentHook = {
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null
    };
    null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
  }
  return workInProgressHook;
}
function createFunctionComponentUpdateQueue() {
  return { lastEffect: null, events: null, stores: null, memoCache: null };
}
function useThenable(thenable) {
  var index2 = thenableIndexCounter$1;
  thenableIndexCounter$1 += 1;
  null === thenableState$1 && (thenableState$1 = []);
  thenable = trackUsedThenable(thenableState$1, thenable, index2);
  index2 = currentlyRenderingFiber;
  null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
  return thenable;
}
function use(usable) {
  if (null !== usable && "object" === typeof usable) {
    if ("function" === typeof usable.then) return useThenable(usable);
    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
  }
  throw Error(formatProdErrorMessage(438, String(usable)));
}
function useMemoCache(size) {
  var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
  null !== updateQueue && (memoCache = updateQueue.memoCache);
  if (null == memoCache) {
    var current = currentlyRenderingFiber.alternate;
    null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
      data: current.data.map(function(array) {
        return array.slice();
      }),
      index: 0
    })));
  }
  null == memoCache && (memoCache = { data: [], index: 0 });
  null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
  updateQueue.memoCache = memoCache;
  updateQueue = memoCache.data[memoCache.index];
  if (void 0 === updateQueue)
    for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
  memoCache.index++;
  return updateQueue;
}
function basicStateReducer(state, action) {
  return "function" === typeof action ? action(state) : action;
}
function updateReducer(reducer) {
  var hook = updateWorkInProgressHook();
  return updateReducerImpl(hook, currentHook, reducer);
}
function updateReducerImpl(hook, current, reducer) {
  var queue = hook.queue;
  if (null === queue) throw Error(formatProdErrorMessage(311));
  queue.lastRenderedReducer = reducer;
  var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
  if (null !== pendingQueue) {
    if (null !== baseQueue) {
      var baseFirst = baseQueue.next;
      baseQueue.next = pendingQueue.next;
      pendingQueue.next = baseFirst;
    }
    current.baseQueue = baseQueue = pendingQueue;
    queue.pending = null;
  }
  pendingQueue = hook.baseState;
  if (null === baseQueue) hook.memoizedState = pendingQueue;
  else {
    current = baseQueue.next;
    var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$32 = false;
    do {
      var updateLane = update.lane & -536870913;
      if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
        var revertLane = update.revertLane;
        if (0 === revertLane)
          null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
            lane: 0,
            revertLane: 0,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
        else if ((renderLanes & revertLane) === revertLane) {
          update = update.next;
          revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
          continue;
        } else
          updateLane = {
            lane: 0,
            revertLane: update.revertLane,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
        updateLane = update.action;
        shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
        pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
      } else
        revertLane = {
          lane: updateLane,
          revertLane: update.revertLane,
          action: update.action,
          hasEagerState: update.hasEagerState,
          eagerState: update.eagerState,
          next: null
        }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
      update = update.next;
    } while (null !== update && update !== current);
    null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
    if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$32 && (reducer = currentEntangledActionThenable, null !== reducer)))
      throw reducer;
    hook.memoizedState = pendingQueue;
    hook.baseState = baseFirst;
    hook.baseQueue = newBaseQueueLast;
    queue.lastRenderedState = pendingQueue;
  }
  null === baseQueue && (queue.lanes = 0);
  return [hook.memoizedState, queue.dispatch];
}
function rerenderReducer(reducer) {
  var hook = updateWorkInProgressHook(), queue = hook.queue;
  if (null === queue) throw Error(formatProdErrorMessage(311));
  queue.lastRenderedReducer = reducer;
  var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
  if (null !== lastRenderPhaseUpdate) {
    queue.pending = null;
    var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
    do
      newState = reducer(newState, update.action), update = update.next;
    while (update !== lastRenderPhaseUpdate);
    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
    hook.memoizedState = newState;
    null === hook.baseQueue && (hook.baseState = newState);
    queue.lastRenderedState = newState;
  }
  return [newState, dispatch];
}
function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
  var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
  if (isHydrating$jscomp$0) {
    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
    getServerSnapshot = getServerSnapshot();
  } else getServerSnapshot = getSnapshot();
  var snapshotChanged = !objectIs(
    (currentHook || hook).memoizedState,
    getServerSnapshot
  );
  snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
  hook = hook.queue;
  var create = subscribeToStore.bind(null, fiber, hook, subscribe);
  updateEffectImpl(2048, 8, create, [subscribe]);
  if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
    fiber.flags |= 2048;
    pushSimpleEffect(
      9,
      createEffectInstance(),
      updateStoreInstance.bind(
        null,
        fiber,
        hook,
        getServerSnapshot,
        getSnapshot
      ),
      null
    );
    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
    isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
  }
  return getServerSnapshot;
}
function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
  fiber.flags |= 16384;
  fiber = { getSnapshot, value: renderedSnapshot };
  getSnapshot = currentlyRenderingFiber.updateQueue;
  null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
}
function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
  inst.value = nextSnapshot;
  inst.getSnapshot = getSnapshot;
  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
}
function subscribeToStore(fiber, inst, subscribe) {
  return subscribe(function() {
    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
  });
}
function checkIfSnapshotChanged(inst) {
  var latestGetSnapshot = inst.getSnapshot;
  inst = inst.value;
  try {
    var nextValue = latestGetSnapshot();
    return !objectIs(inst, nextValue);
  } catch (error) {
    return true;
  }
}
function forceStoreRerender(fiber) {
  var root2 = enqueueConcurrentRenderForLane(fiber, 2);
  null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
}
function mountStateImpl(initialState) {
  var hook = mountWorkInProgressHook();
  if ("function" === typeof initialState) {
    var initialStateInitializer = initialState;
    initialState = initialStateInitializer();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(true);
      try {
        initialStateInitializer();
      } finally {
        setIsStrictModeForDevtools(false);
      }
    }
  }
  hook.memoizedState = hook.baseState = initialState;
  hook.queue = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState
  };
  return hook;
}
function updateOptimisticImpl(hook, current, passthrough, reducer) {
  hook.baseState = passthrough;
  return updateReducerImpl(
    hook,
    currentHook,
    "function" === typeof reducer ? reducer : basicStateReducer
  );
}
function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
  fiber = actionQueue.action;
  if (null !== fiber) {
    var actionNode = {
      payload,
      action: fiber,
      next: null,
      isTransition: true,
      status: "pending",
      value: null,
      reason: null,
      listeners: [],
      then: function(listener) {
        actionNode.listeners.push(listener);
      }
    };
    null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
    setState(actionNode);
    setPendingState = actionQueue.pending;
    null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
  }
}
function runActionStateAction(actionQueue, node) {
  var action = node.action, payload = node.payload, prevState = actionQueue.state;
  if (node.isTransition) {
    var prevTransition = ReactSharedInternals.T, currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    try {
      var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
      handleActionReturnValue(actionQueue, node, returnValue);
    } catch (error) {
      onActionError(actionQueue, node, error);
    } finally {
      ReactSharedInternals.T = prevTransition;
    }
  } else
    try {
      prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
    } catch (error$38) {
      onActionError(actionQueue, node, error$38);
    }
}
function handleActionReturnValue(actionQueue, node, returnValue) {
  null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
    function(nextState) {
      onActionSuccess(actionQueue, node, nextState);
    },
    function(error) {
      return onActionError(actionQueue, node, error);
    }
  ) : onActionSuccess(actionQueue, node, returnValue);
}
function onActionSuccess(actionQueue, actionNode, nextState) {
  actionNode.status = "fulfilled";
  actionNode.value = nextState;
  notifyActionListeners(actionNode);
  actionQueue.state = nextState;
  actionNode = actionQueue.pending;
  null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
}
function onActionError(actionQueue, actionNode, error) {
  var last = actionQueue.pending;
  actionQueue.pending = null;
  if (null !== last) {
    last = last.next;
    do
      actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
    while (actionNode !== last);
  }
  actionQueue.action = null;
}
function notifyActionListeners(actionNode) {
  actionNode = actionNode.listeners;
  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
}
function actionStateReducer(oldState, newState) {
  return newState;
}
function mountActionState(action, initialStateProp) {
  if (isHydrating) {
    var ssrFormState = workInProgressRoot.formState;
    if (null !== ssrFormState) {
      a: {
        var JSCompiler_inline_result = currentlyRenderingFiber;
        if (isHydrating) {
          if (nextHydratableInstance) {
            b: {
              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
              for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                if (!inRootOrSingleton) {
                  JSCompiler_inline_result$jscomp$0 = null;
                  break b;
                }
                JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                  JSCompiler_inline_result$jscomp$0.nextSibling
                );
                if (null === JSCompiler_inline_result$jscomp$0) {
                  JSCompiler_inline_result$jscomp$0 = null;
                  break b;
                }
              }
              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
              JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
            }
            if (JSCompiler_inline_result$jscomp$0) {
              nextHydratableInstance = getNextHydratable(
                JSCompiler_inline_result$jscomp$0.nextSibling
              );
              JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
              break a;
            }
          }
          throwOnHydrationMismatch(JSCompiler_inline_result);
        }
        JSCompiler_inline_result = false;
      }
      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
    }
  }
  ssrFormState = mountWorkInProgressHook();
  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
  JSCompiler_inline_result = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: actionStateReducer,
    lastRenderedState: initialStateProp
  };
  ssrFormState.queue = JSCompiler_inline_result;
  ssrFormState = dispatchSetState.bind(
    null,
    currentlyRenderingFiber,
    JSCompiler_inline_result
  );
  JSCompiler_inline_result.dispatch = ssrFormState;
  JSCompiler_inline_result = mountStateImpl(false);
  inRootOrSingleton = dispatchOptimisticSetState.bind(
    null,
    currentlyRenderingFiber,
    false,
    JSCompiler_inline_result.queue
  );
  JSCompiler_inline_result = mountWorkInProgressHook();
  JSCompiler_inline_result$jscomp$0 = {
    state: initialStateProp,
    dispatch: null,
    action,
    pending: null
  };
  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
  ssrFormState = dispatchActionState.bind(
    null,
    currentlyRenderingFiber,
    JSCompiler_inline_result$jscomp$0,
    inRootOrSingleton,
    ssrFormState
  );
  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
  JSCompiler_inline_result.memoizedState = action;
  return [initialStateProp, ssrFormState, false];
}
function updateActionState(action) {
  var stateHook = updateWorkInProgressHook();
  return updateActionStateImpl(stateHook, currentHook, action);
}
function updateActionStateImpl(stateHook, currentStateHook, action) {
  currentStateHook = updateReducerImpl(
    stateHook,
    currentStateHook,
    actionStateReducer
  )[0];
  stateHook = updateReducer(basicStateReducer)[0];
  if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
    try {
      var state = useThenable(currentStateHook);
    } catch (x) {
      if (x === SuspenseException) throw SuspenseActionException;
      throw x;
    }
  else state = currentStateHook;
  currentStateHook = updateWorkInProgressHook();
  var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
  action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
    9,
    createEffectInstance(),
    actionStateActionEffect.bind(null, actionQueue, action),
    null
  ));
  return [state, dispatch, stateHook];
}
function actionStateActionEffect(actionQueue, action) {
  actionQueue.action = action;
}
function rerenderActionState(action) {
  var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
  if (null !== currentStateHook)
    return updateActionStateImpl(stateHook, currentStateHook, action);
  updateWorkInProgressHook();
  stateHook = stateHook.memoizedState;
  currentStateHook = updateWorkInProgressHook();
  var dispatch = currentStateHook.queue.dispatch;
  currentStateHook.memoizedState = action;
  return [stateHook, dispatch, false];
}
function pushSimpleEffect(tag, inst, create, createDeps) {
  tag = { tag, create, deps: createDeps, inst, next: null };
  inst = currentlyRenderingFiber.updateQueue;
  null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
  create = inst.lastEffect;
  null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
  return tag;
}
function createEffectInstance() {
  return { destroy: void 0, resource: void 0 };
}
function updateRef() {
  return updateWorkInProgressHook().memoizedState;
}
function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
  var hook = mountWorkInProgressHook();
  createDeps = void 0 === createDeps ? null : createDeps;
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushSimpleEffect(
    1 | hookFlags,
    createEffectInstance(),
    create,
    createDeps
  );
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var inst = hook.memoizedState.inst;
  null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
    1 | hookFlags,
    inst,
    create,
    deps
  ));
}
function mountEffect(create, createDeps) {
  mountEffectImpl(8390656, 8, create, createDeps);
}
function updateEffect(create, createDeps) {
  updateEffectImpl(2048, 8, create, createDeps);
}
function updateInsertionEffect(create, deps) {
  return updateEffectImpl(4, 2, create, deps);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(4, 4, create, deps);
}
function imperativeHandleEffect(create, ref) {
  if ("function" === typeof ref) {
    create = create();
    var refCleanup = ref(create);
    return function() {
      "function" === typeof refCleanup ? refCleanup() : ref(null);
    };
  }
  if (null !== ref && void 0 !== ref)
    return create = create(), ref.current = create, function() {
      ref.current = null;
    };
}
function updateImperativeHandle(ref, create, deps) {
  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
}
function mountDebugValue() {
}
function updateCallback(callback, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var prevState = hook.memoizedState;
  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
    return prevState[0];
  hook.memoizedState = [callback, deps];
  return callback;
}
function updateMemo(nextCreate, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var prevState = hook.memoizedState;
  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
    return prevState[0];
  prevState = nextCreate();
  if (shouldDoubleInvokeUserFnsInHooksDEV) {
    setIsStrictModeForDevtools(true);
    try {
      nextCreate();
    } finally {
      setIsStrictModeForDevtools(false);
    }
  }
  hook.memoizedState = [prevState, deps];
  return prevState;
}
function mountDeferredValueImpl(hook, value, initialValue) {
  if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
    return hook.memoizedState = value;
  hook.memoizedState = initialValue;
  hook = requestDeferredLane();
  currentlyRenderingFiber.lanes |= hook;
  workInProgressRootSkippedLanes |= hook;
  return initialValue;
}
function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
  if (objectIs(value, prevValue)) return value;
  if (null !== currentTreeHiddenStackCursor.current)
    return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
  if (0 === (renderLanes & 42))
    return didReceiveUpdate = true, hook.memoizedState = value;
  hook = requestDeferredLane();
  currentlyRenderingFiber.lanes |= hook;
  workInProgressRootSkippedLanes |= hook;
  return prevValue;
}
function startTransition(fiber, queue, pendingState, finishedState, callback) {
  var previousPriority = ReactDOMSharedInternals.p;
  ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
  var prevTransition = ReactSharedInternals.T, currentTransition = {};
  ReactSharedInternals.T = currentTransition;
  dispatchOptimisticSetState(fiber, false, queue, pendingState);
  try {
    var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
    null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
    if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
      var thenableForFinishedState = chainThenableValue(
        returnValue,
        finishedState
      );
      dispatchSetStateInternal(
        fiber,
        queue,
        thenableForFinishedState,
        requestUpdateLane(fiber)
      );
    } else
      dispatchSetStateInternal(
        fiber,
        queue,
        finishedState,
        requestUpdateLane(fiber)
      );
  } catch (error) {
    dispatchSetStateInternal(
      fiber,
      queue,
      { then: function() {
      }, status: "rejected", reason: error },
      requestUpdateLane()
    );
  } finally {
    ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
  }
}
function noop$2() {
}
function startHostTransition(formFiber, pendingState, action, formData) {
  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
  var queue = ensureFormComponentIsStateful(formFiber).queue;
  startTransition(
    formFiber,
    queue,
    pendingState,
    sharedNotPendingObject,
    null === action ? noop$2 : function() {
      requestFormReset$1(formFiber);
      return action(formData);
    }
  );
}
function ensureFormComponentIsStateful(formFiber) {
  var existingStateHook = formFiber.memoizedState;
  if (null !== existingStateHook) return existingStateHook;
  existingStateHook = {
    memoizedState: sharedNotPendingObject,
    baseState: sharedNotPendingObject,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: sharedNotPendingObject
    },
    next: null
  };
  var initialResetState = {};
  existingStateHook.next = {
    memoizedState: initialResetState,
    baseState: initialResetState,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: initialResetState
    },
    next: null
  };
  formFiber.memoizedState = existingStateHook;
  formFiber = formFiber.alternate;
  null !== formFiber && (formFiber.memoizedState = existingStateHook);
  return existingStateHook;
}
function requestFormReset$1(formFiber) {
  var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
  dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
}
function useHostTransitionStatus() {
  return readContext(HostTransitionContext);
}
function updateId() {
  return updateWorkInProgressHook().memoizedState;
}
function updateRefresh() {
  return updateWorkInProgressHook().memoizedState;
}
function refreshCache(fiber) {
  for (var provider = fiber.return; null !== provider; ) {
    switch (provider.tag) {
      case 24:
      case 3:
        var lane = requestUpdateLane();
        fiber = createUpdate(lane);
        var root$41 = enqueueUpdate(provider, fiber, lane);
        null !== root$41 && (scheduleUpdateOnFiber(root$41, provider, lane), entangleTransitions(root$41, provider, lane));
        provider = { cache: createCache() };
        fiber.payload = provider;
        return;
    }
    provider = provider.return;
  }
}
function dispatchReducerAction(fiber, queue, action) {
  var lane = requestUpdateLane();
  action = {
    lane,
    revertLane: 0,
    action,
    hasEagerState: false,
    eagerState: null,
    next: null
  };
  isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
}
function dispatchSetState(fiber, queue, action) {
  var lane = requestUpdateLane();
  dispatchSetStateInternal(fiber, queue, action, lane);
}
function dispatchSetStateInternal(fiber, queue, action, lane) {
  var update = {
    lane,
    revertLane: 0,
    action,
    hasEagerState: false,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
  else {
    var alternate = fiber.alternate;
    if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
      try {
        var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
        update.hasEagerState = true;
        update.eagerState = eagerState;
        if (objectIs(eagerState, currentState))
          return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
      } catch (error) {
      } finally {
      }
    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
    if (null !== action)
      return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
  }
  return false;
}
function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
  action = {
    lane: 2,
    revertLane: requestTransitionLane(),
    action,
    hasEagerState: false,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) {
    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
  } else
    throwIfDuringRender = enqueueConcurrentHookUpdate(
      fiber,
      queue,
      action,
      2
    ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
}
function isRenderPhaseUpdate(fiber) {
  var alternate = fiber.alternate;
  return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
}
function enqueueRenderPhaseUpdate(queue, update) {
  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
  var pending = queue.pending;
  null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
  queue.pending = update;
}
function entangleTransitionUpdate(root2, queue, lane) {
  if (0 !== (lane & 4194048)) {
    var queueLanes = queue.lanes;
    queueLanes &= root2.pendingLanes;
    lane |= queueLanes;
    queue.lanes = lane;
    markRootEntangled(root2, lane);
  }
}
var ContextOnlyDispatcher = {
  readContext,
  use,
  useCallback: throwInvalidHookError,
  useContext: throwInvalidHookError,
  useEffect: throwInvalidHookError,
  useImperativeHandle: throwInvalidHookError,
  useLayoutEffect: throwInvalidHookError,
  useInsertionEffect: throwInvalidHookError,
  useMemo: throwInvalidHookError,
  useReducer: throwInvalidHookError,
  useRef: throwInvalidHookError,
  useState: throwInvalidHookError,
  useDebugValue: throwInvalidHookError,
  useDeferredValue: throwInvalidHookError,
  useTransition: throwInvalidHookError,
  useSyncExternalStore: throwInvalidHookError,
  useId: throwInvalidHookError,
  useHostTransitionStatus: throwInvalidHookError,
  useFormState: throwInvalidHookError,
  useActionState: throwInvalidHookError,
  useOptimistic: throwInvalidHookError,
  useMemoCache: throwInvalidHookError,
  useCacheRefresh: throwInvalidHookError
}, HooksDispatcherOnMount = {
  readContext,
  use,
  useCallback: function(callback, deps) {
    mountWorkInProgressHook().memoizedState = [
      callback,
      void 0 === deps ? null : deps
    ];
    return callback;
  },
  useContext: readContext,
  useEffect: mountEffect,
  useImperativeHandle: function(ref, create, deps) {
    deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
    mountEffectImpl(
      4194308,
      4,
      imperativeHandleEffect.bind(null, create, ref),
      deps
    );
  },
  useLayoutEffect: function(create, deps) {
    return mountEffectImpl(4194308, 4, create, deps);
  },
  useInsertionEffect: function(create, deps) {
    mountEffectImpl(4, 2, create, deps);
  },
  useMemo: function(nextCreate, deps) {
    var hook = mountWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var nextValue = nextCreate();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(true);
      try {
        nextCreate();
      } finally {
        setIsStrictModeForDevtools(false);
      }
    }
    hook.memoizedState = [nextValue, deps];
    return nextValue;
  },
  useReducer: function(reducer, initialArg, init) {
    var hook = mountWorkInProgressHook();
    if (void 0 !== init) {
      var initialState = init(initialArg);
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          init(initialArg);
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
    } else initialState = initialArg;
    hook.memoizedState = hook.baseState = initialState;
    reducer = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: reducer,
      lastRenderedState: initialState
    };
    hook.queue = reducer;
    reducer = reducer.dispatch = dispatchReducerAction.bind(
      null,
      currentlyRenderingFiber,
      reducer
    );
    return [hook.memoizedState, reducer];
  },
  useRef: function(initialValue) {
    var hook = mountWorkInProgressHook();
    initialValue = { current: initialValue };
    return hook.memoizedState = initialValue;
  },
  useState: function(initialState) {
    initialState = mountStateImpl(initialState);
    var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
    queue.dispatch = dispatch;
    return [initialState.memoizedState, dispatch];
  },
  useDebugValue: mountDebugValue,
  useDeferredValue: function(value, initialValue) {
    var hook = mountWorkInProgressHook();
    return mountDeferredValueImpl(hook, value, initialValue);
  },
  useTransition: function() {
    var stateHook = mountStateImpl(false);
    stateHook = startTransition.bind(
      null,
      currentlyRenderingFiber,
      stateHook.queue,
      true,
      false
    );
    mountWorkInProgressHook().memoizedState = stateHook;
    return [false, stateHook];
  },
  useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
    var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
    if (isHydrating) {
      if (void 0 === getServerSnapshot)
        throw Error(formatProdErrorMessage(407));
      getServerSnapshot = getServerSnapshot();
    } else {
      getServerSnapshot = getSnapshot();
      if (null === workInProgressRoot)
        throw Error(formatProdErrorMessage(349));
      0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
    }
    hook.memoizedState = getServerSnapshot;
    var inst = { value: getServerSnapshot, getSnapshot };
    hook.queue = inst;
    mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
      subscribe
    ]);
    fiber.flags |= 2048;
    pushSimpleEffect(
      9,
      createEffectInstance(),
      updateStoreInstance.bind(
        null,
        fiber,
        inst,
        getServerSnapshot,
        getSnapshot
      ),
      null
    );
    return getServerSnapshot;
  },
  useId: function() {
    var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
    if (isHydrating) {
      var JSCompiler_inline_result = treeContextOverflow;
      var idWithLeadingBit = treeContextId;
      JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
      identifierPrefix = "«" + identifierPrefix + "R" + JSCompiler_inline_result;
      JSCompiler_inline_result = localIdCounter++;
      0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
      identifierPrefix += "»";
    } else
      JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "«" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + "»";
    return hook.memoizedState = identifierPrefix;
  },
  useHostTransitionStatus,
  useFormState: mountActionState,
  useActionState: mountActionState,
  useOptimistic: function(passthrough) {
    var hook = mountWorkInProgressHook();
    hook.memoizedState = hook.baseState = passthrough;
    var queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: null,
      lastRenderedState: null
    };
    hook.queue = queue;
    hook = dispatchOptimisticSetState.bind(
      null,
      currentlyRenderingFiber,
      true,
      queue
    );
    queue.dispatch = hook;
    return [passthrough, hook];
  },
  useMemoCache,
  useCacheRefresh: function() {
    return mountWorkInProgressHook().memoizedState = refreshCache.bind(
      null,
      currentlyRenderingFiber
    );
  }
}, HooksDispatcherOnUpdate = {
  readContext,
  use,
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useInsertionEffect: updateInsertionEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: updateReducer,
  useRef: updateRef,
  useState: function() {
    return updateReducer(basicStateReducer);
  },
  useDebugValue: mountDebugValue,
  useDeferredValue: function(value, initialValue) {
    var hook = updateWorkInProgressHook();
    return updateDeferredValueImpl(
      hook,
      currentHook.memoizedState,
      value,
      initialValue
    );
  },
  useTransition: function() {
    var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
    return [
      "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
      start
    ];
  },
  useSyncExternalStore: updateSyncExternalStore,
  useId: updateId,
  useHostTransitionStatus,
  useFormState: updateActionState,
  useActionState: updateActionState,
  useOptimistic: function(passthrough, reducer) {
    var hook = updateWorkInProgressHook();
    return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
  },
  useMemoCache,
  useCacheRefresh: updateRefresh
}, HooksDispatcherOnRerender = {
  readContext,
  use,
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useInsertionEffect: updateInsertionEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: rerenderReducer,
  useRef: updateRef,
  useState: function() {
    return rerenderReducer(basicStateReducer);
  },
  useDebugValue: mountDebugValue,
  useDeferredValue: function(value, initialValue) {
    var hook = updateWorkInProgressHook();
    return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
      hook,
      currentHook.memoizedState,
      value,
      initialValue
    );
  },
  useTransition: function() {
    var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
    return [
      "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
      start
    ];
  },
  useSyncExternalStore: updateSyncExternalStore,
  useId: updateId,
  useHostTransitionStatus,
  useFormState: rerenderActionState,
  useActionState: rerenderActionState,
  useOptimistic: function(passthrough, reducer) {
    var hook = updateWorkInProgressHook();
    if (null !== currentHook)
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    hook.baseState = passthrough;
    return [passthrough, hook.queue.dispatch];
  },
  useMemoCache,
  useCacheRefresh: updateRefresh
}, thenableState = null, thenableIndexCounter = 0;
function unwrapThenable(thenable) {
  var index2 = thenableIndexCounter;
  thenableIndexCounter += 1;
  null === thenableState && (thenableState = []);
  return trackUsedThenable(thenableState, thenable, index2);
}
function coerceRef(workInProgress2, element) {
  element = element.props.ref;
  workInProgress2.ref = void 0 !== element ? element : null;
}
function throwOnInvalidObjectType(returnFiber, newChild) {
  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
    throw Error(formatProdErrorMessage(525));
  returnFiber = Object.prototype.toString.call(newChild);
  throw Error(
    formatProdErrorMessage(
      31,
      "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
    )
  );
}
function resolveLazy(lazyType) {
  var init = lazyType._init;
  return init(lazyType._payload);
}
function createChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (shouldTrackSideEffects) {
      var deletions = returnFiber.deletions;
      null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
    }
  }
  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) return null;
    for (; null !== currentFirstChild; )
      deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
    return null;
  }
  function mapRemainingChildren(currentFirstChild) {
    for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
      null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
    return existingChildren;
  }
  function useFiber(fiber, pendingProps) {
    fiber = createWorkInProgress(fiber, pendingProps);
    fiber.index = 0;
    fiber.sibling = null;
    return fiber;
  }
  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects)
      return newFiber.flags |= 1048576, lastPlacedIndex;
    newIndex = newFiber.alternate;
    if (null !== newIndex)
      return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
    newFiber.flags |= 67108866;
    return lastPlacedIndex;
  }
  function placeSingleChild(newFiber) {
    shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
    return newFiber;
  }
  function updateTextNode(returnFiber, current, textContent, lanes) {
    if (null === current || 6 !== current.tag)
      return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
    current = useFiber(current, textContent);
    current.return = returnFiber;
    return current;
  }
  function updateElement(returnFiber, current, element, lanes) {
    var elementType = element.type;
    if (elementType === REACT_FRAGMENT_TYPE)
      return updateFragment(
        returnFiber,
        current,
        element.props.children,
        lanes,
        element.key
      );
    if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
      return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
    current = createFiberFromTypeAndProps(
      element.type,
      element.key,
      element.props,
      null,
      returnFiber.mode,
      lanes
    );
    coerceRef(current, element);
    current.return = returnFiber;
    return current;
  }
  function updatePortal(returnFiber, current, portal, lanes) {
    if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
      return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
    current = useFiber(current, portal.children || []);
    current.return = returnFiber;
    return current;
  }
  function updateFragment(returnFiber, current, fragment, lanes, key) {
    if (null === current || 7 !== current.tag)
      return current = createFiberFromFragment(
        fragment,
        returnFiber.mode,
        lanes,
        key
      ), current.return = returnFiber, current;
    current = useFiber(current, fragment);
    current.return = returnFiber;
    return current;
  }
  function createChild(returnFiber, newChild, lanes) {
    if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
      return newChild = createFiberFromText(
        "" + newChild,
        returnFiber.mode,
        lanes
      ), newChild.return = returnFiber, newChild;
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return lanes = createFiberFromTypeAndProps(
            newChild.type,
            newChild.key,
            newChild.props,
            null,
            returnFiber.mode,
            lanes
          ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
        case REACT_PORTAL_TYPE:
          return newChild = createFiberFromPortal(
            newChild,
            returnFiber.mode,
            lanes
          ), newChild.return = returnFiber, newChild;
        case REACT_LAZY_TYPE:
          var init = newChild._init;
          newChild = init(newChild._payload);
          return createChild(returnFiber, newChild, lanes);
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return newChild = createFiberFromFragment(
          newChild,
          returnFiber.mode,
          lanes,
          null
        ), newChild.return = returnFiber, newChild;
      if ("function" === typeof newChild.then)
        return createChild(returnFiber, unwrapThenable(newChild), lanes);
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return createChild(
          returnFiber,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }
  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
    var key = null !== oldFiber ? oldFiber.key : null;
    if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
      return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
        case REACT_PORTAL_TYPE:
          return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
        case REACT_LAZY_TYPE:
          return key = newChild._init, newChild = key(newChild._payload), updateSlot(returnFiber, oldFiber, newChild, lanes);
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
      if ("function" === typeof newChild.then)
        return updateSlot(
          returnFiber,
          oldFiber,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return updateSlot(
          returnFiber,
          oldFiber,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }
  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
    if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
      return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return existingChildren = existingChildren.get(
            null === newChild.key ? newIdx : newChild.key
          ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
        case REACT_PORTAL_TYPE:
          return existingChildren = existingChildren.get(
            null === newChild.key ? newIdx : newChild.key
          ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
        case REACT_LAZY_TYPE:
          var init = newChild._init;
          newChild = init(newChild._payload);
          return updateFromMap(
            existingChildren,
            returnFiber,
            newIdx,
            newChild,
            lanes
          );
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
      if ("function" === typeof newChild.then)
        return updateFromMap(
          existingChildren,
          returnFiber,
          newIdx,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return updateFromMap(
          existingChildren,
          returnFiber,
          newIdx,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return null;
  }
  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
    for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
      oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
      var newFiber = updateSlot(
        returnFiber,
        oldFiber,
        newChildren[newIdx],
        lanes
      );
      if (null === newFiber) {
        null === oldFiber && (oldFiber = nextOldFiber);
        break;
      }
      shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
      null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (newIdx === newChildren.length)
      return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
    if (null === oldFiber) {
      for (; newIdx < newChildren.length; newIdx++)
        oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
          oldFiber,
          currentFirstChild,
          newIdx
        ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
      nextOldFiber = updateFromMap(
        oldFiber,
        returnFiber,
        newIdx,
        newChildren[newIdx],
        lanes
      ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
        null === nextOldFiber.key ? newIdx : nextOldFiber.key
      ), currentFirstChild = placeChild(
        nextOldFiber,
        currentFirstChild,
        newIdx
      ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
    shouldTrackSideEffects && oldFiber.forEach(function(child) {
      return deleteChild(returnFiber, child);
    });
    isHydrating && pushTreeFork(returnFiber, newIdx);
    return resultingFirstChild;
  }
  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
    if (null == newChildren) throw Error(formatProdErrorMessage(151));
    for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
      oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
      if (null === newFiber) {
        null === oldFiber && (oldFiber = nextOldFiber);
        break;
      }
      shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
      null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (step.done)
      return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
    if (null === oldFiber) {
      for (; !step.done; newIdx++, step = newChildren.next())
        step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
      step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
    shouldTrackSideEffects && oldFiber.forEach(function(child) {
      return deleteChild(returnFiber, child);
    });
    isHydrating && pushTreeFork(returnFiber, newIdx);
    return resultingFirstChild;
  }
  function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
    "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          a: {
            for (var key = newChild.key; null !== currentFirstChild; ) {
              if (currentFirstChild.key === key) {
                key = newChild.type;
                if (key === REACT_FRAGMENT_TYPE) {
                  if (7 === currentFirstChild.tag) {
                    deleteRemainingChildren(
                      returnFiber,
                      currentFirstChild.sibling
                    );
                    lanes = useFiber(
                      currentFirstChild,
                      newChild.props.children
                    );
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  }
                } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                  deleteRemainingChildren(
                    returnFiber,
                    currentFirstChild.sibling
                  );
                  lanes = useFiber(currentFirstChild, newChild.props);
                  coerceRef(lanes, newChild);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                  break a;
                }
                deleteRemainingChildren(returnFiber, currentFirstChild);
                break;
              } else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }
            newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
              newChild.props.children,
              returnFiber.mode,
              lanes,
              newChild.key
            ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
              newChild.type,
              newChild.key,
              newChild.props,
              null,
              returnFiber.mode,
              lanes
            ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
          }
          return placeSingleChild(returnFiber);
        case REACT_PORTAL_TYPE:
          a: {
            for (key = newChild.key; null !== currentFirstChild; ) {
              if (currentFirstChild.key === key)
                if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                  deleteRemainingChildren(
                    returnFiber,
                    currentFirstChild.sibling
                  );
                  lanes = useFiber(currentFirstChild, newChild.children || []);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                  break a;
                } else {
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                }
              else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }
            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
            lanes.return = returnFiber;
            returnFiber = lanes;
          }
          return placeSingleChild(returnFiber);
        case REACT_LAZY_TYPE:
          return key = newChild._init, newChild = key(newChild._payload), reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
      }
      if (isArrayImpl(newChild))
        return reconcileChildrenArray(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
      if (getIteratorFn(newChild)) {
        key = getIteratorFn(newChild);
        if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
        newChild = key.call(newChild);
        return reconcileChildrenIterator(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
      }
      if ("function" === typeof newChild.then)
        return reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectType(returnFiber, newChild);
    }
    return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
  }
  return function(returnFiber, currentFirstChild, newChild, lanes) {
    try {
      thenableIndexCounter = 0;
      var firstChildFiber = reconcileChildFibersImpl(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes
      );
      thenableState = null;
      return firstChildFiber;
    } catch (x) {
      if (x === SuspenseException || x === SuspenseActionException) throw x;
      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
      fiber.lanes = lanes;
      fiber.return = returnFiber;
      return fiber;
    } finally {
    }
  };
}
var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
function pushPrimaryTreeSuspenseHandler(handler) {
  var current = handler.alternate;
  push(suspenseStackCursor, suspenseStackCursor.current & 1);
  push(suspenseHandlerStackCursor, handler);
  null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
}
function pushOffscreenSuspenseHandler(fiber) {
  if (22 === fiber.tag) {
    if (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary) {
      var current = fiber.alternate;
      null !== current && null !== current.memoizedState && (shellBoundary = fiber);
    }
  } else reuseSuspenseHandlerOnStack();
}
function reuseSuspenseHandlerOnStack() {
  push(suspenseStackCursor, suspenseStackCursor.current);
  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
}
function popSuspenseHandler(fiber) {
  pop(suspenseHandlerStackCursor);
  shellBoundary === fiber && (shellBoundary = null);
  pop(suspenseStackCursor);
}
var suspenseStackCursor = createCursor(0);
function findFirstSuspended(row) {
  for (var node = row; null !== node; ) {
    if (13 === node.tag) {
      var state = node.memoizedState;
      if (null !== state && (state = state.dehydrated, null === state || "$?" === state.data || isSuspenseInstanceFallback(state)))
        return node;
    } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
      if (0 !== (node.flags & 128)) return node;
    } else if (null !== node.child) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === row) break;
    for (; null === node.sibling; ) {
      if (null === node.return || node.return === row) return null;
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
  return null;
}
function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
  ctor = workInProgress2.memoizedState;
  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
  getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
  workInProgress2.memoizedState = getDerivedStateFromProps;
  0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
}
var classComponentUpdater = {
  enqueueSetState: function(inst, payload, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(), update = createUpdate(lane);
    update.payload = payload;
    void 0 !== callback && null !== callback && (update.callback = callback);
    payload = enqueueUpdate(inst, update, lane);
    null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
  },
  enqueueReplaceState: function(inst, payload, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(), update = createUpdate(lane);
    update.tag = 1;
    update.payload = payload;
    void 0 !== callback && null !== callback && (update.callback = callback);
    payload = enqueueUpdate(inst, update, lane);
    null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
  },
  enqueueForceUpdate: function(inst, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(), update = createUpdate(lane);
    update.tag = 2;
    void 0 !== callback && null !== callback && (update.callback = callback);
    callback = enqueueUpdate(inst, update, lane);
    null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
  }
};
function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
  workInProgress2 = workInProgress2.stateNode;
  return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
}
function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
  workInProgress2 = instance.state;
  "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
  "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
  instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
}
function resolveClassComponentProps(Component2, baseProps) {
  var newProps = baseProps;
  if ("ref" in baseProps) {
    newProps = {};
    for (var propName in baseProps)
      "ref" !== propName && (newProps[propName] = baseProps[propName]);
  }
  if (Component2 = Component2.defaultProps) {
    newProps === baseProps && (newProps = assign({}, newProps));
    for (var propName$73 in Component2)
      void 0 === newProps[propName$73] && (newProps[propName$73] = Component2[propName$73]);
  }
  return newProps;
}
var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
  if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
    var event = new window.ErrorEvent("error", {
      bubbles: true,
      cancelable: true,
      message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
      error
    });
    if (!window.dispatchEvent(event)) return;
  } else if ("object" === typeof process && "function" === typeof process.emit) {
    process.emit("uncaughtException", error);
    return;
  }
  console.error(error);
};
function defaultOnUncaughtError(error) {
  reportGlobalError(error);
}
function defaultOnCaughtError(error) {
  console.error(error);
}
function defaultOnRecoverableError(error) {
  reportGlobalError(error);
}
function logUncaughtError(root2, errorInfo) {
  try {
    var onUncaughtError = root2.onUncaughtError;
    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
  } catch (e$74) {
    setTimeout(function() {
      throw e$74;
    });
  }
}
function logCaughtError(root2, boundary, errorInfo) {
  try {
    var onCaughtError = root2.onCaughtError;
    onCaughtError(errorInfo.value, {
      componentStack: errorInfo.stack,
      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
    });
  } catch (e$75) {
    setTimeout(function() {
      throw e$75;
    });
  }
}
function createRootErrorUpdate(root2, errorInfo, lane) {
  lane = createUpdate(lane);
  lane.tag = 3;
  lane.payload = { element: null };
  lane.callback = function() {
    logUncaughtError(root2, errorInfo);
  };
  return lane;
}
function createClassErrorUpdate(lane) {
  lane = createUpdate(lane);
  lane.tag = 3;
  return lane;
}
function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
  if ("function" === typeof getDerivedStateFromError) {
    var error = errorInfo.value;
    update.payload = function() {
      return getDerivedStateFromError(error);
    };
    update.callback = function() {
      logCaughtError(root2, fiber, errorInfo);
    };
  }
  var inst = fiber.stateNode;
  null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
    logCaughtError(root2, fiber, errorInfo);
    "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
    var stack = errorInfo.stack;
    this.componentDidCatch(errorInfo.value, {
      componentStack: null !== stack ? stack : ""
    });
  });
}
function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
  sourceFiber.flags |= 32768;
  if (null !== value && "object" === typeof value && "function" === typeof value.then) {
    returnFiber = sourceFiber.alternate;
    null !== returnFiber && propagateParentContextChanges(
      returnFiber,
      sourceFiber,
      rootRenderLanes,
      true
    );
    sourceFiber = suspenseHandlerStackCursor.current;
    if (null !== sourceFiber) {
      switch (sourceFiber.tag) {
        case 13:
          return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
        case 22:
          return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
            transitions: null,
            markerInstances: null,
            retryQueue: /* @__PURE__ */ new Set([value])
          }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
      }
      throw Error(formatProdErrorMessage(435, sourceFiber.tag));
    }
    attachPingListener(root2, value, rootRenderLanes);
    renderDidSuspendDelayIfPossible();
    return false;
  }
  if (isHydrating)
    return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
      cause: value
    }), queueHydrationError(
      createCapturedValueAtFiber(returnFiber, sourceFiber)
    )), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
      root2.stateNode,
      value,
      rootRenderLanes
    ), enqueueCapturedUpdate(root2, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
  null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
  if (null === returnFiber) return true;
  value = createCapturedValueAtFiber(value, sourceFiber);
  sourceFiber = returnFiber;
  do {
    switch (sourceFiber.tag) {
      case 3:
        return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
      case 1:
        if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
          return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
            rootRenderLanes,
            root2,
            sourceFiber,
            value
          ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
    }
    sourceFiber = sourceFiber.return;
  } while (null !== sourceFiber);
  return false;
}
var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
  workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
    workInProgress2,
    current.child,
    nextChildren,
    renderLanes2
  );
}
function updateForwardRef(current, workInProgress2, Component2, nextProps, renderLanes2) {
  Component2 = Component2.render;
  var ref = workInProgress2.ref;
  if ("ref" in nextProps) {
    var propsWithoutRef = {};
    for (var key in nextProps)
      "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
  } else propsWithoutRef = nextProps;
  prepareToReadContext(workInProgress2);
  nextProps = renderWithHooks(
    current,
    workInProgress2,
    Component2,
    propsWithoutRef,
    ref,
    renderLanes2
  );
  key = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
  isHydrating && key && pushMaterializedTreeId(workInProgress2);
  workInProgress2.flags |= 1;
  reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
  return workInProgress2.child;
}
function updateMemoComponent(current, workInProgress2, Component2, nextProps, renderLanes2) {
  if (null === current) {
    var type = Component2.type;
    if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component2.compare)
      return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
        current,
        workInProgress2,
        type,
        nextProps,
        renderLanes2
      );
    current = createFiberFromTypeAndProps(
      Component2.type,
      null,
      nextProps,
      workInProgress2,
      workInProgress2.mode,
      renderLanes2
    );
    current.ref = workInProgress2.ref;
    current.return = workInProgress2;
    return workInProgress2.child = current;
  }
  type = current.child;
  if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
    var prevProps = type.memoizedProps;
    Component2 = Component2.compare;
    Component2 = null !== Component2 ? Component2 : shallowEqual;
    if (Component2(prevProps, nextProps) && current.ref === workInProgress2.ref)
      return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
  }
  workInProgress2.flags |= 1;
  current = createWorkInProgress(type, nextProps);
  current.ref = workInProgress2.ref;
  current.return = workInProgress2;
  return workInProgress2.child = current;
}
function updateSimpleMemoComponent(current, workInProgress2, Component2, nextProps, renderLanes2) {
  if (null !== current) {
    var prevProps = current.memoizedProps;
    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
      if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
        0 !== (current.flags & 131072) && (didReceiveUpdate = true);
      else
        return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
  }
  return updateFunctionComponent(
    current,
    workInProgress2,
    Component2,
    nextProps,
    renderLanes2
  );
}
function updateOffscreenComponent(current, workInProgress2, renderLanes2) {
  var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
  if ("hidden" === nextProps.mode) {
    if (0 !== (workInProgress2.flags & 128)) {
      nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
      if (null !== current) {
        nextChildren = workInProgress2.child = current.child;
        for (prevState = 0; null !== nextChildren; )
          prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
        workInProgress2.childLanes = prevState & ~nextProps;
      } else workInProgress2.childLanes = 0, workInProgress2.child = null;
      return deferHiddenOffscreenComponent(
        current,
        workInProgress2,
        nextProps,
        renderLanes2
      );
    }
    if (0 !== (renderLanes2 & 536870912))
      workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
        workInProgress2,
        null !== prevState ? prevState.cachePool : null
      ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
    else
      return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
        current,
        workInProgress2,
        null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
        renderLanes2
      );
  } else
    null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack());
  reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
  return workInProgress2.child;
}
function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2) {
  var JSCompiler_inline_result = peekCacheFromPool();
  JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
  workInProgress2.memoizedState = {
    baseLanes: nextBaseLanes,
    cachePool: JSCompiler_inline_result
  };
  null !== current && pushTransition(workInProgress2, null);
  reuseHiddenContextOnStack();
  pushOffscreenSuspenseHandler(workInProgress2);
  null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
  return null;
}
function markRef(current, workInProgress2) {
  var ref = workInProgress2.ref;
  if (null === ref)
    null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
  else {
    if ("function" !== typeof ref && "object" !== typeof ref)
      throw Error(formatProdErrorMessage(284));
    if (null === current || current.ref !== ref)
      workInProgress2.flags |= 4194816;
  }
}
function updateFunctionComponent(current, workInProgress2, Component2, nextProps, renderLanes2) {
  prepareToReadContext(workInProgress2);
  Component2 = renderWithHooks(
    current,
    workInProgress2,
    Component2,
    nextProps,
    void 0,
    renderLanes2
  );
  nextProps = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
  isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
  workInProgress2.flags |= 1;
  reconcileChildren(current, workInProgress2, Component2, renderLanes2);
  return workInProgress2.child;
}
function replayFunctionComponent(current, workInProgress2, nextProps, Component2, secondArg, renderLanes2) {
  prepareToReadContext(workInProgress2);
  workInProgress2.updateQueue = null;
  nextProps = renderWithHooksAgain(
    workInProgress2,
    Component2,
    nextProps,
    secondArg
  );
  finishRenderingHooks(current);
  Component2 = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
  isHydrating && Component2 && pushMaterializedTreeId(workInProgress2);
  workInProgress2.flags |= 1;
  reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
  return workInProgress2.child;
}
function updateClassComponent(current, workInProgress2, Component2, nextProps, renderLanes2) {
  prepareToReadContext(workInProgress2);
  if (null === workInProgress2.stateNode) {
    var context = emptyContextObject, contextType = Component2.contextType;
    "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
    context = new Component2(nextProps, context);
    workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
    context.updater = classComponentUpdater;
    workInProgress2.stateNode = context;
    context._reactInternals = workInProgress2;
    context = workInProgress2.stateNode;
    context.props = nextProps;
    context.state = workInProgress2.memoizedState;
    context.refs = {};
    initializeUpdateQueue(workInProgress2);
    contextType = Component2.contextType;
    context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
    context.state = workInProgress2.memoizedState;
    contextType = Component2.getDerivedStateFromProps;
    "function" === typeof contextType && (applyDerivedStateFromProps(
      workInProgress2,
      Component2,
      contextType,
      nextProps
    ), context.state = workInProgress2.memoizedState);
    "function" === typeof Component2.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
    "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
    nextProps = true;
  } else if (null === current) {
    context = workInProgress2.stateNode;
    var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component2, unresolvedOldProps);
    context.props = oldProps;
    var oldContext = context.context, contextType$jscomp$0 = Component2.contextType;
    contextType = emptyContextObject;
    "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
    var getDerivedStateFromProps = Component2.getDerivedStateFromProps;
    contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
    unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
    contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
      workInProgress2,
      context,
      nextProps,
      contextType
    );
    hasForceUpdate = false;
    var oldState = workInProgress2.memoizedState;
    context.state = oldState;
    processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
    suspendIfUpdateReadFromEntangledAsyncAction();
    oldContext = workInProgress2.memoizedState;
    unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
      workInProgress2,
      Component2,
      getDerivedStateFromProps,
      nextProps
    ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
      workInProgress2,
      Component2,
      oldProps,
      nextProps,
      oldState,
      oldContext,
      contextType
    )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
  } else {
    context = workInProgress2.stateNode;
    cloneUpdateQueue(current, workInProgress2);
    contextType = workInProgress2.memoizedProps;
    contextType$jscomp$0 = resolveClassComponentProps(Component2, contextType);
    context.props = contextType$jscomp$0;
    getDerivedStateFromProps = workInProgress2.pendingProps;
    oldState = context.context;
    oldContext = Component2.contextType;
    oldProps = emptyContextObject;
    "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
    unresolvedOldProps = Component2.getDerivedStateFromProps;
    (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
      workInProgress2,
      context,
      nextProps,
      oldProps
    );
    hasForceUpdate = false;
    oldState = workInProgress2.memoizedState;
    context.state = oldState;
    processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
    suspendIfUpdateReadFromEntangledAsyncAction();
    var newState = workInProgress2.memoizedState;
    contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
      workInProgress2,
      Component2,
      unresolvedOldProps,
      nextProps
    ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
      workInProgress2,
      Component2,
      contextType$jscomp$0,
      nextProps,
      oldState,
      newState,
      oldProps
    ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
      nextProps,
      newState,
      oldProps
    )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
  }
  context = nextProps;
  markRef(current, workInProgress2);
  nextProps = 0 !== (workInProgress2.flags & 128);
  context || nextProps ? (context = workInProgress2.stateNode, Component2 = nextProps && "function" !== typeof Component2.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
    workInProgress2,
    current.child,
    null,
    renderLanes2
  ), workInProgress2.child = reconcileChildFibers(
    workInProgress2,
    null,
    Component2,
    renderLanes2
  )) : reconcileChildren(current, workInProgress2, Component2, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
    current,
    workInProgress2,
    renderLanes2
  );
  return current;
}
function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
  resetHydrationState();
  workInProgress2.flags |= 256;
  reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
  return workInProgress2.child;
}
var SUSPENDED_MARKER = {
  dehydrated: null,
  treeContext: null,
  retryLane: 0,
  hydrationErrors: null
};
function mountSuspenseOffscreenState(renderLanes2) {
  return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
}
function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
  current = null !== current ? current.childLanes & ~renderLanes2 : 0;
  primaryTreeDidDefer && (current |= workInProgressDeferredLane);
  return current;
}
function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
  var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
  (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
  JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
  JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
  workInProgress2.flags &= -33;
  if (null === current) {
    if (isHydrating) {
      showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack();
      if (isHydrating) {
        var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;
        if (JSCompiler_temp$jscomp$0 = nextInstance) {
          c: {
            JSCompiler_temp$jscomp$0 = nextInstance;
            for (nextInstance = rootOrSingletonContext; 8 !== JSCompiler_temp$jscomp$0.nodeType; ) {
              if (!nextInstance) {
                nextInstance = null;
                break c;
              }
              JSCompiler_temp$jscomp$0 = getNextHydratable(
                JSCompiler_temp$jscomp$0.nextSibling
              );
              if (null === JSCompiler_temp$jscomp$0) {
                nextInstance = null;
                break c;
              }
            }
            nextInstance = JSCompiler_temp$jscomp$0;
          }
          null !== nextInstance ? (workInProgress2.memoizedState = {
            dehydrated: nextInstance,
            treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
            retryLane: 536870912,
            hydrationErrors: null
          }, JSCompiler_temp$jscomp$0 = createFiberImplClass(
            18,
            null,
            null,
            0
          ), JSCompiler_temp$jscomp$0.stateNode = nextInstance, JSCompiler_temp$jscomp$0.return = workInProgress2, workInProgress2.child = JSCompiler_temp$jscomp$0, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = true) : JSCompiler_temp$jscomp$0 = false;
        }
        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress2);
      }
      nextInstance = workInProgress2.memoizedState;
      if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance))
        return isSuspenseInstanceFallback(nextInstance) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912, null;
      popSuspenseHandler(workInProgress2);
    }
    nextInstance = nextProps.children;
    nextProps = nextProps.fallback;
    if (showFallback)
      return reuseSuspenseHandlerOnStack(), showFallback = workInProgress2.mode, nextInstance = mountWorkInProgressOffscreenFiber(
        { mode: "hidden", children: nextInstance },
        showFallback
      ), nextProps = createFiberFromFragment(
        nextProps,
        showFallback,
        renderLanes2,
        null
      ), nextInstance.return = workInProgress2, nextProps.return = workInProgress2, nextInstance.sibling = nextProps, workInProgress2.child = nextInstance, showFallback = workInProgress2.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes2), showFallback.childLanes = getRemainingWorkInPrimaryTree(
        current,
        JSCompiler_temp,
        renderLanes2
      ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
    pushPrimaryTreeSuspenseHandler(workInProgress2);
    return mountSuspensePrimaryChildren(workInProgress2, nextInstance);
  }
  JSCompiler_temp$jscomp$0 = current.memoizedState;
  if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {
    if (didSuspend)
      workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
        current,
        workInProgress2,
        renderLanes2
      )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
        { mode: "visible", children: nextProps.children },
        nextInstance
      ), showFallback = createFiberFromFragment(
        showFallback,
        nextInstance,
        renderLanes2,
        null
      ), showFallback.flags |= 2, nextProps.return = workInProgress2, showFallback.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, reconcileChildFibers(
        workInProgress2,
        current.child,
        null,
        renderLanes2
      ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
        current,
        JSCompiler_temp,
        renderLanes2
      ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = showFallback);
    else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextInstance)) {
      JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset;
      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
      JSCompiler_temp = digest;
      nextProps = Error(formatProdErrorMessage(419));
      nextProps.stack = "";
      nextProps.digest = JSCompiler_temp;
      queueHydrationError({ value: nextProps, source: null, stack: null });
      workInProgress2 = retrySuspenseComponentWithoutHydrating(
        current,
        workInProgress2,
        renderLanes2
      );
    } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
      JSCompiler_temp = workInProgressRoot;
      if (null !== JSCompiler_temp && (nextProps = renderLanes2 & -renderLanes2, nextProps = 0 !== (nextProps & 42) ? 1 : getBumpedLaneForHydrationByLane(nextProps), nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes2)) ? 0 : nextProps, 0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane))
        throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
      "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
      workInProgress2 = retrySuspenseComponentWithoutHydrating(
        current,
        workInProgress2,
        renderLanes2
      );
    } else
      "$?" === nextInstance.data ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = JSCompiler_temp$jscomp$0.treeContext, nextHydratableInstance = getNextHydratable(
        nextInstance.nextSibling
      ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
        workInProgress2,
        nextProps.children
      ), workInProgress2.flags |= 4096);
    return workInProgress2;
  }
  if (showFallback)
    return reuseSuspenseHandlerOnStack(), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, JSCompiler_temp$jscomp$0 = current.child, digest = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
      mode: "hidden",
      children: nextProps.children
    }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712, null !== digest ? showFallback = createWorkInProgress(digest, showFallback) : (showFallback = createFiberFromFragment(
      showFallback,
      nextInstance,
      renderLanes2,
      null
    ), showFallback.flags |= 2), showFallback.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, nextProps = showFallback, showFallback = workInProgress2.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (digest = CacheContext._currentValue, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== digest ? { parent: digest, pool: digest } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
      baseLanes: nextInstance.baseLanes | renderLanes2,
      cachePool: JSCompiler_temp$jscomp$0
    }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(
      current,
      JSCompiler_temp,
      renderLanes2
    ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
  pushPrimaryTreeSuspenseHandler(workInProgress2);
  renderLanes2 = current.child;
  current = renderLanes2.sibling;
  renderLanes2 = createWorkInProgress(renderLanes2, {
    mode: "visible",
    children: nextProps.children
  });
  renderLanes2.return = workInProgress2;
  renderLanes2.sibling = null;
  null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
  workInProgress2.child = renderLanes2;
  workInProgress2.memoizedState = null;
  return renderLanes2;
}
function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
  primaryChildren = mountWorkInProgressOffscreenFiber(
    { mode: "visible", children: primaryChildren },
    workInProgress2.mode
  );
  primaryChildren.return = workInProgress2;
  return workInProgress2.child = primaryChildren;
}
function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
  offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
  offscreenProps.lanes = 0;
  offscreenProps.stateNode = {
    _visibility: 1,
    _pendingMarkers: null,
    _retryCache: null,
    _transitions: null
  };
  return offscreenProps;
}
function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
  reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
  current = mountSuspensePrimaryChildren(
    workInProgress2,
    workInProgress2.pendingProps.children
  );
  current.flags |= 2;
  workInProgress2.memoizedState = null;
  return current;
}
function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
  fiber.lanes |= renderLanes2;
  var alternate = fiber.alternate;
  null !== alternate && (alternate.lanes |= renderLanes2);
  scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
}
function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
  var renderState = workInProgress2.memoizedState;
  null === renderState ? workInProgress2.memoizedState = {
    isBackwards,
    rendering: null,
    renderingStartTime: 0,
    last: lastContentRow,
    tail,
    tailMode
  } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
}
function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
  var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
  reconcileChildren(current, workInProgress2, nextProps.children, renderLanes2);
  nextProps = suspenseStackCursor.current;
  if (0 !== (nextProps & 2))
    nextProps = nextProps & 1 | 2, workInProgress2.flags |= 128;
  else {
    if (null !== current && 0 !== (current.flags & 128))
      a: for (current = workInProgress2.child; null !== current; ) {
        if (13 === current.tag)
          null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
        else if (19 === current.tag)
          scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
        else if (null !== current.child) {
          current.child.return = current;
          current = current.child;
          continue;
        }
        if (current === workInProgress2) break a;
        for (; null === current.sibling; ) {
          if (null === current.return || current.return === workInProgress2)
            break a;
          current = current.return;
        }
        current.sibling.return = current.return;
        current = current.sibling;
      }
    nextProps &= 1;
  }
  push(suspenseStackCursor, nextProps);
  switch (revealOrder) {
    case "forwards":
      renderLanes2 = workInProgress2.child;
      for (revealOrder = null; null !== renderLanes2; )
        current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
      renderLanes2 = revealOrder;
      null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
      initSuspenseListRenderState(
        workInProgress2,
        false,
        revealOrder,
        renderLanes2,
        tailMode
      );
      break;
    case "backwards":
      renderLanes2 = null;
      revealOrder = workInProgress2.child;
      for (workInProgress2.child = null; null !== revealOrder; ) {
        current = revealOrder.alternate;
        if (null !== current && null === findFirstSuspended(current)) {
          workInProgress2.child = revealOrder;
          break;
        }
        current = revealOrder.sibling;
        revealOrder.sibling = renderLanes2;
        renderLanes2 = revealOrder;
        revealOrder = current;
      }
      initSuspenseListRenderState(
        workInProgress2,
        true,
        renderLanes2,
        null,
        tailMode
      );
      break;
    case "together":
      initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
      break;
    default:
      workInProgress2.memoizedState = null;
  }
  return workInProgress2.child;
}
function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
  null !== current && (workInProgress2.dependencies = current.dependencies);
  workInProgressRootSkippedLanes |= workInProgress2.lanes;
  if (0 === (renderLanes2 & workInProgress2.childLanes))
    if (null !== current) {
      if (propagateParentContextChanges(
        current,
        workInProgress2,
        renderLanes2,
        false
      ), 0 === (renderLanes2 & workInProgress2.childLanes))
        return null;
    } else return null;
  if (null !== current && workInProgress2.child !== current.child)
    throw Error(formatProdErrorMessage(153));
  if (null !== workInProgress2.child) {
    current = workInProgress2.child;
    renderLanes2 = createWorkInProgress(current, current.pendingProps);
    workInProgress2.child = renderLanes2;
    for (renderLanes2.return = workInProgress2; null !== current.sibling; )
      current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
    renderLanes2.sibling = null;
  }
  return workInProgress2.child;
}
function checkScheduledUpdateOrContext(current, renderLanes2) {
  if (0 !== (current.lanes & renderLanes2)) return true;
  current = current.dependencies;
  return null !== current && checkIfContextChanged(current) ? true : false;
}
function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
  switch (workInProgress2.tag) {
    case 3:
      pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
      pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
      resetHydrationState();
      break;
    case 27:
    case 5:
      pushHostContext(workInProgress2);
      break;
    case 4:
      pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
      break;
    case 10:
      pushProvider(
        workInProgress2,
        workInProgress2.type,
        workInProgress2.memoizedProps.value
      );
      break;
    case 13:
      var state = workInProgress2.memoizedState;
      if (null !== state) {
        if (null !== state.dehydrated)
          return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
        if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
          return updateSuspenseComponent(current, workInProgress2, renderLanes2);
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress2,
          renderLanes2
        );
        return null !== current ? current.sibling : null;
      }
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      break;
    case 19:
      var didSuspendBefore = 0 !== (current.flags & 128);
      state = 0 !== (renderLanes2 & workInProgress2.childLanes);
      state || (propagateParentContextChanges(
        current,
        workInProgress2,
        renderLanes2,
        false
      ), state = 0 !== (renderLanes2 & workInProgress2.childLanes));
      if (didSuspendBefore) {
        if (state)
          return updateSuspenseListComponent(
            current,
            workInProgress2,
            renderLanes2
          );
        workInProgress2.flags |= 128;
      }
      didSuspendBefore = workInProgress2.memoizedState;
      null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
      push(suspenseStackCursor, suspenseStackCursor.current);
      if (state) break;
      else return null;
    case 22:
    case 23:
      return workInProgress2.lanes = 0, updateOffscreenComponent(current, workInProgress2, renderLanes2);
    case 24:
      pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
  }
  return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
}
function beginWork(current, workInProgress2, renderLanes2) {
  if (null !== current)
    if (current.memoizedProps !== workInProgress2.pendingProps)
      didReceiveUpdate = true;
    else {
      if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
        return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
          current,
          workInProgress2,
          renderLanes2
        );
      didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
    }
  else
    didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
  workInProgress2.lanes = 0;
  switch (workInProgress2.tag) {
    case 16:
      a: {
        current = workInProgress2.pendingProps;
        var lazyComponent = workInProgress2.elementType, init = lazyComponent._init;
        lazyComponent = init(lazyComponent._payload);
        workInProgress2.type = lazyComponent;
        if ("function" === typeof lazyComponent)
          shouldConstruct(lazyComponent) ? (current = resolveClassComponentProps(lazyComponent, current), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
            null,
            workInProgress2,
            lazyComponent,
            current,
            renderLanes2
          )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
            null,
            workInProgress2,
            lazyComponent,
            current,
            renderLanes2
          ));
        else {
          if (void 0 !== lazyComponent && null !== lazyComponent) {
            if (init = lazyComponent.$$typeof, init === REACT_FORWARD_REF_TYPE) {
              workInProgress2.tag = 11;
              workInProgress2 = updateForwardRef(
                null,
                workInProgress2,
                lazyComponent,
                current,
                renderLanes2
              );
              break a;
            } else if (init === REACT_MEMO_TYPE) {
              workInProgress2.tag = 14;
              workInProgress2 = updateMemoComponent(
                null,
                workInProgress2,
                lazyComponent,
                current,
                renderLanes2
              );
              break a;
            }
          }
          workInProgress2 = getComponentNameFromType(lazyComponent) || lazyComponent;
          throw Error(formatProdErrorMessage(306, workInProgress2, ""));
        }
      }
      return workInProgress2;
    case 0:
      return updateFunctionComponent(
        current,
        workInProgress2,
        workInProgress2.type,
        workInProgress2.pendingProps,
        renderLanes2
      );
    case 1:
      return lazyComponent = workInProgress2.type, init = resolveClassComponentProps(
        lazyComponent,
        workInProgress2.pendingProps
      ), updateClassComponent(
        current,
        workInProgress2,
        lazyComponent,
        init,
        renderLanes2
      );
    case 3:
      a: {
        pushHostContainer(
          workInProgress2,
          workInProgress2.stateNode.containerInfo
        );
        if (null === current) throw Error(formatProdErrorMessage(387));
        lazyComponent = workInProgress2.pendingProps;
        var prevState = workInProgress2.memoizedState;
        init = prevState.element;
        cloneUpdateQueue(current, workInProgress2);
        processUpdateQueue(workInProgress2, lazyComponent, null, renderLanes2);
        var nextState = workInProgress2.memoizedState;
        lazyComponent = nextState.cache;
        pushProvider(workInProgress2, CacheContext, lazyComponent);
        lazyComponent !== prevState.cache && propagateContextChanges(
          workInProgress2,
          [CacheContext],
          renderLanes2,
          true
        );
        suspendIfUpdateReadFromEntangledAsyncAction();
        lazyComponent = nextState.element;
        if (prevState.isDehydrated)
          if (prevState = {
            element: lazyComponent,
            isDehydrated: false,
            cache: nextState.cache
          }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
            workInProgress2 = mountHostRootWithoutHydrating(
              current,
              workInProgress2,
              lazyComponent,
              renderLanes2
            );
            break a;
          } else if (lazyComponent !== init) {
            init = createCapturedValueAtFiber(
              Error(formatProdErrorMessage(424)),
              workInProgress2
            );
            queueHydrationError(init);
            workInProgress2 = mountHostRootWithoutHydrating(
              current,
              workInProgress2,
              lazyComponent,
              renderLanes2
            );
            break a;
          } else {
            current = workInProgress2.stateNode.containerInfo;
            switch (current.nodeType) {
              case 9:
                current = current.body;
                break;
              default:
                current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
            }
            nextHydratableInstance = getNextHydratable(current.firstChild);
            hydrationParentFiber = workInProgress2;
            isHydrating = true;
            hydrationErrors = null;
            rootOrSingletonContext = true;
            renderLanes2 = mountChildFibers(
              workInProgress2,
              null,
              lazyComponent,
              renderLanes2
            );
            for (workInProgress2.child = renderLanes2; renderLanes2; )
              renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
          }
        else {
          resetHydrationState();
          if (lazyComponent === init) {
            workInProgress2 = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress2,
              renderLanes2
            );
            break a;
          }
          reconcileChildren(
            current,
            workInProgress2,
            lazyComponent,
            renderLanes2
          );
        }
        workInProgress2 = workInProgress2.child;
      }
      return workInProgress2;
    case 26:
      return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
        workInProgress2.type,
        null,
        workInProgress2.pendingProps,
        null
      )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, lazyComponent = getOwnerDocumentFromRootContainer(
        rootInstanceStackCursor.current
      ).createElement(renderLanes2), lazyComponent[internalInstanceKey] = workInProgress2, lazyComponent[internalPropsKey] = current, setInitialProperties(lazyComponent, renderLanes2, current), markNodeAsHoistable(lazyComponent), workInProgress2.stateNode = lazyComponent) : workInProgress2.memoizedState = getResource(
        workInProgress2.type,
        current.memoizedProps,
        workInProgress2.pendingProps,
        current.memoizedState
      ), null;
    case 27:
      return pushHostContext(workInProgress2), null === current && isHydrating && (lazyComponent = workInProgress2.stateNode = resolveSingletonInstance(
        workInProgress2.type,
        workInProgress2.pendingProps,
        rootInstanceStackCursor.current
      ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, init = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = init, nextHydratableInstance = getNextHydratable(
        lazyComponent.firstChild
      )) : nextHydratableInstance = init), reconcileChildren(
        current,
        workInProgress2,
        workInProgress2.pendingProps.children,
        renderLanes2
      ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
    case 5:
      if (null === current && isHydrating) {
        if (init = lazyComponent = nextHydratableInstance)
          lazyComponent = canHydrateInstance(
            lazyComponent,
            workInProgress2.type,
            workInProgress2.pendingProps,
            rootOrSingletonContext
          ), null !== lazyComponent ? (workInProgress2.stateNode = lazyComponent, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
            lazyComponent.firstChild
          ), rootOrSingletonContext = false, init = true) : init = false;
        init || throwOnHydrationMismatch(workInProgress2);
      }
      pushHostContext(workInProgress2);
      init = workInProgress2.type;
      prevState = workInProgress2.pendingProps;
      nextState = null !== current ? current.memoizedProps : null;
      lazyComponent = prevState.children;
      shouldSetTextContent(init, prevState) ? lazyComponent = null : null !== nextState && shouldSetTextContent(init, nextState) && (workInProgress2.flags |= 32);
      null !== workInProgress2.memoizedState && (init = renderWithHooks(
        current,
        workInProgress2,
        TransitionAwareHostComponent,
        null,
        null,
        renderLanes2
      ), HostTransitionContext._currentValue = init);
      markRef(current, workInProgress2);
      reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2);
      return workInProgress2.child;
    case 6:
      if (null === current && isHydrating) {
        if (current = renderLanes2 = nextHydratableInstance)
          renderLanes2 = canHydrateTextInstance(
            renderLanes2,
            workInProgress2.pendingProps,
            rootOrSingletonContext
          ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
        current || throwOnHydrationMismatch(workInProgress2);
      }
      return null;
    case 13:
      return updateSuspenseComponent(current, workInProgress2, renderLanes2);
    case 4:
      return pushHostContainer(
        workInProgress2,
        workInProgress2.stateNode.containerInfo
      ), lazyComponent = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
        workInProgress2,
        null,
        lazyComponent,
        renderLanes2
      ) : reconcileChildren(
        current,
        workInProgress2,
        lazyComponent,
        renderLanes2
      ), workInProgress2.child;
    case 11:
      return updateForwardRef(
        current,
        workInProgress2,
        workInProgress2.type,
        workInProgress2.pendingProps,
        renderLanes2
      );
    case 7:
      return reconcileChildren(
        current,
        workInProgress2,
        workInProgress2.pendingProps,
        renderLanes2
      ), workInProgress2.child;
    case 8:
      return reconcileChildren(
        current,
        workInProgress2,
        workInProgress2.pendingProps.children,
        renderLanes2
      ), workInProgress2.child;
    case 12:
      return reconcileChildren(
        current,
        workInProgress2,
        workInProgress2.pendingProps.children,
        renderLanes2
      ), workInProgress2.child;
    case 10:
      return lazyComponent = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, lazyComponent.value), reconcileChildren(
        current,
        workInProgress2,
        lazyComponent.children,
        renderLanes2
      ), workInProgress2.child;
    case 9:
      return init = workInProgress2.type._context, lazyComponent = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), init = readContext(init), lazyComponent = lazyComponent(init), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2), workInProgress2.child;
    case 14:
      return updateMemoComponent(
        current,
        workInProgress2,
        workInProgress2.type,
        workInProgress2.pendingProps,
        renderLanes2
      );
    case 15:
      return updateSimpleMemoComponent(
        current,
        workInProgress2,
        workInProgress2.type,
        workInProgress2.pendingProps,
        renderLanes2
      );
    case 19:
      return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
    case 31:
      return lazyComponent = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, lazyComponent = {
        mode: lazyComponent.mode,
        children: lazyComponent.children
      }, null === current ? (renderLanes2 = mountWorkInProgressOffscreenFiber(
        lazyComponent,
        renderLanes2
      ), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2) : (renderLanes2 = createWorkInProgress(current.child, lazyComponent), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2), workInProgress2;
    case 22:
      return updateOffscreenComponent(current, workInProgress2, renderLanes2);
    case 24:
      return prepareToReadContext(workInProgress2), lazyComponent = readContext(CacheContext), null === current ? (init = peekCacheFromPool(), null === init && (init = workInProgressRoot, prevState = createCache(), init.pooledCache = prevState, prevState.refCount++, null !== prevState && (init.pooledCacheLanes |= renderLanes2), init = prevState), workInProgress2.memoizedState = {
        parent: lazyComponent,
        cache: init
      }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, init)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), init = current.memoizedState, prevState = workInProgress2.memoizedState, init.parent !== lazyComponent ? (init = { parent: lazyComponent, cache: lazyComponent }, workInProgress2.memoizedState = init, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = init), pushProvider(workInProgress2, CacheContext, lazyComponent)) : (lazyComponent = prevState.cache, pushProvider(workInProgress2, CacheContext, lazyComponent), lazyComponent !== init.cache && propagateContextChanges(
        workInProgress2,
        [CacheContext],
        renderLanes2,
        true
      ))), reconcileChildren(
        current,
        workInProgress2,
        workInProgress2.pendingProps.children,
        renderLanes2
      ), workInProgress2.child;
    case 29:
      throw workInProgress2.pendingProps;
  }
  throw Error(formatProdErrorMessage(156, workInProgress2.tag));
}
function markUpdate(workInProgress2) {
  workInProgress2.flags |= 4;
}
function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
  if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
    workInProgress2.flags &= -16777217;
  else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
    resource = suspenseHandlerStackCursor.current;
    if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
      throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
    workInProgress2.flags |= 8192;
  }
}
function scheduleRetryEffect(workInProgress2, retryQueue) {
  null !== retryQueue && (workInProgress2.flags |= 4);
  workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
}
function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
  if (!isHydrating)
    switch (renderState.tailMode) {
      case "hidden":
        hasRenderedATailFallback = renderState.tail;
        for (var lastTailNode = null; null !== hasRenderedATailFallback; )
          null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
        null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
        break;
      case "collapsed":
        lastTailNode = renderState.tail;
        for (var lastTailNode$113 = null; null !== lastTailNode; )
          null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode), lastTailNode = lastTailNode.sibling;
        null === lastTailNode$113 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$113.sibling = null;
    }
}
function bubbleProperties(completedWork) {
  var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
  if (didBailout)
    for (var child$114 = completedWork.child; null !== child$114; )
      newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags & 65011712, subtreeFlags |= child$114.flags & 65011712, child$114.return = completedWork, child$114 = child$114.sibling;
  else
    for (child$114 = completedWork.child; null !== child$114; )
      newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags, subtreeFlags |= child$114.flags, child$114.return = completedWork, child$114 = child$114.sibling;
  completedWork.subtreeFlags |= subtreeFlags;
  completedWork.childLanes = newChildLanes;
  return didBailout;
}
function completeWork(current, workInProgress2, renderLanes2) {
  var newProps = workInProgress2.pendingProps;
  popTreeContext(workInProgress2);
  switch (workInProgress2.tag) {
    case 31:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return bubbleProperties(workInProgress2), null;
    case 1:
      return bubbleProperties(workInProgress2), null;
    case 3:
      renderLanes2 = workInProgress2.stateNode;
      newProps = null;
      null !== current && (newProps = current.memoizedState.cache);
      workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
      popProvider(CacheContext);
      popHostContainer();
      renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
      if (null === current || null === current.child)
        popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
      bubbleProperties(workInProgress2);
      return null;
    case 26:
      return renderLanes2 = workInProgress2.memoizedState, null === current ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
    case 27:
      popHostContext(workInProgress2);
      renderLanes2 = rootInstanceStackCursor.current;
      var type = workInProgress2.type;
      if (null !== current && null != workInProgress2.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress2);
      else {
        if (!newProps) {
          if (null === workInProgress2.stateNode)
            throw Error(formatProdErrorMessage(166));
          bubbleProperties(workInProgress2);
          return null;
        }
        current = contextStackCursor.current;
        popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
      }
      bubbleProperties(workInProgress2);
      return null;
    case 5:
      popHostContext(workInProgress2);
      renderLanes2 = workInProgress2.type;
      if (null !== current && null != workInProgress2.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress2);
      else {
        if (!newProps) {
          if (null === workInProgress2.stateNode)
            throw Error(formatProdErrorMessage(166));
          bubbleProperties(workInProgress2);
          return null;
        }
        current = contextStackCursor.current;
        if (popHydrationState(workInProgress2))
          prepareToHydrateHostInstance(workInProgress2);
        else {
          type = getOwnerDocumentFromRootContainer(
            rootInstanceStackCursor.current
          );
          switch (current) {
            case 1:
              current = type.createElementNS(
                "http://www.w3.org/2000/svg",
                renderLanes2
              );
              break;
            case 2:
              current = type.createElementNS(
                "http://www.w3.org/1998/Math/MathML",
                renderLanes2
              );
              break;
            default:
              switch (renderLanes2) {
                case "svg":
                  current = type.createElementNS(
                    "http://www.w3.org/2000/svg",
                    renderLanes2
                  );
                  break;
                case "math":
                  current = type.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    renderLanes2
                  );
                  break;
                case "script":
                  current = type.createElement("div");
                  current.innerHTML = "<script><\/script>";
                  current = current.removeChild(current.firstChild);
                  break;
                case "select":
                  current = "string" === typeof newProps.is ? type.createElement("select", { is: newProps.is }) : type.createElement("select");
                  newProps.multiple ? current.multiple = true : newProps.size && (current.size = newProps.size);
                  break;
                default:
                  current = "string" === typeof newProps.is ? type.createElement(renderLanes2, { is: newProps.is }) : type.createElement(renderLanes2);
              }
          }
          current[internalInstanceKey] = workInProgress2;
          current[internalPropsKey] = newProps;
          a: for (type = workInProgress2.child; null !== type; ) {
            if (5 === type.tag || 6 === type.tag)
              current.appendChild(type.stateNode);
            else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
              type.child.return = type;
              type = type.child;
              continue;
            }
            if (type === workInProgress2) break a;
            for (; null === type.sibling; ) {
              if (null === type.return || type.return === workInProgress2)
                break a;
              type = type.return;
            }
            type.sibling.return = type.return;
            type = type.sibling;
          }
          workInProgress2.stateNode = current;
          a: switch (setInitialProperties(current, renderLanes2, newProps), renderLanes2) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              current = !!newProps.autoFocus;
              break a;
            case "img":
              current = true;
              break a;
            default:
              current = false;
          }
          current && markUpdate(workInProgress2);
        }
      }
      bubbleProperties(workInProgress2);
      workInProgress2.flags &= -16777217;
      return null;
    case 6:
      if (current && null != workInProgress2.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress2);
      else {
        if ("string" !== typeof newProps && null === workInProgress2.stateNode)
          throw Error(formatProdErrorMessage(166));
        current = rootInstanceStackCursor.current;
        if (popHydrationState(workInProgress2)) {
          current = workInProgress2.stateNode;
          renderLanes2 = workInProgress2.memoizedProps;
          newProps = null;
          type = hydrationParentFiber;
          if (null !== type)
            switch (type.tag) {
              case 27:
              case 5:
                newProps = type.memoizedProps;
            }
          current[internalInstanceKey] = workInProgress2;
          current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
          current || throwOnHydrationMismatch(workInProgress2);
        } else
          current = getOwnerDocumentFromRootContainer(current).createTextNode(
            newProps
          ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
      }
      bubbleProperties(workInProgress2);
      return null;
    case 13:
      newProps = workInProgress2.memoizedState;
      if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
        type = popHydrationState(workInProgress2);
        if (null !== newProps && null !== newProps.dehydrated) {
          if (null === current) {
            if (!type) throw Error(formatProdErrorMessage(318));
            type = workInProgress2.memoizedState;
            type = null !== type ? type.dehydrated : null;
            if (!type) throw Error(formatProdErrorMessage(317));
            type[internalInstanceKey] = workInProgress2;
          } else
            resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
          bubbleProperties(workInProgress2);
          type = false;
        } else
          type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
        if (!type) {
          if (workInProgress2.flags & 256)
            return popSuspenseHandler(workInProgress2), workInProgress2;
          popSuspenseHandler(workInProgress2);
          return null;
        }
      }
      popSuspenseHandler(workInProgress2);
      if (0 !== (workInProgress2.flags & 128))
        return workInProgress2.lanes = renderLanes2, workInProgress2;
      renderLanes2 = null !== newProps;
      current = null !== current && null !== current.memoizedState;
      if (renderLanes2) {
        newProps = workInProgress2.child;
        type = null;
        null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool);
        var cache$127 = null;
        null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (cache$127 = newProps.memoizedState.cachePool.pool);
        cache$127 !== type && (newProps.flags |= 2048);
      }
      renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
      scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
      bubbleProperties(workInProgress2);
      return null;
    case 4:
      return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
    case 10:
      return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
    case 19:
      pop(suspenseStackCursor);
      type = workInProgress2.memoizedState;
      if (null === type) return bubbleProperties(workInProgress2), null;
      newProps = 0 !== (workInProgress2.flags & 128);
      cache$127 = type.rendering;
      if (null === cache$127)
        if (newProps) cutOffTailIfNeeded(type, false);
        else {
          if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
            for (current = workInProgress2.child; null !== current; ) {
              cache$127 = findFirstSuspended(current);
              if (null !== cache$127) {
                workInProgress2.flags |= 128;
                cutOffTailIfNeeded(type, false);
                current = cache$127.updateQueue;
                workInProgress2.updateQueue = current;
                scheduleRetryEffect(workInProgress2, current);
                workInProgress2.subtreeFlags = 0;
                current = renderLanes2;
                for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                  resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                push(
                  suspenseStackCursor,
                  suspenseStackCursor.current & 1 | 2
                );
                return workInProgress2.child;
              }
              current = current.sibling;
            }
          null !== type.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
        }
      else {
        if (!newProps)
          if (current = findFirstSuspended(cache$127), null !== current) {
            if (workInProgress2.flags |= 128, newProps = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(type, true), null === type.tail && "hidden" === type.tailMode && !cache$127.alternate && !isHydrating)
              return bubbleProperties(workInProgress2), null;
          } else
            2 * now() - type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
        type.isBackwards ? (cache$127.sibling = workInProgress2.child, workInProgress2.child = cache$127) : (current = type.last, null !== current ? current.sibling = cache$127 : workInProgress2.child = cache$127, type.last = cache$127);
      }
      if (null !== type.tail)
        return workInProgress2 = type.tail, type.rendering = workInProgress2, type.tail = workInProgress2.sibling, type.renderingStartTime = now(), workInProgress2.sibling = null, current = suspenseStackCursor.current, push(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress2;
      bubbleProperties(workInProgress2);
      return null;
    case 22:
    case 23:
      return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
    case 24:
      return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
    case 25:
      return null;
    case 30:
      return null;
  }
  throw Error(formatProdErrorMessage(156, workInProgress2.tag));
}
function unwindWork(current, workInProgress2) {
  popTreeContext(workInProgress2);
  switch (workInProgress2.tag) {
    case 1:
      return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
    case 3:
      return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
    case 26:
    case 27:
    case 5:
      return popHostContext(workInProgress2), null;
    case 13:
      popSuspenseHandler(workInProgress2);
      current = workInProgress2.memoizedState;
      if (null !== current && null !== current.dehydrated) {
        if (null === workInProgress2.alternate)
          throw Error(formatProdErrorMessage(340));
        resetHydrationState();
      }
      current = workInProgress2.flags;
      return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
    case 19:
      return pop(suspenseStackCursor), null;
    case 4:
      return popHostContainer(), null;
    case 10:
      return popProvider(workInProgress2.type), null;
    case 22:
    case 23:
      return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
    case 24:
      return popProvider(CacheContext), null;
    case 25:
      return null;
    default:
      return null;
  }
}
function unwindInterruptedWork(current, interruptedWork) {
  popTreeContext(interruptedWork);
  switch (interruptedWork.tag) {
    case 3:
      popProvider(CacheContext);
      popHostContainer();
      break;
    case 26:
    case 27:
    case 5:
      popHostContext(interruptedWork);
      break;
    case 4:
      popHostContainer();
      break;
    case 13:
      popSuspenseHandler(interruptedWork);
      break;
    case 19:
      pop(suspenseStackCursor);
      break;
    case 10:
      popProvider(interruptedWork.type);
      break;
    case 22:
    case 23:
      popSuspenseHandler(interruptedWork);
      popHiddenContext();
      null !== current && pop(resumedCache);
      break;
    case 24:
      popProvider(CacheContext);
  }
}
function commitHookEffectListMount(flags, finishedWork) {
  try {
    var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
    if (null !== lastEffect) {
      var firstEffect = lastEffect.next;
      updateQueue = firstEffect;
      do {
        if ((updateQueue.tag & flags) === flags) {
          lastEffect = void 0;
          var create = updateQueue.create, inst = updateQueue.inst;
          lastEffect = create();
          inst.destroy = lastEffect;
        }
        updateQueue = updateQueue.next;
      } while (updateQueue !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
  try {
    var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
    if (null !== lastEffect) {
      var firstEffect = lastEffect.next;
      updateQueue = firstEffect;
      do {
        if ((updateQueue.tag & flags) === flags) {
          var inst = updateQueue.inst, destroy = inst.destroy;
          if (void 0 !== destroy) {
            inst.destroy = void 0;
            lastEffect = finishedWork;
            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
            try {
              destroy_();
            } catch (error) {
              captureCommitPhaseError(
                lastEffect,
                nearestMountedAncestor,
                error
              );
            }
          }
        }
        updateQueue = updateQueue.next;
      } while (updateQueue !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitClassCallbacks(finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  if (null !== updateQueue) {
    var instance = finishedWork.stateNode;
    try {
      commitCallbacks(updateQueue, instance);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
}
function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
  instance.props = resolveClassComponentProps(
    current.type,
    current.memoizedProps
  );
  instance.state = current.memoizedState;
  try {
    instance.componentWillUnmount();
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
function safelyAttachRef(current, nearestMountedAncestor) {
  try {
    var ref = current.ref;
    if (null !== ref) {
      switch (current.tag) {
        case 26:
        case 27:
        case 5:
          var instanceToUse = current.stateNode;
          break;
        case 30:
          instanceToUse = current.stateNode;
          break;
        default:
          instanceToUse = current.stateNode;
      }
      "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
    }
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
function safelyDetachRef(current, nearestMountedAncestor) {
  var ref = current.ref, refCleanup = current.refCleanup;
  if (null !== ref)
    if ("function" === typeof refCleanup)
      try {
        refCleanup();
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      } finally {
        current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
      }
    else if ("function" === typeof ref)
      try {
        ref(null);
      } catch (error$143) {
        captureCommitPhaseError(current, nearestMountedAncestor, error$143);
      }
    else ref.current = null;
}
function commitHostMount(finishedWork) {
  var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
  try {
    a: switch (type) {
      case "button":
      case "input":
      case "select":
      case "textarea":
        props.autoFocus && instance.focus();
        break a;
      case "img":
        props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostUpdate(finishedWork, newProps, oldProps) {
  try {
    var domElement = finishedWork.stateNode;
    updateProperties(domElement, finishedWork.type, oldProps, newProps);
    domElement[internalPropsKey] = newProps;
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function isHostParent(fiber) {
  return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
}
function getHostSibling(fiber) {
  a: for (; ; ) {
    for (; null === fiber.sibling; ) {
      if (null === fiber.return || isHostParent(fiber.return)) return null;
      fiber = fiber.return;
    }
    fiber.sibling.return = fiber.return;
    for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
      if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
      if (fiber.flags & 2) continue a;
      if (null === fiber.child || 4 === fiber.tag) continue a;
      else fiber.child.return = fiber, fiber = fiber.child;
    }
    if (!(fiber.flags & 2)) return fiber.stateNode;
  }
}
function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
  var tag = node.tag;
  if (5 === tag || 6 === tag)
    node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
  else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
    for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
      insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
}
function insertOrAppendPlacementNode(node, before, parent) {
  var tag = node.tag;
  if (5 === tag || 6 === tag)
    node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
  else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
    for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
}
function commitHostSingletonAcquisition(finishedWork) {
  var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
  try {
    for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
      singleton.removeAttributeNode(attributes[0]);
    setInitialProperties(singleton, type, props);
    singleton[internalInstanceKey] = finishedWork;
    singleton[internalPropsKey] = props;
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null;
function commitBeforeMutationEffects(root2, firstChild) {
  root2 = root2.containerInfo;
  eventsEnabled = _enabled;
  root2 = getActiveElementDeep(root2);
  if (hasSelectionCapabilities(root2)) {
    if ("selectionStart" in root2)
      var JSCompiler_temp = {
        start: root2.selectionStart,
        end: root2.selectionEnd
      };
    else
      a: {
        JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
        var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
        if (selection && 0 !== selection.rangeCount) {
          JSCompiler_temp = selection.anchorNode;
          var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
          selection = selection.focusOffset;
          try {
            JSCompiler_temp.nodeType, focusNode.nodeType;
          } catch (e$20) {
            JSCompiler_temp = null;
            break a;
          }
          var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
          b: for (; ; ) {
            for (var next; ; ) {
              node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
              node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
              3 === node.nodeType && (length += node.nodeValue.length);
              if (null === (next = node.firstChild)) break;
              parentNode = node;
              node = next;
            }
            for (; ; ) {
              if (node === root2) break b;
              parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
              parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
              if (null !== (next = node.nextSibling)) break;
              node = parentNode;
              parentNode = node.parentNode;
            }
            node = next;
          }
          JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
        } else JSCompiler_temp = null;
      }
    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
  } else JSCompiler_temp = null;
  selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
  _enabled = false;
  for (nextEffect = firstChild; null !== nextEffect; )
    if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root2)
      root2.return = firstChild, nextEffect = root2;
    else
      for (; null !== nextEffect; ) {
        firstChild = nextEffect;
        focusNode = firstChild.alternate;
        root2 = firstChild.flags;
        switch (firstChild.tag) {
          case 0:
            break;
          case 11:
          case 15:
            break;
          case 1:
            if (0 !== (root2 & 1024) && null !== focusNode) {
              root2 = void 0;
              JSCompiler_temp = firstChild;
              anchorOffset = focusNode.memoizedProps;
              focusNode = focusNode.memoizedState;
              selection = JSCompiler_temp.stateNode;
              try {
                var resolvedPrevProps = resolveClassComponentProps(
                  JSCompiler_temp.type,
                  anchorOffset,
                  JSCompiler_temp.elementType === JSCompiler_temp.type
                );
                root2 = selection.getSnapshotBeforeUpdate(
                  resolvedPrevProps,
                  focusNode
                );
                selection.__reactInternalSnapshotBeforeUpdate = root2;
              } catch (error) {
                captureCommitPhaseError(
                  JSCompiler_temp,
                  JSCompiler_temp.return,
                  error
                );
              }
            }
            break;
          case 3:
            if (0 !== (root2 & 1024)) {
              if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                clearContainerSparingly(root2);
              else if (1 === JSCompiler_temp)
                switch (root2.nodeName) {
                  case "HEAD":
                  case "HTML":
                  case "BODY":
                    clearContainerSparingly(root2);
                    break;
                  default:
                    root2.textContent = "";
                }
            }
            break;
          case 5:
          case 26:
          case 27:
          case 6:
          case 4:
          case 17:
            break;
          default:
            if (0 !== (root2 & 1024)) throw Error(formatProdErrorMessage(163));
        }
        root2 = firstChild.sibling;
        if (null !== root2) {
          root2.return = firstChild.return;
          nextEffect = root2;
          break;
        }
        nextEffect = firstChild.return;
      }
}
function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
  var flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitHookEffectListMount(5, finishedWork);
      break;
    case 1:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags & 4)
        if (finishedRoot = finishedWork.stateNode, null === current)
          try {
            finishedRoot.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        else {
          var prevProps = resolveClassComponentProps(
            finishedWork.type,
            current.memoizedProps
          );
          current = current.memoizedState;
          try {
            finishedRoot.componentDidUpdate(
              prevProps,
              current,
              finishedRoot.__reactInternalSnapshotBeforeUpdate
            );
          } catch (error$142) {
            captureCommitPhaseError(
              finishedWork,
              finishedWork.return,
              error$142
            );
          }
        }
      flags & 64 && commitClassCallbacks(finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 3:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
        current = null;
        if (null !== finishedWork.child)
          switch (finishedWork.child.tag) {
            case 27:
            case 5:
              current = finishedWork.child.stateNode;
              break;
            case 1:
              current = finishedWork.child.stateNode;
          }
        try {
          commitCallbacks(finishedRoot, current);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      break;
    case 27:
      null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
    case 26:
    case 5:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      null === current && flags & 4 && commitHostMount(finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 12:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      break;
    case 13:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
      flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
        null,
        finishedWork
      ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
      break;
    case 22:
      flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
      if (!flags) {
        current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
        prevProps = offscreenSubtreeIsHidden;
        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = flags;
        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          0 !== (finishedWork.subtreeFlags & 8772)
        ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        offscreenSubtreeIsHidden = prevProps;
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
      }
      break;
    case 30:
      break;
    default:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
  }
}
function detachFiberAfterEffects(fiber) {
  var alternate = fiber.alternate;
  null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
  fiber.child = null;
  fiber.deletions = null;
  fiber.sibling = null;
  5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
  fiber.stateNode = null;
  fiber.return = null;
  fiber.dependencies = null;
  fiber.memoizedProps = null;
  fiber.memoizedState = null;
  fiber.pendingProps = null;
  fiber.stateNode = null;
  fiber.updateQueue = null;
}
var hostParent = null, hostParentIsContainer = false;
function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
  for (parent = parent.child; null !== parent; )
    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
}
function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
    try {
      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
    } catch (err) {
    }
  switch (deletedFiber.tag) {
    case 26:
      offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
      break;
    case 27:
      offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
      var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
      isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      releaseSingletonInstance(deletedFiber.stateNode);
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      break;
    case 5:
      offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
    case 6:
      prevHostParent = hostParent;
      prevHostParentIsContainer = hostParentIsContainer;
      hostParent = null;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      if (null !== hostParent)
        if (hostParentIsContainer)
          try {
            (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
          } catch (error) {
            captureCommitPhaseError(
              deletedFiber,
              nearestMountedAncestor,
              error
            );
          }
        else
          try {
            hostParent.removeChild(deletedFiber.stateNode);
          } catch (error) {
            captureCommitPhaseError(
              deletedFiber,
              nearestMountedAncestor,
              error
            );
          }
      break;
    case 18:
      null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(
        9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
        deletedFiber.stateNode
      ), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
      break;
    case 4:
      prevHostParent = hostParent;
      prevHostParentIsContainer = hostParentIsContainer;
      hostParent = deletedFiber.stateNode.containerInfo;
      hostParentIsContainer = true;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
      offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 1:
      offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
        deletedFiber,
        nearestMountedAncestor,
        prevHostParent
      ));
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 21:
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 22:
      offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      offscreenSubtreeWasHidden = prevHostParent;
      break;
    default:
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
  }
}
function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
  if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
    try {
      retryIfBlockedOn(finishedRoot);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
}
function getRetryCache(finishedWork) {
  switch (finishedWork.tag) {
    case 13:
    case 19:
      var retryCache = finishedWork.stateNode;
      null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
      return retryCache;
    case 22:
      return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
    default:
      throw Error(formatProdErrorMessage(435, finishedWork.tag));
  }
}
function attachSuspenseRetryListeners(finishedWork, wakeables) {
  var retryCache = getRetryCache(finishedWork);
  wakeables.forEach(function(wakeable) {
    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
    retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
  });
}
function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
  var deletions = parentFiber.deletions;
  if (null !== deletions)
    for (var i = 0; i < deletions.length; i++) {
      var childToDelete = deletions[i], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
      a: for (; null !== parent; ) {
        switch (parent.tag) {
          case 27:
            if (isSingletonScope(parent.type)) {
              hostParent = parent.stateNode;
              hostParentIsContainer = false;
              break a;
            }
            break;
          case 5:
            hostParent = parent.stateNode;
            hostParentIsContainer = false;
            break a;
          case 3:
          case 4:
            hostParent = parent.stateNode.containerInfo;
            hostParentIsContainer = true;
            break a;
        }
        parent = parent.return;
      }
      if (null === hostParent) throw Error(formatProdErrorMessage(160));
      commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
      hostParent = null;
      hostParentIsContainer = false;
      root2 = childToDelete.alternate;
      null !== root2 && (root2.return = null);
      childToDelete.return = null;
    }
  if (parentFiber.subtreeFlags & 13878)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
}
var currentHoistableRoot = null;
function commitMutationEffectsOnFiber(finishedWork, root2) {
  var current = finishedWork.alternate, flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
      break;
    case 1:
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
      flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
      break;
    case 26:
      var hoistableRoot = currentHoistableRoot;
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
      if (flags & 4) {
        var currentResource = null !== current ? current.memoizedState : null;
        flags = finishedWork.memoizedState;
        if (null === current)
          if (null === flags)
            if (null === finishedWork.stateNode) {
              a: {
                flags = finishedWork.type;
                current = finishedWork.memoizedProps;
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                b: switch (flags) {
                  case "title":
                    currentResource = hoistableRoot.getElementsByTagName("title")[0];
                    if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                      currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                        currentResource,
                        hoistableRoot.querySelector("head > title")
                      );
                    setInitialProperties(currentResource, flags, current);
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                    break a;
                  case "link":
                    var maybeNodes = getHydratableHoistableCache(
                      "link",
                      "href",
                      hoistableRoot
                    ).get(flags + (current.href || ""));
                    if (maybeNodes) {
                      for (var i = 0; i < maybeNodes.length; i++)
                        if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                          maybeNodes.splice(i, 1);
                          break b;
                        }
                    }
                    currentResource = hoistableRoot.createElement(flags);
                    setInitialProperties(currentResource, flags, current);
                    hoistableRoot.head.appendChild(currentResource);
                    break;
                  case "meta":
                    if (maybeNodes = getHydratableHoistableCache(
                      "meta",
                      "content",
                      hoistableRoot
                    ).get(flags + (current.content || ""))) {
                      for (i = 0; i < maybeNodes.length; i++)
                        if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                          maybeNodes.splice(i, 1);
                          break b;
                        }
                    }
                    currentResource = hoistableRoot.createElement(flags);
                    setInitialProperties(currentResource, flags, current);
                    hoistableRoot.head.appendChild(currentResource);
                    break;
                  default:
                    throw Error(formatProdErrorMessage(468, flags));
                }
                currentResource[internalInstanceKey] = finishedWork;
                markNodeAsHoistable(currentResource);
                flags = currentResource;
              }
              finishedWork.stateNode = flags;
            } else
              mountHoistable(
                hoistableRoot,
                finishedWork.type,
                finishedWork.stateNode
              );
          else
            finishedWork.stateNode = acquireResource(
              hoistableRoot,
              flags,
              finishedWork.memoizedProps
            );
        else
          currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
            hoistableRoot,
            finishedWork.type,
            finishedWork.stateNode
          ) : acquireResource(
            hoistableRoot,
            flags,
            finishedWork.memoizedProps
          )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
            finishedWork,
            finishedWork.memoizedProps,
            current.memoizedProps
          );
      }
      break;
    case 27:
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
      null !== current && flags & 4 && commitHostUpdate(
        finishedWork,
        finishedWork.memoizedProps,
        current.memoizedProps
      );
      break;
    case 5:
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
      if (finishedWork.flags & 32) {
        hoistableRoot = finishedWork.stateNode;
        try {
          setTextContent(hoistableRoot, "");
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
        finishedWork,
        hoistableRoot,
        null !== current ? current.memoizedProps : hoistableRoot
      ));
      flags & 1024 && (needsFormReset = true);
      break;
    case 6:
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags & 4) {
        if (null === finishedWork.stateNode)
          throw Error(formatProdErrorMessage(162));
        flags = finishedWork.memoizedProps;
        current = finishedWork.stateNode;
        try {
          current.nodeValue = flags;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      break;
    case 3:
      tagCaches = null;
      hoistableRoot = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(root2.containerInfo);
      recursivelyTraverseMutationEffects(root2, finishedWork);
      currentHoistableRoot = hoistableRoot;
      commitReconciliationEffects(finishedWork);
      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
        try {
          retryIfBlockedOn(root2.containerInfo);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
      break;
    case 4:
      flags = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(
        finishedWork.stateNode.containerInfo
      );
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      currentHoistableRoot = flags;
      break;
    case 12:
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    case 13:
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
      flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 22:
      hoistableRoot = null !== finishedWork.memoizedState;
      var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
      recursivelyTraverseMutationEffects(root2, finishedWork);
      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
      commitReconciliationEffects(finishedWork);
      if (flags & 8192)
        a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & -2 : root2._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root2 = finishedWork; ; ) {
          if (5 === root2.tag || 26 === root2.tag) {
            if (null === current) {
              wasHidden = current = root2;
              try {
                if (currentResource = wasHidden.stateNode, hoistableRoot)
                  maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                else {
                  i = wasHidden.stateNode;
                  var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                  i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                }
              } catch (error) {
                captureCommitPhaseError(wasHidden, wasHidden.return, error);
              }
            }
          } else if (6 === root2.tag) {
            if (null === current) {
              wasHidden = root2;
              try {
                wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
              } catch (error) {
                captureCommitPhaseError(wasHidden, wasHidden.return, error);
              }
            }
          } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
            root2.child.return = root2;
            root2 = root2.child;
            continue;
          }
          if (root2 === finishedWork) break a;
          for (; null === root2.sibling; ) {
            if (null === root2.return || root2.return === finishedWork) break a;
            current === root2 && (current = null);
            root2 = root2.return;
          }
          current === root2 && (current = null);
          root2.sibling.return = root2.return;
          root2 = root2.sibling;
        }
      flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
      break;
    case 19:
      recursivelyTraverseMutationEffects(root2, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 30:
      break;
    case 21:
      break;
    default:
      recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
  }
}
function commitReconciliationEffects(finishedWork) {
  var flags = finishedWork.flags;
  if (flags & 2) {
    try {
      for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
        if (isHostParent(parentFiber)) {
          hostParentFiber = parentFiber;
          break;
        }
        parentFiber = parentFiber.return;
      }
      if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
      switch (hostParentFiber.tag) {
        case 27:
          var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, before, parent);
          break;
        case 5:
          var parent$144 = hostParentFiber.stateNode;
          hostParentFiber.flags & 32 && (setTextContent(parent$144, ""), hostParentFiber.flags &= -33);
          var before$145 = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, before$145, parent$144);
          break;
        case 3:
        case 4:
          var parent$146 = hostParentFiber.stateNode.containerInfo, before$147 = getHostSibling(finishedWork);
          insertOrAppendPlacementNodeIntoContainer(
            finishedWork,
            before$147,
            parent$146
          );
          break;
        default:
          throw Error(formatProdErrorMessage(161));
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
    finishedWork.flags &= -3;
  }
  flags & 4096 && (finishedWork.flags &= -4097);
}
function recursivelyResetForms(parentFiber) {
  if (parentFiber.subtreeFlags & 1024)
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var fiber = parentFiber;
      recursivelyResetForms(fiber);
      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
      parentFiber = parentFiber.sibling;
    }
}
function recursivelyTraverseLayoutEffects(root2, parentFiber) {
  if (parentFiber.subtreeFlags & 8772)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
}
function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var finishedWork = parentFiber;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 1:
        safelyDetachRef(finishedWork, finishedWork.return);
        var instance = finishedWork.stateNode;
        "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
          finishedWork,
          finishedWork.return,
          instance
        );
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 27:
        releaseSingletonInstance(finishedWork.stateNode);
      case 26:
      case 5:
        safelyDetachRef(finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 22:
        null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 30:
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      default:
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
    }
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
  includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        commitHookEffectListMount(4, finishedWork);
        break;
      case 1:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        current = finishedWork;
        finishedRoot = current.stateNode;
        if ("function" === typeof finishedRoot.componentDidMount)
          try {
            finishedRoot.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(current, current.return, error);
          }
        current = finishedWork;
        finishedRoot = current.updateQueue;
        if (null !== finishedRoot) {
          var instance = current.stateNode;
          try {
            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
            if (null !== hiddenCallbacks)
              for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                callCallback(hiddenCallbacks[finishedRoot], instance);
          } catch (error) {
            captureCommitPhaseError(current, current.return, error);
          }
        }
        includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 27:
        commitHostSingletonAcquisition(finishedWork);
      case 26:
      case 5:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 12:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        break;
      case 13:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        break;
      case 22:
        null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 30:
        break;
      default:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
    }
    parentFiber = parentFiber.sibling;
  }
}
function commitOffscreenPassiveMountEffects(current, finishedWork) {
  var previousCache = null;
  null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
  current = null;
  null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
  current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
}
function commitCachePassiveMountEffect(current, finishedWork) {
  current = null;
  null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
  finishedWork = finishedWork.memoizedState.cache;
  finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
}
function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitPassiveMountOnFiber(
        root2,
        parentFiber,
        committedLanes,
        committedTransitions
      ), parentFiber = parentFiber.sibling;
}
function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
  var flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 && commitHookEffectListMount(9, finishedWork);
      break;
    case 1:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      break;
    case 3:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
      break;
    case 12:
      if (flags & 2048) {
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        finishedRoot = finishedWork.stateNode;
        try {
          var _finishedWork$memoize2 = finishedWork.memoizedProps, id2 = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
          "function" === typeof onPostCommit && onPostCommit(
            id2,
            null === finishedWork.alternate ? "mount" : "update",
            finishedRoot.passiveEffectDuration,
            -0
          );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      } else
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
      break;
    case 13:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      break;
    case 23:
      break;
    case 22:
      _finishedWork$memoize2 = finishedWork.stateNode;
      id2 = finishedWork.alternate;
      null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions,
        0 !== (finishedWork.subtreeFlags & 10256)
      ));
      flags & 2048 && commitOffscreenPassiveMountEffects(id2, finishedWork);
      break;
    case 24:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
      break;
    default:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
  }
}
function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
  includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
        commitHookEffectListMount(8, finishedWork);
        break;
      case 23:
        break;
      case 22:
        var instance = finishedWork.stateNode;
        null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        ) : recursivelyTraverseAtomicPassiveEffects(
          finishedRoot,
          finishedWork
        ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        ));
        includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
          finishedWork.alternate,
          finishedWork
        );
        break;
      case 24:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
        break;
      default:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
    }
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 22:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 && commitOffscreenPassiveMountEffects(
            finishedWork.alternate,
            finishedWork
          );
          break;
        case 24:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
      }
      parentFiber = parentFiber.sibling;
    }
}
var suspenseyCommitFlag = 8192;
function recursivelyAccumulateSuspenseyCommit(parentFiber) {
  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
}
function accumulateSuspenseyCommitOnFiber(fiber) {
  switch (fiber.tag) {
    case 26:
      recursivelyAccumulateSuspenseyCommit(fiber);
      fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
        currentHoistableRoot,
        fiber.memoizedState,
        fiber.memoizedProps
      );
      break;
    case 5:
      recursivelyAccumulateSuspenseyCommit(fiber);
      break;
    case 3:
    case 4:
      var previousHoistableRoot = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
      recursivelyAccumulateSuspenseyCommit(fiber);
      currentHoistableRoot = previousHoistableRoot;
      break;
    case 22:
      null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
      break;
    default:
      recursivelyAccumulateSuspenseyCommit(fiber);
  }
}
function detachAlternateSiblings(parentFiber) {
  var previousFiber = parentFiber.alternate;
  if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
    previousFiber.child = null;
    do
      previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
    while (null !== parentFiber);
  }
}
function recursivelyTraversePassiveUnmountEffects(parentFiber) {
  var deletions = parentFiber.deletions;
  if (0 !== (parentFiber.flags & 16)) {
    if (null !== deletions)
      for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
          childToDelete,
          parentFiber
        );
      }
    detachAlternateSiblings(parentFiber);
  }
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
}
function commitPassiveUnmountOnFiber(finishedWork) {
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
      break;
    case 3:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    case 12:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    case 22:
      var instance = finishedWork.stateNode;
      null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    default:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
  }
}
function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
  var deletions = parentFiber.deletions;
  if (0 !== (parentFiber.flags & 16)) {
    if (null !== deletions)
      for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
          childToDelete,
          parentFiber
        );
      }
    detachAlternateSiblings(parentFiber);
  }
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    deletions = parentFiber;
    switch (deletions.tag) {
      case 0:
      case 11:
      case 15:
        commitHookEffectListUnmount(8, deletions, deletions.return);
        recursivelyTraverseDisconnectPassiveEffects(deletions);
        break;
      case 22:
        i = deletions.stateNode;
        i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
        break;
      default:
        recursivelyTraverseDisconnectPassiveEffects(deletions);
    }
    parentFiber = parentFiber.sibling;
  }
}
function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
  for (; null !== nextEffect; ) {
    var fiber = nextEffect;
    switch (fiber.tag) {
      case 0:
      case 11:
      case 15:
        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
        break;
      case 23:
      case 22:
        if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
          var cache = fiber.memoizedState.cachePool.pool;
          null != cache && cache.refCount++;
        }
        break;
      case 24:
        releaseCache(fiber.memoizedState.cache);
    }
    cache = fiber.child;
    if (null !== cache) cache.return = fiber, nextEffect = cache;
    else
      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
        cache = nextEffect;
        var sibling = cache.sibling, returnFiber = cache.return;
        detachFiberAfterEffects(cache);
        if (cache === fiber) {
          nextEffect = null;
          break a;
        }
        if (null !== sibling) {
          sibling.return = returnFiber;
          nextEffect = sibling;
          break a;
        }
        nextEffect = returnFiber;
      }
  }
}
var DefaultAsyncDispatcher = {
  getCacheForType: function(resourceType) {
    var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
    void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
    return cacheForType;
  }
}, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
function requestUpdateLane() {
  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
  if (null !== ReactSharedInternals.T) {
    var actionScopeLane = currentEntangledLane;
    return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
  }
  return resolveUpdatePriority();
}
function requestDeferredLane() {
  0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
  var suspenseHandler = suspenseHandlerStackCursor.current;
  null !== suspenseHandler && (suspenseHandler.flags |= 32);
  return workInProgressDeferredLane;
}
function scheduleUpdateOnFiber(root2, fiber, lane) {
  if (root2 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
    prepareFreshStack(root2, 0), markRootSuspended(
      root2,
      workInProgressRootRenderLanes,
      workInProgressDeferredLane,
      false
    );
  markRootUpdated$1(root2, lane);
  if (0 === (executionContext & 2) || root2 !== workInProgressRoot)
    root2 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
      root2,
      workInProgressRootRenderLanes,
      workInProgressDeferredLane,
      false
    )), ensureRootIsScheduled(root2);
}
function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
  var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
  do {
    if (0 === exitStatus) {
      workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
      break;
    } else {
      forceSync = root$jscomp$0.current.alternate;
      if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
        exitStatus = renderRootSync(root$jscomp$0, lanes, false);
        renderWasConcurrent = false;
        continue;
      }
      if (2 === exitStatus) {
        renderWasConcurrent = lanes;
        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
          var JSCompiler_inline_result = 0;
        else
          JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
        if (0 !== JSCompiler_inline_result) {
          lanes = JSCompiler_inline_result;
          a: {
            var root2 = root$jscomp$0;
            exitStatus = workInProgressRootConcurrentErrors;
            var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
            wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
            JSCompiler_inline_result = renderRootSync(
              root2,
              JSCompiler_inline_result,
              false
            );
            if (2 !== JSCompiler_inline_result) {
              if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
                workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                exitStatus = 4;
                break a;
              }
              renderWasConcurrent = workInProgressRootRecoverableErrors;
              workInProgressRootRecoverableErrors = exitStatus;
              null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                workInProgressRootRecoverableErrors,
                renderWasConcurrent
              ));
            }
            exitStatus = JSCompiler_inline_result;
          }
          renderWasConcurrent = false;
          if (2 !== exitStatus) continue;
        }
      }
      if (1 === exitStatus) {
        prepareFreshStack(root$jscomp$0, 0);
        markRootSuspended(root$jscomp$0, lanes, 0, true);
        break;
      }
      a: {
        shouldTimeSlice = root$jscomp$0;
        renderWasConcurrent = exitStatus;
        switch (renderWasConcurrent) {
          case 0:
          case 1:
            throw Error(formatProdErrorMessage(345));
          case 4:
            if ((lanes & 4194048) !== lanes) break;
          case 6:
            markRootSuspended(
              shouldTimeSlice,
              lanes,
              workInProgressDeferredLane,
              !workInProgressRootDidSkipSuspendedSiblings
            );
            break a;
          case 2:
            workInProgressRootRecoverableErrors = null;
            break;
          case 3:
          case 5:
            break;
          default:
            throw Error(formatProdErrorMessage(329));
        }
        if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
          markRootSuspended(
            shouldTimeSlice,
            lanes,
            workInProgressDeferredLane,
            !workInProgressRootDidSkipSuspendedSiblings
          );
          if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
          shouldTimeSlice.timeoutHandle = scheduleTimeout(
            commitRootWhenReady.bind(
              null,
              shouldTimeSlice,
              forceSync,
              workInProgressRootRecoverableErrors,
              workInProgressTransitions,
              workInProgressRootDidIncludeRecursiveRenderUpdate,
              lanes,
              workInProgressDeferredLane,
              workInProgressRootInterleavedUpdatedLanes,
              workInProgressSuspendedRetryLanes,
              workInProgressRootDidSkipSuspendedSiblings,
              renderWasConcurrent,
              2,
              -0,
              0
            ),
            exitStatus
          );
          break a;
        }
        commitRootWhenReady(
          shouldTimeSlice,
          forceSync,
          workInProgressRootRecoverableErrors,
          workInProgressTransitions,
          workInProgressRootDidIncludeRecursiveRenderUpdate,
          lanes,
          workInProgressDeferredLane,
          workInProgressRootInterleavedUpdatedLanes,
          workInProgressSuspendedRetryLanes,
          workInProgressRootDidSkipSuspendedSiblings,
          renderWasConcurrent,
          0,
          -0,
          0
        );
      }
    }
    break;
  } while (1);
  ensureRootIsScheduled(root$jscomp$0);
}
function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
  root2.timeoutHandle = -1;
  suspendedCommitReason = finishedWork.subtreeFlags;
  if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
    if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
      root2.cancelPendingCommit = suspendedCommitReason(
        commitRoot.bind(
          null,
          root2,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes,
          exitStatus,
          1,
          completedRenderStartTime,
          completedRenderEndTime
        )
      );
      markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
      return;
    }
  }
  commitRoot(
    root2,
    finishedWork,
    lanes,
    recoverableErrors,
    transitions,
    didIncludeRenderPhaseUpdate,
    spawnedLane,
    updatedLanes,
    suspendedRetryLanes
  );
}
function isRenderConsistentWithExternalStores(finishedWork) {
  for (var node = finishedWork; ; ) {
    var tag = node.tag;
    if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
      for (var i = 0; i < tag.length; i++) {
        var check = tag[i], getSnapshot = check.getSnapshot;
        check = check.value;
        try {
          if (!objectIs(getSnapshot(), check)) return false;
        } catch (error) {
          return false;
        }
      }
    tag = node.child;
    if (node.subtreeFlags & 16384 && null !== tag)
      tag.return = node, node = tag;
    else {
      if (node === finishedWork) break;
      for (; null === node.sibling; ) {
        if (null === node.return || node.return === finishedWork) return true;
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
  return true;
}
function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
  suspendedLanes &= ~workInProgressRootPingedLanes;
  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
  root2.suspendedLanes |= suspendedLanes;
  root2.pingedLanes &= ~suspendedLanes;
  didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
  didAttemptEntireTree = root2.expirationTimes;
  for (var lanes = suspendedLanes; 0 < lanes; ) {
    var index$4 = 31 - clz32(lanes), lane = 1 << index$4;
    didAttemptEntireTree[index$4] = -1;
    lanes &= ~lane;
  }
  0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
}
function flushSyncWork$1() {
  return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
}
function resetWorkInProgressStack() {
  if (null !== workInProgress) {
    if (0 === workInProgressSuspendedReason)
      var interruptedWork = workInProgress.return;
    else
      interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
    for (; null !== interruptedWork; )
      unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
    workInProgress = null;
  }
}
function prepareFreshStack(root2, lanes) {
  var timeoutHandle = root2.timeoutHandle;
  -1 !== timeoutHandle && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
  timeoutHandle = root2.cancelPendingCommit;
  null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
  resetWorkInProgressStack();
  workInProgressRoot = root2;
  workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
  workInProgressRootRenderLanes = lanes;
  workInProgressSuspendedReason = 0;
  workInProgressThrownValue = null;
  workInProgressRootDidSkipSuspendedSiblings = false;
  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
  workInProgressRootDidAttachPingListener = false;
  workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
  workInProgressRootDidIncludeRecursiveRenderUpdate = false;
  0 !== (lanes & 8) && (lanes |= lanes & 32);
  var allEntangledLanes = root2.entangledLanes;
  if (0 !== allEntangledLanes)
    for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
      var index$2 = 31 - clz32(allEntangledLanes), lane = 1 << index$2;
      lanes |= root2[index$2];
      allEntangledLanes &= ~lane;
    }
  entangledRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
  return timeoutHandle;
}
function handleThrow(root2, thrownValue) {
  currentlyRenderingFiber = null;
  ReactSharedInternals.H = ContextOnlyDispatcher;
  thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
  workInProgressThrownValue = thrownValue;
  null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
    root2,
    createCapturedValueAtFiber(thrownValue, root2.current)
  ));
}
function pushDispatcher() {
  var prevDispatcher = ReactSharedInternals.H;
  ReactSharedInternals.H = ContextOnlyDispatcher;
  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
}
function pushAsyncDispatcher() {
  var prevAsyncDispatcher = ReactSharedInternals.A;
  ReactSharedInternals.A = DefaultAsyncDispatcher;
  return prevAsyncDispatcher;
}
function renderDidSuspendDelayIfPossible() {
  workInProgressRootExitStatus = 4;
  workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
  0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
    workInProgressRoot,
    workInProgressRootRenderLanes,
    workInProgressDeferredLane,
    false
  );
}
function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
  var prevExecutionContext = executionContext;
  executionContext |= 2;
  var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
  if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
    workInProgressTransitions = null, prepareFreshStack(root2, lanes);
  lanes = false;
  var exitStatus = workInProgressRootExitStatus;
  a: do
    try {
      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
        var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
        switch (workInProgressSuspendedReason) {
          case 8:
            resetWorkInProgressStack();
            exitStatus = 6;
            break a;
          case 3:
          case 2:
          case 9:
          case 6:
            null === suspenseHandlerStackCursor.current && (lanes = true);
            var reason = workInProgressSuspendedReason;
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
            if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
              exitStatus = 0;
              break a;
            }
            break;
          default:
            reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
        }
      }
      workLoopSync();
      exitStatus = workInProgressRootExitStatus;
      break;
    } catch (thrownValue$167) {
      handleThrow(root2, thrownValue$167);
    }
  while (1);
  lanes && root2.shellSuspendCounter++;
  lastContextDependency = currentlyRenderingFiber$1 = null;
  executionContext = prevExecutionContext;
  ReactSharedInternals.H = prevDispatcher;
  ReactSharedInternals.A = prevAsyncDispatcher;
  null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
  return exitStatus;
}
function workLoopSync() {
  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
}
function renderRootConcurrent(root2, lanes) {
  var prevExecutionContext = executionContext;
  executionContext |= 2;
  var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
  workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
    root2,
    lanes
  );
  a: do
    try {
      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
        lanes = workInProgress;
        var thrownValue = workInProgressThrownValue;
        b: switch (workInProgressSuspendedReason) {
          case 1:
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
            break;
          case 2:
          case 9:
            if (isThenableResolved(thrownValue)) {
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              replaySuspendedUnitOfWork(lanes);
              break;
            }
            lanes = function() {
              2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root2 || (workInProgressSuspendedReason = 7);
              ensureRootIsScheduled(root2);
            };
            thrownValue.then(lanes, lanes);
            break a;
          case 3:
            workInProgressSuspendedReason = 7;
            break a;
          case 4:
            workInProgressSuspendedReason = 5;
            break a;
          case 7:
            isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
            break;
          case 5:
            var resource = null;
            switch (workInProgress.tag) {
              case 26:
                resource = workInProgress.memoizedState;
              case 5:
              case 27:
                var hostFiber = workInProgress;
                if (resource ? preloadResource(resource) : 1) {
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  var sibling = hostFiber.sibling;
                  if (null !== sibling) workInProgress = sibling;
                  else {
                    var returnFiber = hostFiber.return;
                    null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                  }
                  break b;
                }
            }
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
            break;
          case 6:
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
            break;
          case 8:
            resetWorkInProgressStack();
            workInProgressRootExitStatus = 6;
            break a;
          default:
            throw Error(formatProdErrorMessage(462));
        }
      }
      workLoopConcurrentByScheduler();
      break;
    } catch (thrownValue$169) {
      handleThrow(root2, thrownValue$169);
    }
  while (1);
  lastContextDependency = currentlyRenderingFiber$1 = null;
  ReactSharedInternals.H = prevDispatcher;
  ReactSharedInternals.A = prevAsyncDispatcher;
  executionContext = prevExecutionContext;
  if (null !== workInProgress) return 0;
  workInProgressRoot = null;
  workInProgressRootRenderLanes = 0;
  finishQueueingConcurrentUpdates();
  return workInProgressRootExitStatus;
}
function workLoopConcurrentByScheduler() {
  for (; null !== workInProgress && !shouldYield(); )
    performUnitOfWork(workInProgress);
}
function performUnitOfWork(unitOfWork) {
  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
}
function replaySuspendedUnitOfWork(unitOfWork) {
  var next = unitOfWork;
  var current = next.alternate;
  switch (next.tag) {
    case 15:
    case 0:
      next = replayFunctionComponent(
        current,
        next,
        next.pendingProps,
        next.type,
        void 0,
        workInProgressRootRenderLanes
      );
      break;
    case 11:
      next = replayFunctionComponent(
        current,
        next,
        next.pendingProps,
        next.type.render,
        next.ref,
        workInProgressRootRenderLanes
      );
      break;
    case 5:
      resetHooksOnUnwind(next);
    default:
      unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
  }
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
}
function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
  lastContextDependency = currentlyRenderingFiber$1 = null;
  resetHooksOnUnwind(unitOfWork);
  thenableState = null;
  thenableIndexCounter = 0;
  var returnFiber = unitOfWork.return;
  try {
    if (throwException(
      root2,
      returnFiber,
      unitOfWork,
      thrownValue,
      workInProgressRootRenderLanes
    )) {
      workInProgressRootExitStatus = 1;
      logUncaughtError(
        root2,
        createCapturedValueAtFiber(thrownValue, root2.current)
      );
      workInProgress = null;
      return;
    }
  } catch (error) {
    if (null !== returnFiber) throw workInProgress = returnFiber, error;
    workInProgressRootExitStatus = 1;
    logUncaughtError(
      root2,
      createCapturedValueAtFiber(thrownValue, root2.current)
    );
    workInProgress = null;
    return;
  }
  if (unitOfWork.flags & 32768) {
    if (isHydrating || 1 === suspendedReason) root2 = true;
    else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
      root2 = false;
    else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
      suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
    unwindUnitOfWork(unitOfWork, root2);
  } else completeUnitOfWork(unitOfWork);
}
function completeUnitOfWork(unitOfWork) {
  var completedWork = unitOfWork;
  do {
    if (0 !== (completedWork.flags & 32768)) {
      unwindUnitOfWork(
        completedWork,
        workInProgressRootDidSkipSuspendedSiblings
      );
      return;
    }
    unitOfWork = completedWork.return;
    var next = completeWork(
      completedWork.alternate,
      completedWork,
      entangledRenderLanes
    );
    if (null !== next) {
      workInProgress = next;
      return;
    }
    completedWork = completedWork.sibling;
    if (null !== completedWork) {
      workInProgress = completedWork;
      return;
    }
    workInProgress = completedWork = unitOfWork;
  } while (null !== completedWork);
  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
}
function unwindUnitOfWork(unitOfWork, skipSiblings) {
  do {
    var next = unwindWork(unitOfWork.alternate, unitOfWork);
    if (null !== next) {
      next.flags &= 32767;
      workInProgress = next;
      return;
    }
    next = unitOfWork.return;
    null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
    if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
      workInProgress = unitOfWork;
      return;
    }
    workInProgress = unitOfWork = next;
  } while (null !== unitOfWork);
  workInProgressRootExitStatus = 6;
  workInProgress = null;
}
function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
  root2.cancelPendingCommit = null;
  do
    flushPendingEffects();
  while (0 !== pendingEffectsStatus);
  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
  if (null !== finishedWork) {
    if (finishedWork === root2.current) throw Error(formatProdErrorMessage(177));
    didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
    didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
    markRootFinished(
      root2,
      lanes,
      didIncludeRenderPhaseUpdate,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes
    );
    root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
    pendingFinishedWork = finishedWork;
    pendingEffectsRoot = root2;
    pendingEffectsLanes = lanes;
    pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
    pendingPassiveTransitions = transitions;
    pendingRecoverableErrors = recoverableErrors;
    0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
      flushPassiveEffects();
      return null;
    })) : (root2.callbackNode = null, root2.callbackPriority = 0);
    recoverableErrors = 0 !== (finishedWork.flags & 13878);
    if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
      recoverableErrors = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      transitions = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      spawnedLane = executionContext;
      executionContext |= 4;
      try {
        commitBeforeMutationEffects(root2, finishedWork, lanes);
      } finally {
        executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
      }
    }
    pendingEffectsStatus = 1;
    flushMutationEffects();
    flushLayoutEffects();
    flushSpawnedWork();
  }
}
function flushMutationEffects() {
  if (1 === pendingEffectsStatus) {
    pendingEffectsStatus = 0;
    var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
    if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
      rootMutationHasEffect = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      var prevExecutionContext = executionContext;
      executionContext |= 4;
      try {
        commitMutationEffectsOnFiber(finishedWork, root2);
        var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
        if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
          priorFocusedElem.ownerDocument.documentElement,
          priorFocusedElem
        )) {
          if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
            var start = priorSelectionRange.start, end = priorSelectionRange.end;
            void 0 === end && (end = start);
            if ("selectionStart" in priorFocusedElem)
              priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                end,
                priorFocusedElem.value.length
              );
            else {
              var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
              if (win.getSelection) {
                var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                var startMarker = getNodeForCharacterOffset(
                  priorFocusedElem,
                  start$jscomp$0
                ), endMarker = getNodeForCharacterOffset(
                  priorFocusedElem,
                  end$jscomp$0
                );
                if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                  var range = doc.createRange();
                  range.setStart(startMarker.node, startMarker.offset);
                  selection.removeAllRanges();
                  start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                }
              }
            }
          }
          doc = [];
          for (selection = priorFocusedElem; selection = selection.parentNode; )
            1 === selection.nodeType && doc.push({
              element: selection,
              left: selection.scrollLeft,
              top: selection.scrollTop
            });
          "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
          for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
            var info = doc[priorFocusedElem];
            info.element.scrollLeft = info.left;
            info.element.scrollTop = info.top;
          }
        }
        _enabled = !!eventsEnabled;
        selectionInformation = eventsEnabled = null;
      } finally {
        executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
      }
    }
    root2.current = finishedWork;
    pendingEffectsStatus = 2;
  }
}
function flushLayoutEffects() {
  if (2 === pendingEffectsStatus) {
    pendingEffectsStatus = 0;
    var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
    if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
      rootHasLayoutEffect = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      var prevExecutionContext = executionContext;
      executionContext |= 4;
      try {
        commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork);
      } finally {
        executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
      }
    }
    pendingEffectsStatus = 3;
  }
}
function flushSpawnedWork() {
  if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
    pendingEffectsStatus = 0;
    requestPaint();
    var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
    0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes));
    var remainingLanes = root2.pendingLanes;
    0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
    lanesToEventPriority(lanes);
    finishedWork = finishedWork.stateNode;
    if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
      try {
        injectedHook.onCommitFiberRoot(
          rendererID,
          finishedWork,
          void 0,
          128 === (finishedWork.current.flags & 128)
        );
      } catch (err) {
      }
    if (null !== recoverableErrors) {
      finishedWork = ReactSharedInternals.T;
      remainingLanes = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      ReactSharedInternals.T = null;
      try {
        for (var onRecoverableError = root2.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
          var recoverableError = recoverableErrors[i];
          onRecoverableError(recoverableError.value, {
            componentStack: recoverableError.stack
          });
        }
      } finally {
        ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
      }
    }
    0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
    ensureRootIsScheduled(root2);
    remainingLanes = root2.pendingLanes;
    0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
    flushSyncWorkAcrossRoots_impl(0);
  }
}
function releaseRootPooledCache(root2, remainingLanes) {
  0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
}
function flushPendingEffects(wasDelayedCommit) {
  flushMutationEffects();
  flushLayoutEffects();
  flushSpawnedWork();
  return flushPassiveEffects();
}
function flushPassiveEffects() {
  if (5 !== pendingEffectsStatus) return false;
  var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
  pendingEffectsRemainingLanes = 0;
  var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
  try {
    ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
    ReactSharedInternals.T = null;
    renderPriority = pendingPassiveTransitions;
    pendingPassiveTransitions = null;
    var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
    pendingEffectsStatus = 0;
    pendingFinishedWork = pendingEffectsRoot = null;
    pendingEffectsLanes = 0;
    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
    var prevExecutionContext = executionContext;
    executionContext |= 4;
    commitPassiveUnmountOnFiber(root$jscomp$0.current);
    commitPassiveMountOnFiber(
      root$jscomp$0,
      root$jscomp$0.current,
      lanes,
      renderPriority
    );
    executionContext = prevExecutionContext;
    flushSyncWorkAcrossRoots_impl(0, false);
    if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
      try {
        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
      } catch (err) {
      }
    return true;
  } finally {
    ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root2, remainingLanes);
  }
}
function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
  sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
  null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
}
function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
  if (3 === sourceFiber.tag)
    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
  else
    for (; null !== nearestMountedAncestor; ) {
      if (3 === nearestMountedAncestor.tag) {
        captureCommitPhaseErrorOnRoot(
          nearestMountedAncestor,
          sourceFiber,
          error
        );
        break;
      } else if (1 === nearestMountedAncestor.tag) {
        var instance = nearestMountedAncestor.stateNode;
        if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          error = createClassErrorUpdate(2);
          instance = enqueueUpdate(nearestMountedAncestor, error, 2);
          null !== instance && (initializeClassErrorUpdate(
            error,
            instance,
            nearestMountedAncestor,
            sourceFiber
          ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
          break;
        }
      }
      nearestMountedAncestor = nearestMountedAncestor.return;
    }
}
function attachPingListener(root2, wakeable, lanes) {
  var pingCache = root2.pingCache;
  if (null === pingCache) {
    pingCache = root2.pingCache = new PossiblyWeakMap();
    var threadIDs = /* @__PURE__ */ new Set();
    pingCache.set(wakeable, threadIDs);
  } else
    threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
  threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
}
function pingSuspendedRoot(root2, wakeable, pingedLanes) {
  var pingCache = root2.pingCache;
  null !== pingCache && pingCache.delete(wakeable);
  root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
  root2.warmLanes &= ~pingedLanes;
  workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
  ensureRootIsScheduled(root2);
}
function retryTimedOutBoundary(boundaryFiber, retryLane) {
  0 === retryLane && (retryLane = claimNextRetryLane());
  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
  null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
}
function retryDehydratedSuspenseBoundary(boundaryFiber) {
  var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
  null !== suspenseState && (retryLane = suspenseState.retryLane);
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function resolveRetryWakeable(boundaryFiber, wakeable) {
  var retryLane = 0;
  switch (boundaryFiber.tag) {
    case 13:
      var retryCache = boundaryFiber.stateNode;
      var suspenseState = boundaryFiber.memoizedState;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      break;
    case 19:
      retryCache = boundaryFiber.stateNode;
      break;
    case 22:
      retryCache = boundaryFiber.stateNode._retryCache;
      break;
    default:
      throw Error(formatProdErrorMessage(314));
  }
  null !== retryCache && retryCache.delete(wakeable);
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function scheduleCallback$1(priorityLevel, callback) {
  return scheduleCallback$3(priorityLevel, callback);
}
var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
function ensureRootIsScheduled(root2) {
  root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
  mightHavePendingSyncWork = true;
  didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
}
function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
  if (!isFlushingWork && mightHavePendingSyncWork) {
    isFlushingWork = true;
    do {
      var didPerformSomeWork = false;
      for (var root$174 = firstScheduledRoot; null !== root$174; ) {
        if (0 !== syncTransitionLanes) {
          var pendingLanes = root$174.pendingLanes;
          if (0 === pendingLanes) var JSCompiler_inline_result = 0;
          else {
            var suspendedLanes = root$174.suspendedLanes, pingedLanes = root$174.pingedLanes;
            JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
            JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
            JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
          }
          0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
        } else
          JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
            root$174,
            root$174 === workInProgressRoot ? JSCompiler_inline_result : 0,
            null !== root$174.cancelPendingCommit || -1 !== root$174.timeoutHandle
          ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
        root$174 = root$174.next;
      }
    } while (didPerformSomeWork);
    isFlushingWork = false;
  }
}
function processRootScheduleInImmediateTask() {
  processRootScheduleInMicrotask();
}
function processRootScheduleInMicrotask() {
  mightHavePendingSyncWork = didScheduleMicrotask = false;
  var syncTransitionLanes = 0;
  0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
  for (var currentTime = now(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
    var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
    if (0 === nextLanes)
      root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
    else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
      mightHavePendingSyncWork = true;
    root2 = next;
  }
  flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
}
function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
  for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
    var index$3 = 31 - clz32(lanes), lane = 1 << index$3, expirationTime = expirationTimes[index$3];
    if (-1 === expirationTime) {
      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
        expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
    } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
    lanes &= ~lane;
  }
  currentTime = workInProgressRoot;
  suspendedLanes = workInProgressRootRenderLanes;
  suspendedLanes = getNextLanes(
    root2,
    root2 === currentTime ? suspendedLanes : 0,
    null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
  );
  pingedLanes = root2.callbackNode;
  if (0 === suspendedLanes || root2 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
    return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
  if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
    currentTime = suspendedLanes & -suspendedLanes;
    if (currentTime === root2.callbackPriority) return currentTime;
    null !== pingedLanes && cancelCallback$1(pingedLanes);
    switch (lanesToEventPriority(suspendedLanes)) {
      case 2:
      case 8:
        suspendedLanes = UserBlockingPriority;
        break;
      case 32:
        suspendedLanes = NormalPriority$1;
        break;
      case 268435456:
        suspendedLanes = IdlePriority;
        break;
      default:
        suspendedLanes = NormalPriority$1;
    }
    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
    root2.callbackPriority = currentTime;
    root2.callbackNode = suspendedLanes;
    return currentTime;
  }
  null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
  root2.callbackPriority = 2;
  root2.callbackNode = null;
  return 2;
}
function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
  if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
    return root2.callbackNode = null, root2.callbackPriority = 0, null;
  var originalCallbackNode = root2.callbackNode;
  if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
    return null;
  var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
  workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
    root2,
    root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
    null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
  );
  if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
  performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
  scheduleTaskForRootDuringMicrotask(root2, now());
  return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
}
function performSyncWorkOnRoot(root2, lanes) {
  if (flushPendingEffects()) return null;
  performWorkOnRoot(root2, lanes, true);
}
function scheduleImmediateRootScheduleTask() {
  scheduleMicrotask(function() {
    0 !== (executionContext & 6) ? scheduleCallback$3(
      ImmediatePriority,
      processRootScheduleInImmediateTask
    ) : processRootScheduleInMicrotask();
  });
}
function requestTransitionLane() {
  0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
  return currentEventTransitionLane;
}
function coerceFormActionProp(actionProp) {
  return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
}
function createFormDataWithSubmitter(form, submitter) {
  var temp = submitter.ownerDocument.createElement("input");
  temp.name = submitter.name;
  temp.value = submitter.value;
  form.id && temp.setAttribute("form", form.id);
  submitter.parentNode.insertBefore(temp, submitter);
  form = new FormData(form);
  temp.parentNode.removeChild(temp);
  return form;
}
function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
  if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
    var action = coerceFormActionProp(
      (nativeEventTarget[internalPropsKey] || null).action
    ), submitter = nativeEvent.submitter;
    submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
    var event = new SyntheticEvent(
      "action",
      "action",
      null,
      nativeEvent,
      nativeEventTarget
    );
    dispatchQueue.push({
      event,
      listeners: [
        {
          instance: null,
          listener: function() {
            if (nativeEvent.defaultPrevented) {
              if (0 !== currentEventTransitionLane) {
                var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                startHostTransition(
                  maybeTargetInst,
                  {
                    pending: true,
                    data: formData,
                    method: nativeEventTarget.method,
                    action
                  },
                  null,
                  formData
                );
              }
            } else
              "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                maybeTargetInst,
                {
                  pending: true,
                  data: formData,
                  method: nativeEventTarget.method,
                  action
                },
                action,
                formData
              ));
          },
          currentTarget: nativeEventTarget
        }
      ]
    });
  }
}
for (var i$jscomp$inline_1528 = 0; i$jscomp$inline_1528 < simpleEventPluginEvents.length; i$jscomp$inline_1528++) {
  var eventName$jscomp$inline_1529 = simpleEventPluginEvents[i$jscomp$inline_1528], domEventName$jscomp$inline_1530 = eventName$jscomp$inline_1529.toLowerCase(), capitalizedEvent$jscomp$inline_1531 = eventName$jscomp$inline_1529[0].toUpperCase() + eventName$jscomp$inline_1529.slice(1);
  registerSimpleEvent(
    domEventName$jscomp$inline_1530,
    "on" + capitalizedEvent$jscomp$inline_1531
  );
}
registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
registerSimpleEvent(ANIMATION_START, "onAnimationStart");
registerSimpleEvent("dblclick", "onDoubleClick");
registerSimpleEvent("focusin", "onFocus");
registerSimpleEvent("focusout", "onBlur");
registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
registerSimpleEvent(TRANSITION_START, "onTransitionStart");
registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
registerTwoPhaseEvent(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
registerTwoPhaseEvent(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
registerTwoPhaseEvent("onBeforeInput", [
  "compositionend",
  "keypress",
  "textInput",
  "paste"
]);
registerTwoPhaseEvent(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
registerTwoPhaseEvent(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
registerTwoPhaseEvent(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
  " "
), nonDelegatedEvents = new Set(
  "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
);
function processDispatchQueue(dispatchQueue, eventSystemFlags) {
  eventSystemFlags = 0 !== (eventSystemFlags & 4);
  for (var i = 0; i < dispatchQueue.length; i++) {
    var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
    _dispatchQueue$i = _dispatchQueue$i.listeners;
    a: {
      var previousInstance = void 0;
      if (eventSystemFlags)
        for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped())
            break a;
          previousInstance = _dispatchListeners$i;
          event.currentTarget = currentTarget;
          try {
            previousInstance(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
          previousInstance = instance;
        }
      else
        for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
          instance = _dispatchListeners$i.instance;
          currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped())
            break a;
          previousInstance = _dispatchListeners$i;
          event.currentTarget = currentTarget;
          try {
            previousInstance(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
          previousInstance = instance;
        }
    }
  }
}
function listenToNonDelegatedEvent(domEventName, targetElement) {
  var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
  void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
  var listenerSetKey = domEventName + "__bubble";
  JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
}
function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
  var eventSystemFlags = 0;
  isCapturePhaseListener && (eventSystemFlags |= 4);
  addTrappedEventListener(
    target,
    domEventName,
    eventSystemFlags,
    isCapturePhaseListener
  );
}
var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
function listenToAllSupportedEvents(rootContainerElement) {
  if (!rootContainerElement[listeningMarker]) {
    rootContainerElement[listeningMarker] = true;
    allNativeEvents.forEach(function(domEventName) {
      "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
    });
    var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
    null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
  }
}
function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
  switch (getEventPriority(domEventName)) {
    case 2:
      var listenerWrapper = dispatchDiscreteEvent;
      break;
    case 8:
      listenerWrapper = dispatchContinuousEvent;
      break;
    default:
      listenerWrapper = dispatchEvent;
  }
  eventSystemFlags = listenerWrapper.bind(
    null,
    domEventName,
    eventSystemFlags,
    targetContainer
  );
  listenerWrapper = void 0;
  !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
  isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
    capture: true,
    passive: listenerWrapper
  }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
    passive: listenerWrapper
  }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
}
function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
  var ancestorInst = targetInst$jscomp$0;
  if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
    a: for (; ; ) {
      if (null === targetInst$jscomp$0) return;
      var nodeTag = targetInst$jscomp$0.tag;
      if (3 === nodeTag || 4 === nodeTag) {
        var container2 = targetInst$jscomp$0.stateNode.containerInfo;
        if (container2 === targetContainer) break;
        if (4 === nodeTag)
          for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
            var grandTag = nodeTag.tag;
            if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
              return;
            nodeTag = nodeTag.return;
          }
        for (; null !== container2; ) {
          nodeTag = getClosestInstanceFromNode(container2);
          if (null === nodeTag) return;
          grandTag = nodeTag.tag;
          if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
            targetInst$jscomp$0 = ancestorInst = nodeTag;
            continue a;
          }
          container2 = container2.parentNode;
        }
      }
      targetInst$jscomp$0 = targetInst$jscomp$0.return;
    }
  batchedUpdates$1(function() {
    var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
    a: {
      var reactName = topLevelEventsToReactNames.get(domEventName);
      if (void 0 !== reactName) {
        var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
        switch (domEventName) {
          case "keypress":
            if (0 === getEventCharCode(nativeEvent)) break a;
          case "keydown":
          case "keyup":
            SyntheticEventCtor = SyntheticKeyboardEvent;
            break;
          case "focusin":
            reactEventType = "focus";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "focusout":
            reactEventType = "blur";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "beforeblur":
          case "afterblur":
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "click":
            if (2 === nativeEvent.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            SyntheticEventCtor = SyntheticMouseEvent;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            SyntheticEventCtor = SyntheticDragEvent;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            SyntheticEventCtor = SyntheticTouchEvent;
            break;
          case ANIMATION_END:
          case ANIMATION_ITERATION:
          case ANIMATION_START:
            SyntheticEventCtor = SyntheticAnimationEvent;
            break;
          case TRANSITION_END:
            SyntheticEventCtor = SyntheticTransitionEvent;
            break;
          case "scroll":
          case "scrollend":
            SyntheticEventCtor = SyntheticUIEvent;
            break;
          case "wheel":
            SyntheticEventCtor = SyntheticWheelEvent;
            break;
          case "copy":
          case "cut":
          case "paste":
            SyntheticEventCtor = SyntheticClipboardEvent;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            SyntheticEventCtor = SyntheticPointerEvent;
            break;
          case "toggle":
          case "beforetoggle":
            SyntheticEventCtor = SyntheticToggleEvent;
        }
        var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
        inCapturePhase = [];
        for (var instance = targetInst, lastHostComponent; null !== instance; ) {
          var _instance = instance;
          lastHostComponent = _instance.stateNode;
          _instance = _instance.tag;
          5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
            createDispatchListener(instance, _instance, lastHostComponent)
          ));
          if (accumulateTargetOnly) break;
          instance = instance.return;
        }
        0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
          reactName,
          reactEventType,
          null,
          nativeEvent,
          nativeEventTarget
        ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
      }
    }
    if (0 === (eventSystemFlags & 7)) {
      a: {
        reactName = "mouseover" === domEventName || "pointerover" === domEventName;
        SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
        if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
          break a;
        if (SyntheticEventCtor || reactName) {
          reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
          if (SyntheticEventCtor) {
            if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
              reactEventType = null;
          } else SyntheticEventCtor = null, reactEventType = targetInst;
          if (SyntheticEventCtor !== reactEventType) {
            inCapturePhase = SyntheticMouseEvent;
            _instance = "onMouseLeave";
            reactEventName = "onMouseEnter";
            instance = "mouse";
            if ("pointerout" === domEventName || "pointerover" === domEventName)
              inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
            accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
            lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
            reactName = new inCapturePhase(
              _instance,
              instance + "leave",
              SyntheticEventCtor,
              nativeEvent,
              nativeEventTarget
            );
            reactName.target = accumulateTargetOnly;
            reactName.relatedTarget = lastHostComponent;
            _instance = null;
            getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
              reactEventName,
              instance + "enter",
              reactEventType,
              nativeEvent,
              nativeEventTarget
            ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
            accumulateTargetOnly = _instance;
            if (SyntheticEventCtor && reactEventType)
              b: {
                inCapturePhase = SyntheticEventCtor;
                reactEventName = reactEventType;
                instance = 0;
                for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                  instance++;
                lastHostComponent = 0;
                for (_instance = reactEventName; _instance; _instance = getParent(_instance))
                  lastHostComponent++;
                for (; 0 < instance - lastHostComponent; )
                  inCapturePhase = getParent(inCapturePhase), instance--;
                for (; 0 < lastHostComponent - instance; )
                  reactEventName = getParent(reactEventName), lastHostComponent--;
                for (; instance--; ) {
                  if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
                    break b;
                  inCapturePhase = getParent(inCapturePhase);
                  reactEventName = getParent(reactEventName);
                }
                inCapturePhase = null;
              }
            else inCapturePhase = null;
            null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
              dispatchQueue,
              reactName,
              SyntheticEventCtor,
              inCapturePhase,
              false
            );
            null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
              dispatchQueue,
              accumulateTargetOnly,
              reactEventType,
              inCapturePhase,
              true
            );
          }
        }
      }
      a: {
        reactName = targetInst ? getNodeFromInstance(targetInst) : window;
        SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
        if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
          var getTargetInstFunc = getTargetInstForChangeEvent;
        else if (isTextInputElement(reactName))
          if (isInputEventSupported)
            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
          else {
            getTargetInstFunc = getTargetInstForInputEventPolyfill;
            var handleEventFunc = handleEventsForInputEventPolyfill;
          }
        else
          SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
        if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
          createAndAccumulateChangeEvent(
            dispatchQueue,
            getTargetInstFunc,
            nativeEvent,
            nativeEventTarget
          );
          break a;
        }
        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
        "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
      }
      handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
      switch (domEventName) {
        case "focusin":
          if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
            activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
          break;
        case "focusout":
          lastSelection = activeElementInst = activeElement = null;
          break;
        case "mousedown":
          mouseDown = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          mouseDown = false;
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          break;
        case "selectionchange":
          if (skipSelectionChangeEvent) break;
        case "keydown":
        case "keyup":
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
      }
      var fallbackData;
      if (canUseCompositionEvent)
        b: {
          switch (domEventName) {
            case "compositionstart":
              var eventType = "onCompositionStart";
              break b;
            case "compositionend":
              eventType = "onCompositionEnd";
              break b;
            case "compositionupdate":
              eventType = "onCompositionUpdate";
              break b;
          }
          eventType = void 0;
        }
      else
        isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
      eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
        eventType,
        domEventName,
        null,
        nativeEvent,
        nativeEventTarget
      ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
      if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
        eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
          "onBeforeInput",
          "beforeinput",
          null,
          nativeEvent,
          nativeEventTarget
        ), dispatchQueue.push({
          event: handleEventFunc,
          listeners: eventType
        }), handleEventFunc.data = fallbackData);
      extractEvents$1(
        dispatchQueue,
        domEventName,
        targetInst,
        nativeEvent,
        nativeEventTarget
      );
    }
    processDispatchQueue(dispatchQueue, eventSystemFlags);
  });
}
function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance,
    listener,
    currentTarget
  };
}
function accumulateTwoPhaseListeners(targetFiber, reactName) {
  for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
    var _instance2 = targetFiber, stateNode = _instance2.stateNode;
    _instance2 = _instance2.tag;
    5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
      createDispatchListener(targetFiber, _instance2, stateNode)
    ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
      createDispatchListener(targetFiber, _instance2, stateNode)
    ));
    if (3 === targetFiber.tag) return listeners;
    targetFiber = targetFiber.return;
  }
  return [];
}
function getParent(inst) {
  if (null === inst) return null;
  do
    inst = inst.return;
  while (inst && 5 !== inst.tag && 27 !== inst.tag);
  return inst ? inst : null;
}
function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
  for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
    var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
    _instance3 = _instance3.tag;
    if (null !== alternate && alternate === common) break;
    5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
      createDispatchListener(target, stateNode, alternate)
    )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
      createDispatchListener(target, stateNode, alternate)
    )));
    target = target.return;
  }
  0 !== listeners.length && dispatchQueue.push({ event, listeners });
}
var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
function normalizeMarkupForTextOrAttribute(markup) {
  return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
}
function checkForUnmatchedText(serverText, clientText) {
  clientText = normalizeMarkupForTextOrAttribute(clientText);
  return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
}
function noop$1() {
}
function setProp(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "children":
      "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
      break;
    case "className":
      setValueForKnownAttribute(domElement, "class", value);
      break;
    case "tabIndex":
      setValueForKnownAttribute(domElement, "tabindex", value);
      break;
    case "dir":
    case "role":
    case "viewBox":
    case "width":
    case "height":
      setValueForKnownAttribute(domElement, key, value);
      break;
    case "style":
      setValueForStyles(domElement, value, prevValue);
      break;
    case "data":
      if ("object" !== tag) {
        setValueForKnownAttribute(domElement, "data", value);
        break;
      }
    case "src":
    case "href":
      if ("" === value && ("a" !== tag || "href" !== key)) {
        domElement.removeAttribute(key);
        break;
      }
      if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
        domElement.removeAttribute(key);
        break;
      }
      value = sanitizeURL("" + value);
      domElement.setAttribute(key, value);
      break;
    case "action":
    case "formAction":
      if ("function" === typeof value) {
        domElement.setAttribute(
          key,
          "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
        );
        break;
      } else
        "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
          domElement,
          tag,
          "formEncType",
          props.formEncType,
          props,
          null
        ), setProp(
          domElement,
          tag,
          "formMethod",
          props.formMethod,
          props,
          null
        ), setProp(
          domElement,
          tag,
          "formTarget",
          props.formTarget,
          props,
          null
        )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
      if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
        domElement.removeAttribute(key);
        break;
      }
      value = sanitizeURL("" + value);
      domElement.setAttribute(key, value);
      break;
    case "onClick":
      null != value && (domElement.onclick = noop$1);
      break;
    case "onScroll":
      null != value && listenToNonDelegatedEvent("scroll", domElement);
      break;
    case "onScrollEnd":
      null != value && listenToNonDelegatedEvent("scrollend", domElement);
      break;
    case "dangerouslySetInnerHTML":
      if (null != value) {
        if ("object" !== typeof value || !("__html" in value))
          throw Error(formatProdErrorMessage(61));
        key = value.__html;
        if (null != key) {
          if (null != props.children) throw Error(formatProdErrorMessage(60));
          domElement.innerHTML = key;
        }
      }
      break;
    case "multiple":
      domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
      break;
    case "muted":
      domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "ref":
      break;
    case "autoFocus":
      break;
    case "xlinkHref":
      if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
        domElement.removeAttribute("xlink:href");
        break;
      }
      key = sanitizeURL("" + value);
      domElement.setAttributeNS(
        "http://www.w3.org/1999/xlink",
        "xlink:href",
        key
      );
      break;
    case "contentEditable":
    case "spellCheck":
    case "draggable":
    case "value":
    case "autoReverse":
    case "externalResourcesRequired":
    case "focusable":
    case "preserveAlpha":
      null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
      break;
    case "inert":
    case "allowFullScreen":
    case "async":
    case "autoPlay":
    case "controls":
    case "default":
    case "defer":
    case "disabled":
    case "disablePictureInPicture":
    case "disableRemotePlayback":
    case "formNoValidate":
    case "hidden":
    case "loop":
    case "noModule":
    case "noValidate":
    case "open":
    case "playsInline":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "itemScope":
      value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
      break;
    case "capture":
    case "download":
      true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
      break;
    case "cols":
    case "rows":
    case "size":
    case "span":
      null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
      break;
    case "rowSpan":
    case "start":
      null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
      break;
    case "popover":
      listenToNonDelegatedEvent("beforetoggle", domElement);
      listenToNonDelegatedEvent("toggle", domElement);
      setValueForAttribute(domElement, "popover", value);
      break;
    case "xlinkActuate":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:actuate",
        value
      );
      break;
    case "xlinkArcrole":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:arcrole",
        value
      );
      break;
    case "xlinkRole":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:role",
        value
      );
      break;
    case "xlinkShow":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:show",
        value
      );
      break;
    case "xlinkTitle":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:title",
        value
      );
      break;
    case "xlinkType":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:type",
        value
      );
      break;
    case "xmlBase":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:base",
        value
      );
      break;
    case "xmlLang":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:lang",
        value
      );
      break;
    case "xmlSpace":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:space",
        value
      );
      break;
    case "is":
      setValueForAttribute(domElement, "is", value);
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
        key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
  }
}
function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "style":
      setValueForStyles(domElement, value, prevValue);
      break;
    case "dangerouslySetInnerHTML":
      if (null != value) {
        if ("object" !== typeof value || !("__html" in value))
          throw Error(formatProdErrorMessage(61));
        key = value.__html;
        if (null != key) {
          if (null != props.children) throw Error(formatProdErrorMessage(60));
          domElement.innerHTML = key;
        }
      }
      break;
    case "children":
      "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
      break;
    case "onScroll":
      null != value && listenToNonDelegatedEvent("scroll", domElement);
      break;
    case "onScrollEnd":
      null != value && listenToNonDelegatedEvent("scrollend", domElement);
      break;
    case "onClick":
      null != value && (domElement.onclick = noop$1);
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "innerHTML":
    case "ref":
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (!registrationNameDependencies.hasOwnProperty(key))
        a: {
          if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
            "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
            domElement.addEventListener(tag, value, props);
            break a;
          }
          key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
        }
  }
}
function setInitialProperties(domElement, tag, props) {
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "img":
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      var hasSrc = false, hasSrcSet = false, propKey;
      for (propKey in props)
        if (props.hasOwnProperty(propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "src":
                hasSrc = true;
                break;
              case "srcSet":
                hasSrcSet = true;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(formatProdErrorMessage(137, tag));
              default:
                setProp(domElement, tag, propKey, propValue, props, null);
            }
        }
      hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
      hasSrc && setProp(domElement, tag, "src", props.src, props, null);
      return;
    case "input":
      listenToNonDelegatedEvent("invalid", domElement);
      var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
      for (hasSrc in props)
        if (props.hasOwnProperty(hasSrc)) {
          var propValue$188 = props[hasSrc];
          if (null != propValue$188)
            switch (hasSrc) {
              case "name":
                hasSrcSet = propValue$188;
                break;
              case "type":
                propValue = propValue$188;
                break;
              case "checked":
                checked = propValue$188;
                break;
              case "defaultChecked":
                defaultChecked = propValue$188;
                break;
              case "value":
                propKey = propValue$188;
                break;
              case "defaultValue":
                defaultValue = propValue$188;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (null != propValue$188)
                  throw Error(formatProdErrorMessage(137, tag));
                break;
              default:
                setProp(domElement, tag, hasSrc, propValue$188, props, null);
            }
        }
      initInput(
        domElement,
        propKey,
        defaultValue,
        checked,
        defaultChecked,
        propValue,
        hasSrcSet,
        false
      );
      track(domElement);
      return;
    case "select":
      listenToNonDelegatedEvent("invalid", domElement);
      hasSrc = propValue = propKey = null;
      for (hasSrcSet in props)
        if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
          switch (hasSrcSet) {
            case "value":
              propKey = defaultValue;
              break;
            case "defaultValue":
              propValue = defaultValue;
              break;
            case "multiple":
              hasSrc = defaultValue;
            default:
              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
          }
      tag = propKey;
      props = propValue;
      domElement.multiple = !!hasSrc;
      null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
      return;
    case "textarea":
      listenToNonDelegatedEvent("invalid", domElement);
      propKey = hasSrcSet = hasSrc = null;
      for (propValue in props)
        if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
          switch (propValue) {
            case "value":
              hasSrc = defaultValue;
              break;
            case "defaultValue":
              hasSrcSet = defaultValue;
              break;
            case "children":
              propKey = defaultValue;
              break;
            case "dangerouslySetInnerHTML":
              if (null != defaultValue) throw Error(formatProdErrorMessage(91));
              break;
            default:
              setProp(domElement, tag, propValue, defaultValue, props, null);
          }
      initTextarea(domElement, hasSrc, hasSrcSet, propKey);
      track(domElement);
      return;
    case "option":
      for (checked in props)
        if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
          switch (checked) {
            case "selected":
              domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
              break;
            default:
              setProp(domElement, tag, checked, hasSrc, props, null);
          }
      return;
    case "dialog":
      listenToNonDelegatedEvent("beforetoggle", domElement);
      listenToNonDelegatedEvent("toggle", domElement);
      listenToNonDelegatedEvent("cancel", domElement);
      listenToNonDelegatedEvent("close", domElement);
      break;
    case "iframe":
    case "object":
      listenToNonDelegatedEvent("load", domElement);
      break;
    case "video":
    case "audio":
      for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
        listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
      break;
    case "image":
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      break;
    case "details":
      listenToNonDelegatedEvent("toggle", domElement);
      break;
    case "embed":
    case "source":
    case "link":
      listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
    case "area":
    case "base":
    case "br":
    case "col":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "track":
    case "wbr":
    case "menuitem":
      for (defaultChecked in props)
        if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
          switch (defaultChecked) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(formatProdErrorMessage(137, tag));
            default:
              setProp(domElement, tag, defaultChecked, hasSrc, props, null);
          }
      return;
    default:
      if (isCustomElement(tag)) {
        for (propValue$188 in props)
          props.hasOwnProperty(propValue$188) && (hasSrc = props[propValue$188], void 0 !== hasSrc && setPropOnCustomElement(
            domElement,
            tag,
            propValue$188,
            hasSrc,
            props,
            void 0
          ));
        return;
      }
  }
  for (defaultValue in props)
    props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
}
function updateProperties(domElement, tag, lastProps, nextProps) {
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "input":
      var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
      for (propKey in lastProps) {
        var lastProp = lastProps[propKey];
        if (lastProps.hasOwnProperty(propKey) && null != lastProp)
          switch (propKey) {
            case "checked":
              break;
            case "value":
              break;
            case "defaultValue":
              lastDefaultValue = lastProp;
            default:
              nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
          }
      }
      for (var propKey$205 in nextProps) {
        var propKey = nextProps[propKey$205];
        lastProp = lastProps[propKey$205];
        if (nextProps.hasOwnProperty(propKey$205) && (null != propKey || null != lastProp))
          switch (propKey$205) {
            case "type":
              type = propKey;
              break;
            case "name":
              name = propKey;
              break;
            case "checked":
              checked = propKey;
              break;
            case "defaultChecked":
              defaultChecked = propKey;
              break;
            case "value":
              value = propKey;
              break;
            case "defaultValue":
              defaultValue = propKey;
              break;
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != propKey)
                throw Error(formatProdErrorMessage(137, tag));
              break;
            default:
              propKey !== lastProp && setProp(
                domElement,
                tag,
                propKey$205,
                propKey,
                nextProps,
                lastProp
              );
          }
      }
      updateInput(
        domElement,
        value,
        defaultValue,
        lastDefaultValue,
        checked,
        defaultChecked,
        type,
        name
      );
      return;
    case "select":
      propKey = value = defaultValue = propKey$205 = null;
      for (type in lastProps)
        if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
          switch (type) {
            case "value":
              break;
            case "multiple":
              propKey = lastDefaultValue;
            default:
              nextProps.hasOwnProperty(type) || setProp(
                domElement,
                tag,
                type,
                null,
                nextProps,
                lastDefaultValue
              );
          }
      for (name in nextProps)
        if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
          switch (name) {
            case "value":
              propKey$205 = type;
              break;
            case "defaultValue":
              defaultValue = type;
              break;
            case "multiple":
              value = type;
            default:
              type !== lastDefaultValue && setProp(
                domElement,
                tag,
                name,
                type,
                nextProps,
                lastDefaultValue
              );
          }
      tag = defaultValue;
      lastProps = value;
      nextProps = propKey;
      null != propKey$205 ? updateOptions(domElement, !!lastProps, propKey$205, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
      return;
    case "textarea":
      propKey = propKey$205 = null;
      for (defaultValue in lastProps)
        if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
          switch (defaultValue) {
            case "value":
              break;
            case "children":
              break;
            default:
              setProp(domElement, tag, defaultValue, null, nextProps, name);
          }
      for (value in nextProps)
        if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
          switch (value) {
            case "value":
              propKey$205 = name;
              break;
            case "defaultValue":
              propKey = name;
              break;
            case "children":
              break;
            case "dangerouslySetInnerHTML":
              if (null != name) throw Error(formatProdErrorMessage(91));
              break;
            default:
              name !== type && setProp(domElement, tag, value, name, nextProps, type);
          }
      updateTextarea(domElement, propKey$205, propKey);
      return;
    case "option":
      for (var propKey$221 in lastProps)
        if (propKey$205 = lastProps[propKey$221], lastProps.hasOwnProperty(propKey$221) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$221))
          switch (propKey$221) {
            case "selected":
              domElement.selected = false;
              break;
            default:
              setProp(
                domElement,
                tag,
                propKey$221,
                null,
                nextProps,
                propKey$205
              );
          }
      for (lastDefaultValue in nextProps)
        if (propKey$205 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
          switch (lastDefaultValue) {
            case "selected":
              domElement.selected = propKey$205 && "function" !== typeof propKey$205 && "symbol" !== typeof propKey$205;
              break;
            default:
              setProp(
                domElement,
                tag,
                lastDefaultValue,
                propKey$205,
                nextProps,
                propKey
              );
          }
      return;
    case "img":
    case "link":
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
    case "menuitem":
      for (var propKey$226 in lastProps)
        propKey$205 = lastProps[propKey$226], lastProps.hasOwnProperty(propKey$226) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$226) && setProp(domElement, tag, propKey$226, null, nextProps, propKey$205);
      for (checked in nextProps)
        if (propKey$205 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
          switch (checked) {
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != propKey$205)
                throw Error(formatProdErrorMessage(137, tag));
              break;
            default:
              setProp(
                domElement,
                tag,
                checked,
                propKey$205,
                nextProps,
                propKey
              );
          }
      return;
    default:
      if (isCustomElement(tag)) {
        for (var propKey$231 in lastProps)
          propKey$205 = lastProps[propKey$231], lastProps.hasOwnProperty(propKey$231) && void 0 !== propKey$205 && !nextProps.hasOwnProperty(propKey$231) && setPropOnCustomElement(
            domElement,
            tag,
            propKey$231,
            void 0,
            nextProps,
            propKey$205
          );
        for (defaultChecked in nextProps)
          propKey$205 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$205 === propKey || void 0 === propKey$205 && void 0 === propKey || setPropOnCustomElement(
            domElement,
            tag,
            defaultChecked,
            propKey$205,
            nextProps,
            propKey
          );
        return;
      }
  }
  for (var propKey$236 in lastProps)
    propKey$205 = lastProps[propKey$236], lastProps.hasOwnProperty(propKey$236) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$236) && setProp(domElement, tag, propKey$236, null, nextProps, propKey$205);
  for (lastProp in nextProps)
    propKey$205 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$205 === propKey || null == propKey$205 && null == propKey || setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey);
}
var eventsEnabled = null, selectionInformation = null;
function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
}
function getOwnHostContext(namespaceURI) {
  switch (namespaceURI) {
    case "http://www.w3.org/2000/svg":
      return 1;
    case "http://www.w3.org/1998/Math/MathML":
      return 2;
    default:
      return 0;
  }
}
function getChildHostContextProd(parentNamespace, type) {
  if (0 === parentNamespace)
    switch (type) {
      case "svg":
        return 1;
      case "math":
        return 2;
      default:
        return 0;
    }
  return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
}
function shouldSetTextContent(type, props) {
  return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
}
var currentPopstateTransitionEvent = null;
function shouldAttemptEagerTransition() {
  var event = window.event;
  if (event && "popstate" === event.type) {
    if (event === currentPopstateTransitionEvent) return false;
    currentPopstateTransitionEvent = event;
    return true;
  }
  currentPopstateTransitionEvent = null;
  return false;
}
var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
  return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
} : scheduleTimeout;
function handleErrorInNextTick(error) {
  setTimeout(function() {
    throw error;
  });
}
function isSingletonScope(type) {
  return "head" === type;
}
function clearSuspenseBoundary(parentInstance, suspenseInstance) {
  var node = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
  do {
    var nextNode = node.nextSibling;
    parentInstance.removeChild(node);
    if (nextNode && 8 === nextNode.nodeType)
      if (node = nextNode.data, "/$" === node) {
        if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
          node = possiblePreambleContribution;
          var ownerDocument = parentInstance.ownerDocument;
          node & 1 && releaseSingletonInstance(ownerDocument.documentElement);
          node & 2 && releaseSingletonInstance(ownerDocument.body);
          if (node & 4)
            for (node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild; ownerDocument; ) {
              var nextNode$jscomp$0 = ownerDocument.nextSibling, nodeName = ownerDocument.nodeName;
              ownerDocument[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === ownerDocument.rel.toLowerCase() || node.removeChild(ownerDocument);
              ownerDocument = nextNode$jscomp$0;
            }
        }
        if (0 === depth) {
          parentInstance.removeChild(nextNode);
          retryIfBlockedOn(suspenseInstance);
          return;
        }
        depth--;
      } else
        "$" === node || "$?" === node || "$!" === node ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;
    else possiblePreambleContribution = 0;
    node = nextNode;
  } while (node);
  retryIfBlockedOn(suspenseInstance);
}
function clearContainerSparingly(container2) {
  var nextNode = container2.firstChild;
  nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
  for (; nextNode; ) {
    var node = nextNode;
    nextNode = nextNode.nextSibling;
    switch (node.nodeName) {
      case "HTML":
      case "HEAD":
      case "BODY":
        clearContainerSparingly(node);
        detachDeletedInstance(node);
        continue;
      case "SCRIPT":
      case "STYLE":
        continue;
      case "LINK":
        if ("stylesheet" === node.rel.toLowerCase()) continue;
    }
    container2.removeChild(node);
  }
}
function canHydrateInstance(instance, type, props, inRootOrSingleton) {
  for (; 1 === instance.nodeType; ) {
    var anyProps = props;
    if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
      if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
        break;
    } else if (!inRootOrSingleton)
      if ("input" === type && "hidden" === instance.type) {
        var name = null == anyProps.name ? null : "" + anyProps.name;
        if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
          return instance;
      } else return instance;
    else if (!instance[internalHoistableMarker])
      switch (type) {
        case "meta":
          if (!instance.hasAttribute("itemprop")) break;
          return instance;
        case "link":
          name = instance.getAttribute("rel");
          if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
            break;
          else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
            break;
          return instance;
        case "style":
          if (instance.hasAttribute("data-precedence")) break;
          return instance;
        case "script":
          name = instance.getAttribute("src");
          if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
            break;
          return instance;
        default:
          return instance;
      }
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) break;
  }
  return null;
}
function canHydrateTextInstance(instance, text, inRootOrSingleton) {
  if ("" === text) return null;
  for (; 3 !== instance.nodeType; ) {
    if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
      return null;
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) return null;
  }
  return instance;
}
function isSuspenseInstanceFallback(instance) {
  return "$!" === instance.data || "$?" === instance.data && "complete" === instance.ownerDocument.readyState;
}
function registerSuspenseInstanceRetry(instance, callback) {
  var ownerDocument = instance.ownerDocument;
  if ("$?" !== instance.data || "complete" === ownerDocument.readyState)
    callback();
  else {
    var listener = function() {
      callback();
      ownerDocument.removeEventListener("DOMContentLoaded", listener);
    };
    ownerDocument.addEventListener("DOMContentLoaded", listener);
    instance._reactRetry = listener;
  }
}
function getNextHydratable(node) {
  for (; null != node; node = node.nextSibling) {
    var nodeType = node.nodeType;
    if (1 === nodeType || 3 === nodeType) break;
    if (8 === nodeType) {
      nodeType = node.data;
      if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "F!" === nodeType || "F" === nodeType)
        break;
      if ("/$" === nodeType) return null;
    }
  }
  return node;
}
var previousHydratableOnEnteringScopedSingleton = null;
function getParentSuspenseInstance(targetInstance) {
  targetInstance = targetInstance.previousSibling;
  for (var depth = 0; targetInstance; ) {
    if (8 === targetInstance.nodeType) {
      var data = targetInstance.data;
      if ("$" === data || "$!" === data || "$?" === data) {
        if (0 === depth) return targetInstance;
        depth--;
      } else "/$" === data && depth++;
    }
    targetInstance = targetInstance.previousSibling;
  }
  return null;
}
function resolveSingletonInstance(type, props, rootContainerInstance) {
  props = getOwnerDocumentFromRootContainer(rootContainerInstance);
  switch (type) {
    case "html":
      type = props.documentElement;
      if (!type) throw Error(formatProdErrorMessage(452));
      return type;
    case "head":
      type = props.head;
      if (!type) throw Error(formatProdErrorMessage(453));
      return type;
    case "body":
      type = props.body;
      if (!type) throw Error(formatProdErrorMessage(454));
      return type;
    default:
      throw Error(formatProdErrorMessage(451));
  }
}
function releaseSingletonInstance(instance) {
  for (var attributes = instance.attributes; attributes.length; )
    instance.removeAttributeNode(attributes[0]);
  detachDeletedInstance(instance);
}
var preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set();
function getHoistableRoot(container2) {
  return "function" === typeof container2.getRootNode ? container2.getRootNode() : 9 === container2.nodeType ? container2 : container2.ownerDocument;
}
var previousDispatcher = ReactDOMSharedInternals.d;
ReactDOMSharedInternals.d = {
  f: flushSyncWork,
  r: requestFormReset,
  D: prefetchDNS,
  C: preconnect,
  L: preload,
  m: preloadModule,
  X: preinitScript,
  S: preinitStyle,
  M: preinitModuleScript
};
function flushSyncWork() {
  var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
  return previousWasRendering || wasRendering;
}
function requestFormReset(form) {
  var formInst = getInstanceFromNode(form);
  null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
}
var globalDocument = "undefined" === typeof document ? null : document;
function preconnectAs(rel, href, crossOrigin) {
  var ownerDocument = globalDocument;
  if (ownerDocument && "string" === typeof href && href) {
    var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
    limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
    "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
    preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
  }
}
function prefetchDNS(href) {
  previousDispatcher.D(href);
  preconnectAs("dns-prefetch", href, null);
}
function preconnect(href, crossOrigin) {
  previousDispatcher.C(href, crossOrigin);
  preconnectAs("preconnect", href, crossOrigin);
}
function preload(href, as, options) {
  previousDispatcher.L(href, as, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href && as) {
    var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
    "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
      options.imageSrcSet
    ) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
      options.imageSizes
    ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
    var key = preloadSelector;
    switch (as) {
      case "style":
        key = getStyleKey(href);
        break;
      case "script":
        key = getScriptKey(href);
    }
    preloadPropsMap.has(key) || (href = assign(
      {
        rel: "preload",
        href: "image" === as && options && options.imageSrcSet ? void 0 : href,
        as
      },
      options
    ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
  }
}
function preloadModule(href, options) {
  previousDispatcher.m(href, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href) {
    var as = options && "string" === typeof options.as ? options.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
    switch (as) {
      case "audioworklet":
      case "paintworklet":
      case "serviceworker":
      case "sharedworker":
      case "worker":
      case "script":
        key = getScriptKey(href);
    }
    if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
      switch (as) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
            return;
      }
      as = ownerDocument.createElement("link");
      setInitialProperties(as, "link", href);
      markNodeAsHoistable(as);
      ownerDocument.head.appendChild(as);
    }
  }
}
function preinitStyle(href, precedence, options) {
  previousDispatcher.S(href, precedence, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href) {
    var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
    precedence = precedence || "default";
    var resource = styles.get(key);
    if (!resource) {
      var state = { loading: 0, preload: null };
      if (resource = ownerDocument.querySelector(
        getStylesheetSelectorFromKey(key)
      ))
        state.loading = 5;
      else {
        href = assign(
          { rel: "stylesheet", href, "data-precedence": precedence },
          options
        );
        (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
        var link = resource = ownerDocument.createElement("link");
        markNodeAsHoistable(link);
        setInitialProperties(link, "link", href);
        link._p = new Promise(function(resolve, reject) {
          link.onload = resolve;
          link.onerror = reject;
        });
        link.addEventListener("load", function() {
          state.loading |= 1;
        });
        link.addEventListener("error", function() {
          state.loading |= 2;
        });
        state.loading |= 4;
        insertStylesheet(resource, precedence, ownerDocument);
      }
      resource = {
        type: "stylesheet",
        instance: resource,
        count: 1,
        state
      };
      styles.set(key, resource);
    }
  }
}
function preinitScript(src, options) {
  previousDispatcher.X(src, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && src) {
    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
    resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
      type: "script",
      instance: resource,
      count: 1,
      state: null
    }, scripts.set(key, resource));
  }
}
function preinitModuleScript(src, options) {
  previousDispatcher.M(src, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && src) {
    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
    resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
      type: "script",
      instance: resource,
      count: 1,
      state: null
    }, scripts.set(key, resource));
  }
}
function getResource(type, currentProps, pendingProps, currentResource) {
  var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
  if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
  switch (type) {
    case "meta":
    case "title":
      return null;
    case "style":
      return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
        JSCompiler_inline_result
      ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
        type: "style",
        instance: null,
        count: 0,
        state: null
      }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
    case "link":
      if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
        type = getStyleKey(pendingProps.href);
        var styles$244 = getResourcesFromRoot(
          JSCompiler_inline_result
        ).hoistableStyles, resource$245 = styles$244.get(type);
        resource$245 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$245 = {
          type: "stylesheet",
          instance: null,
          count: 0,
          state: { loading: 0, preload: null }
        }, styles$244.set(type, resource$245), (styles$244 = JSCompiler_inline_result.querySelector(
          getStylesheetSelectorFromKey(type)
        )) && !styles$244._p && (resource$245.instance = styles$244, resource$245.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
          rel: "preload",
          as: "style",
          href: pendingProps.href,
          crossOrigin: pendingProps.crossOrigin,
          integrity: pendingProps.integrity,
          media: pendingProps.media,
          hrefLang: pendingProps.hrefLang,
          referrerPolicy: pendingProps.referrerPolicy
        }, preloadPropsMap.set(type, pendingProps), styles$244 || preloadStylesheet(
          JSCompiler_inline_result,
          type,
          pendingProps,
          resource$245.state
        )));
        if (currentProps && null === currentResource)
          throw Error(formatProdErrorMessage(528, ""));
        return resource$245;
      }
      if (currentProps && null !== currentResource)
        throw Error(formatProdErrorMessage(529, ""));
      return null;
    case "script":
      return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
        JSCompiler_inline_result
      ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
        type: "script",
        instance: null,
        count: 0,
        state: null
      }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
    default:
      throw Error(formatProdErrorMessage(444, type));
  }
}
function getStyleKey(href) {
  return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
}
function getStylesheetSelectorFromKey(key) {
  return 'link[rel="stylesheet"][' + key + "]";
}
function stylesheetPropsFromRawProps(rawProps) {
  return assign({}, rawProps, {
    "data-precedence": rawProps.precedence,
    precedence: null
  });
}
function preloadStylesheet(ownerDocument, key, preloadProps, state) {
  ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
    return state.loading |= 1;
  }), key.addEventListener("error", function() {
    return state.loading |= 2;
  }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
}
function getScriptKey(src) {
  return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
}
function getScriptSelectorFromKey(key) {
  return "script[async]" + key;
}
function acquireResource(hoistableRoot, resource, props) {
  resource.count++;
  if (null === resource.instance)
    switch (resource.type) {
      case "style":
        var instance = hoistableRoot.querySelector(
          'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
        );
        if (instance)
          return resource.instance = instance, markNodeAsHoistable(instance), instance;
        var styleProps = assign({}, props, {
          "data-href": props.href,
          "data-precedence": props.precedence,
          href: null,
          precedence: null
        });
        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
          "style"
        );
        markNodeAsHoistable(instance);
        setInitialProperties(instance, "style", styleProps);
        insertStylesheet(instance, props.precedence, hoistableRoot);
        return resource.instance = instance;
      case "stylesheet":
        styleProps = getStyleKey(props.href);
        var instance$250 = hoistableRoot.querySelector(
          getStylesheetSelectorFromKey(styleProps)
        );
        if (instance$250)
          return resource.state.loading |= 4, resource.instance = instance$250, markNodeAsHoistable(instance$250), instance$250;
        instance = stylesheetPropsFromRawProps(props);
        (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
        instance$250 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
        markNodeAsHoistable(instance$250);
        var linkInstance = instance$250;
        linkInstance._p = new Promise(function(resolve, reject) {
          linkInstance.onload = resolve;
          linkInstance.onerror = reject;
        });
        setInitialProperties(instance$250, "link", instance);
        resource.state.loading |= 4;
        insertStylesheet(instance$250, props.precedence, hoistableRoot);
        return resource.instance = instance$250;
      case "script":
        instance$250 = getScriptKey(props.src);
        if (styleProps = hoistableRoot.querySelector(
          getScriptSelectorFromKey(instance$250)
        ))
          return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
        instance = props;
        if (styleProps = preloadPropsMap.get(instance$250))
          instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        styleProps = hoistableRoot.createElement("script");
        markNodeAsHoistable(styleProps);
        setInitialProperties(styleProps, "link", instance);
        hoistableRoot.head.appendChild(styleProps);
        return resource.instance = styleProps;
      case "void":
        return null;
      default:
        throw Error(formatProdErrorMessage(443, resource.type));
    }
  else
    "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
  return resource.instance;
}
function insertStylesheet(instance, precedence, root2) {
  for (var nodes = root2.querySelectorAll(
    'link[rel="stylesheet"][data-precedence],style[data-precedence]'
  ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (node.dataset.precedence === precedence) prior = node;
    else if (prior !== last) break;
  }
  prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
}
function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
  null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
  null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
  null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
}
function adoptPreloadPropsForScript(scriptProps, preloadProps) {
  null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
  null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
  null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
}
var tagCaches = null;
function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
  if (null === tagCaches) {
    var cache = /* @__PURE__ */ new Map();
    var caches = tagCaches = /* @__PURE__ */ new Map();
    caches.set(ownerDocument, cache);
  } else
    caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
  if (cache.has(type)) return cache;
  cache.set(type, null);
  ownerDocument = ownerDocument.getElementsByTagName(type);
  for (caches = 0; caches < ownerDocument.length; caches++) {
    var node = ownerDocument[caches];
    if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
      var nodeKey = node.getAttribute(keyAttribute) || "";
      nodeKey = type + nodeKey;
      var existing = cache.get(nodeKey);
      existing ? existing.push(node) : cache.set(nodeKey, [node]);
    }
  }
  return cache;
}
function mountHoistable(hoistableRoot, type, instance) {
  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
  hoistableRoot.head.insertBefore(
    instance,
    "title" === type ? hoistableRoot.querySelector("head > title") : null
  );
}
function isHostHoistableType(type, props, hostContext) {
  if (1 === hostContext || null != props.itemProp) return false;
  switch (type) {
    case "meta":
    case "title":
      return true;
    case "style":
      if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
        break;
      return true;
    case "link":
      if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
        break;
      switch (props.rel) {
        case "stylesheet":
          return type = props.disabled, "string" === typeof props.precedence && null == type;
        default:
          return true;
      }
    case "script":
      if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
        return true;
  }
  return false;
}
function preloadResource(resource) {
  return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
}
var suspendedState = null;
function noop() {
}
function suspendResource(hoistableRoot, resource, props) {
  if (null === suspendedState) throw Error(formatProdErrorMessage(475));
  var state = suspendedState;
  if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
    if (null === resource.instance) {
      var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
        getStylesheetSelectorFromKey(key)
      );
      if (instance) {
        hoistableRoot = instance._p;
        null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
        resource.state.loading |= 4;
        resource.instance = instance;
        markNodeAsHoistable(instance);
        return;
      }
      instance = hoistableRoot.ownerDocument || hoistableRoot;
      props = stylesheetPropsFromRawProps(props);
      (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
      instance = instance.createElement("link");
      markNodeAsHoistable(instance);
      var linkInstance = instance;
      linkInstance._p = new Promise(function(resolve, reject) {
        linkInstance.onload = resolve;
        linkInstance.onerror = reject;
      });
      setInitialProperties(instance, "link", props);
      resource.instance = instance;
    }
    null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
    state.stylesheets.set(resource, hoistableRoot);
    (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
  }
}
function waitForCommitToBeReady() {
  if (null === suspendedState) throw Error(formatProdErrorMessage(475));
  var state = suspendedState;
  state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
  return 0 < state.count ? function(commit) {
    var stylesheetTimer = setTimeout(function() {
      state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
      if (state.unsuspend) {
        var unsuspend = state.unsuspend;
        state.unsuspend = null;
        unsuspend();
      }
    }, 6e4);
    state.unsuspend = commit;
    return function() {
      state.unsuspend = null;
      clearTimeout(stylesheetTimer);
    };
  } : null;
}
function onUnsuspend() {
  this.count--;
  if (0 === this.count) {
    if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
    else if (this.unsuspend) {
      var unsuspend = this.unsuspend;
      this.unsuspend = null;
      unsuspend();
    }
  }
}
var precedencesByRoot = null;
function insertSuspendedStylesheets(state, resources) {
  state.stylesheets = null;
  null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
}
function insertStylesheetIntoRoot(root2, resource) {
  if (!(resource.state.loading & 4)) {
    var precedences = precedencesByRoot.get(root2);
    if (precedences) var last = precedences.get(null);
    else {
      precedences = /* @__PURE__ */ new Map();
      precedencesByRoot.set(root2, precedences);
      for (var nodes = root2.querySelectorAll(
        "link[data-precedence],style[data-precedence]"
      ), i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
          precedences.set(node.dataset.precedence, node), last = node;
      }
      last && precedences.set(null, last);
    }
    nodes = resource.instance;
    node = nodes.getAttribute("data-precedence");
    i = precedences.get(node) || last;
    i === last && precedences.set(null, nodes);
    precedences.set(node, nodes);
    this.count++;
    last = onUnsuspend.bind(this);
    nodes.addEventListener("load", last);
    nodes.addEventListener("error", last);
    i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
    resource.state.loading |= 4;
  }
}
var HostTransitionContext = {
  $$typeof: REACT_CONTEXT_TYPE,
  Provider: null,
  Consumer: null,
  _currentValue: sharedNotPendingObject,
  _currentValue2: sharedNotPendingObject,
  _threadCount: 0
};
function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
  this.tag = 1;
  this.containerInfo = containerInfo;
  this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
  this.callbackPriority = 0;
  this.expirationTimes = createLaneMap(-1);
  this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = createLaneMap(0);
  this.hiddenUpdates = createLaneMap(null);
  this.identifierPrefix = identifierPrefix;
  this.onUncaughtError = onUncaughtError;
  this.onCaughtError = onCaughtError;
  this.onRecoverableError = onRecoverableError;
  this.pooledCache = null;
  this.pooledCacheLanes = 0;
  this.formState = formState;
  this.incompleteTransitions = /* @__PURE__ */ new Map();
}
function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
  containerInfo = new FiberRootNode(
    containerInfo,
    tag,
    hydrate,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    formState
  );
  tag = 1;
  true === isStrictMode && (tag |= 24);
  isStrictMode = createFiberImplClass(3, null, null, tag);
  containerInfo.current = isStrictMode;
  isStrictMode.stateNode = containerInfo;
  tag = createCache();
  tag.refCount++;
  containerInfo.pooledCache = tag;
  tag.refCount++;
  isStrictMode.memoizedState = {
    element: initialChildren,
    isDehydrated: hydrate,
    cache: tag
  };
  initializeUpdateQueue(isStrictMode);
  return containerInfo;
}
function getContextForSubtree(parentComponent) {
  if (!parentComponent) return emptyContextObject;
  parentComponent = emptyContextObject;
  return parentComponent;
}
function updateContainerImpl(rootFiber, lane, element, container2, parentComponent, callback) {
  parentComponent = getContextForSubtree(parentComponent);
  null === container2.context ? container2.context = parentComponent : container2.pendingContext = parentComponent;
  container2 = createUpdate(lane);
  container2.payload = { element };
  callback = void 0 === callback ? null : callback;
  null !== callback && (container2.callback = callback);
  element = enqueueUpdate(rootFiber, container2, lane);
  null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
}
function markRetryLaneImpl(fiber, retryLane) {
  fiber = fiber.memoizedState;
  if (null !== fiber && null !== fiber.dehydrated) {
    var a = fiber.retryLane;
    fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
  }
}
function markRetryLaneIfNotHydrated(fiber, retryLane) {
  markRetryLaneImpl(fiber, retryLane);
  (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
}
function attemptContinuousHydration(fiber) {
  if (13 === fiber.tag) {
    var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
    null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
    markRetryLaneIfNotHydrated(fiber, 67108864);
  }
}
var _enabled = true;
function dispatchDiscreteEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
  var prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
  } finally {
    ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
  }
}
function dispatchContinuousEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
  var prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
  } finally {
    ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
  }
}
function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  if (_enabled) {
    var blockedOn = findInstanceBlockingEvent(nativeEvent);
    if (null === blockedOn)
      dispatchEventForPluginEventSystem(
        domEventName,
        eventSystemFlags,
        nativeEvent,
        return_targetInst,
        targetContainer
      ), clearIfContinuousEvent(domEventName, nativeEvent);
    else if (queueIfContinuousEvent(
      blockedOn,
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent
    ))
      nativeEvent.stopPropagation();
    else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
      for (; null !== blockedOn; ) {
        var fiber = getInstanceFromNode(blockedOn);
        if (null !== fiber)
          switch (fiber.tag) {
            case 3:
              fiber = fiber.stateNode;
              if (fiber.current.memoizedState.isDehydrated) {
                var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                if (0 !== lanes) {
                  var root2 = fiber;
                  root2.pendingLanes |= 2;
                  for (root2.entangledLanes |= 2; lanes; ) {
                    var lane = 1 << 31 - clz32(lanes);
                    root2.entanglements[1] |= lane;
                    lanes &= ~lane;
                  }
                  ensureRootIsScheduled(fiber);
                  0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0));
                }
              }
              break;
            case 13:
              root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
          }
        fiber = findInstanceBlockingEvent(nativeEvent);
        null === fiber && dispatchEventForPluginEventSystem(
          domEventName,
          eventSystemFlags,
          nativeEvent,
          return_targetInst,
          targetContainer
        );
        if (fiber === blockedOn) break;
        blockedOn = fiber;
      }
      null !== blockedOn && nativeEvent.stopPropagation();
    } else
      dispatchEventForPluginEventSystem(
        domEventName,
        eventSystemFlags,
        nativeEvent,
        null,
        targetContainer
      );
  }
}
function findInstanceBlockingEvent(nativeEvent) {
  nativeEvent = getEventTarget(nativeEvent);
  return findInstanceBlockingTarget(nativeEvent);
}
var return_targetInst = null;
function findInstanceBlockingTarget(targetNode) {
  return_targetInst = null;
  targetNode = getClosestInstanceFromNode(targetNode);
  if (null !== targetNode) {
    var nearestMounted = getNearestMountedFiber(targetNode);
    if (null === nearestMounted) targetNode = null;
    else {
      var tag = nearestMounted.tag;
      if (13 === tag) {
        targetNode = getSuspenseInstanceFromFiber(nearestMounted);
        if (null !== targetNode) return targetNode;
        targetNode = null;
      } else if (3 === tag) {
        if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
          return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
        targetNode = null;
      } else nearestMounted !== targetNode && (targetNode = null);
    }
  }
  return_targetInst = targetNode;
  return null;
}
function getEventPriority(domEventName) {
  switch (domEventName) {
    case "beforetoggle":
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "toggle":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 2;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 8;
    case "message":
      switch (getCurrentPriorityLevel()) {
        case ImmediatePriority:
          return 2;
        case UserBlockingPriority:
          return 8;
        case NormalPriority$1:
        case LowPriority:
          return 32;
        case IdlePriority:
          return 268435456;
        default:
          return 32;
      }
    default:
      return 32;
  }
}
var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
  " "
);
function clearIfContinuousEvent(domEventName, nativeEvent) {
  switch (domEventName) {
    case "focusin":
    case "focusout":
      queuedFocus = null;
      break;
    case "dragenter":
    case "dragleave":
      queuedDrag = null;
      break;
    case "mouseover":
    case "mouseout":
      queuedMouse = null;
      break;
    case "pointerover":
    case "pointerout":
      queuedPointers.delete(nativeEvent.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      queuedPointerCaptures.delete(nativeEvent.pointerId);
  }
}
function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
    return existingQueuedEvent = {
      blockedOn,
      domEventName,
      eventSystemFlags,
      nativeEvent,
      targetContainers: [targetContainer]
    }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
  blockedOn = existingQueuedEvent.targetContainers;
  null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
  return existingQueuedEvent;
}
function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  switch (domEventName) {
    case "focusin":
      return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
        queuedFocus,
        blockedOn,
        domEventName,
        eventSystemFlags,
        targetContainer,
        nativeEvent
      ), true;
    case "dragenter":
      return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
        queuedDrag,
        blockedOn,
        domEventName,
        eventSystemFlags,
        targetContainer,
        nativeEvent
      ), true;
    case "mouseover":
      return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
        queuedMouse,
        blockedOn,
        domEventName,
        eventSystemFlags,
        targetContainer,
        nativeEvent
      ), true;
    case "pointerover":
      var pointerId = nativeEvent.pointerId;
      queuedPointers.set(
        pointerId,
        accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedPointers.get(pointerId) || null,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )
      );
      return true;
    case "gotpointercapture":
      return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
        pointerId,
        accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedPointerCaptures.get(pointerId) || null,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )
      ), true;
  }
  return false;
}
function attemptExplicitHydrationTarget(queuedTarget) {
  var targetInst = getClosestInstanceFromNode(queuedTarget.target);
  if (null !== targetInst) {
    var nearestMounted = getNearestMountedFiber(targetInst);
    if (null !== nearestMounted) {
      if (targetInst = nearestMounted.tag, 13 === targetInst) {
        if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
          queuedTarget.blockedOn = targetInst;
          runWithPriority(queuedTarget.priority, function() {
            if (13 === nearestMounted.tag) {
              var lane = requestUpdateLane();
              lane = getBumpedLaneForHydrationByLane(lane);
              var root2 = enqueueConcurrentRenderForLane(nearestMounted, lane);
              null !== root2 && scheduleUpdateOnFiber(root2, nearestMounted, lane);
              markRetryLaneIfNotHydrated(nearestMounted, lane);
            }
          });
          return;
        }
      } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
        queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
        return;
      }
    }
  }
  queuedTarget.blockedOn = null;
}
function attemptReplayContinuousQueuedEvent(queuedEvent) {
  if (null !== queuedEvent.blockedOn) return false;
  for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
    var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
    if (null === nextBlockedOn) {
      nextBlockedOn = queuedEvent.nativeEvent;
      var nativeEventClone = new nextBlockedOn.constructor(
        nextBlockedOn.type,
        nextBlockedOn
      );
      currentReplayingEvent = nativeEventClone;
      nextBlockedOn.target.dispatchEvent(nativeEventClone);
      currentReplayingEvent = null;
    } else
      return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
    targetContainers.shift();
  }
  return true;
}
function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
  attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
}
function replayUnblockedEvents() {
  hasScheduledReplayAttempt = false;
  null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
  null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
  null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
}
function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
  queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
    Scheduler.unstable_NormalPriority,
    replayUnblockedEvents
  )));
}
var lastScheduledReplayQueue = null;
function scheduleReplayQueueIfNeeded(formReplayingQueue) {
  lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
    Scheduler.unstable_NormalPriority,
    function() {
      lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
      for (var i = 0; i < formReplayingQueue.length; i += 3) {
        var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
        if ("function" !== typeof submitterOrAction)
          if (null === findInstanceBlockingTarget(submitterOrAction || form))
            continue;
          else break;
        var formInst = getInstanceFromNode(form);
        null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(
          formInst,
          {
            pending: true,
            data: formData,
            method: form.method,
            action: submitterOrAction
          },
          submitterOrAction,
          formData
        ));
      }
    }
  ));
}
function retryIfBlockedOn(unblocked) {
  function unblock(queuedEvent) {
    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
  }
  null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
  null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
  null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
  queuedPointers.forEach(unblock);
  queuedPointerCaptures.forEach(unblock);
  for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
    var queuedTarget = queuedExplicitHydrationTargets[i];
    queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
  }
  for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
    attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
  i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
  if (null != i)
    for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
      var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
      if ("function" === typeof submitterOrAction)
        formProps || scheduleReplayQueueIfNeeded(i);
      else if (formProps) {
        var action = null;
        if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
          if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
            action = formProps.formAction;
          else {
            if (null !== findInstanceBlockingTarget(form)) continue;
          }
        else action = formProps.action;
        "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
        scheduleReplayQueueIfNeeded(i);
      }
    }
}
function ReactDOMRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
  var root2 = this._internalRoot;
  if (null === root2) throw Error(formatProdErrorMessage(409));
  var current = root2.current, lane = requestUpdateLane();
  updateContainerImpl(current, lane, children, root2, null, null);
};
ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
  var root2 = this._internalRoot;
  if (null !== root2) {
    this._internalRoot = null;
    var container2 = root2.containerInfo;
    updateContainerImpl(root2.current, 2, null, root2, null, null);
    flushSyncWork$1();
    container2[internalContainerInstanceKey] = null;
  }
};
function ReactDOMHydrationRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
  if (target) {
    var updatePriority = resolveUpdatePriority();
    target = { blockedOn: null, target, priority: updatePriority };
    for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
    queuedExplicitHydrationTargets.splice(i, 0, target);
    0 === i && attemptExplicitHydrationTarget(target);
  }
};
var isomorphicReactPackageVersion$jscomp$inline_1785 = React.version;
if ("19.1.1" !== isomorphicReactPackageVersion$jscomp$inline_1785)
  throw Error(
    formatProdErrorMessage(
      527,
      isomorphicReactPackageVersion$jscomp$inline_1785,
      "19.1.1"
    )
  );
ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
  var fiber = componentOrElement._reactInternals;
  if (void 0 === fiber) {
    if ("function" === typeof componentOrElement.render)
      throw Error(formatProdErrorMessage(188));
    componentOrElement = Object.keys(componentOrElement).join(",");
    throw Error(formatProdErrorMessage(268, componentOrElement));
  }
  componentOrElement = findCurrentFiberUsingSlowPath(fiber);
  componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
  componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
  return componentOrElement;
};
var internals$jscomp$inline_2256 = {
  bundleType: 0,
  version: "19.1.1",
  rendererPackageName: "react-dom",
  currentDispatcherRef: ReactSharedInternals,
  reconcilerVersion: "19.1.1"
};
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!hook$jscomp$inline_2257.isDisabled && hook$jscomp$inline_2257.supportsFiber)
    try {
      rendererID = hook$jscomp$inline_2257.inject(
        internals$jscomp$inline_2256
      ), injectedHook = hook$jscomp$inline_2257;
    } catch (err) {
    }
}
reactDomClient_production.createRoot = function(container2, options) {
  if (!isValidContainer(container2)) throw Error(formatProdErrorMessage(299));
  var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
  null !== options && void 0 !== options && (true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks));
  options = createFiberRoot(
    container2,
    1,
    false,
    null,
    null,
    isStrictMode,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    transitionCallbacks,
    null
  );
  container2[internalContainerInstanceKey] = options.current;
  listenToAllSupportedEvents(container2);
  return new ReactDOMRoot(options);
};
reactDomClient_production.hydrateRoot = function(container2, initialChildren, options) {
  if (!isValidContainer(container2)) throw Error(formatProdErrorMessage(299));
  var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
  null !== options && void 0 !== options && (true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks), void 0 !== options.formState && (formState = options.formState));
  initialChildren = createFiberRoot(
    container2,
    1,
    true,
    initialChildren,
    null != options ? options : null,
    isStrictMode,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    transitionCallbacks,
    formState
  );
  initialChildren.context = getContextForSubtree(null);
  options = initialChildren.current;
  isStrictMode = requestUpdateLane();
  isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
  identifierPrefix = createUpdate(isStrictMode);
  identifierPrefix.callback = null;
  enqueueUpdate(options, identifierPrefix, isStrictMode);
  options = isStrictMode;
  initialChildren.current.lanes = options;
  markRootUpdated$1(initialChildren, options);
  ensureRootIsScheduled(initialChildren);
  container2[internalContainerInstanceKey] = initialChildren.current;
  listenToAllSupportedEvents(container2);
  return new ReactDOMHydrationRoot(initialChildren);
};
reactDomClient_production.version = "19.1.1";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  client.exports = reactDomClient_production;
}
var clientExports = client.exports;
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o, r, i = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
var _excluded$1y = ["size", "className", "fill"];
var Play = function Play2(_ref) {
  var _ref$size = _ref.size, size = _ref$size === void 0 ? 24 : _ref$size, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className, _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "none" : _ref$fill, otherProps = _objectWithoutProperties(_ref, _excluded$1y);
  return /* @__PURE__ */ React$2.createElement("svg", _extends({
    width: size,
    height: size,
    viewBox: "0 0 24 24",
    fill,
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    className: "feather feather-play ".concat(className)
  }, otherProps), /* @__PURE__ */ React$2.createElement("g", null, /* @__PURE__ */ React$2.createElement("polygon", {
    points: "5 3 19 12 5 21 5 3"
  })));
};
var _excluded$1q = ["size", "className", "fill"];
var RefreshCcw = function RefreshCcw2(_ref) {
  var _ref$size = _ref.size, size = _ref$size === void 0 ? 24 : _ref$size, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className, _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "none" : _ref$fill, otherProps = _objectWithoutProperties(_ref, _excluded$1q);
  return /* @__PURE__ */ React$2.createElement("svg", _extends({
    width: size,
    height: size,
    viewBox: "0 0 24 24",
    fill,
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    className: "feather feather-refresh-ccw ".concat(className)
  }, otherProps), /* @__PURE__ */ React$2.createElement("g", null, /* @__PURE__ */ React$2.createElement("polyline", {
    points: "1 4 1 10 7 10"
  }), /* @__PURE__ */ React$2.createElement("polyline", {
    points: "23 20 23 14 17 14"
  }), /* @__PURE__ */ React$2.createElement("path", {
    d: "M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"
  })));
};
const container$2 = "_container_13y4s_1";
const area = "_area_13y4s_9";
const toolbar$1 = "_toolbar_13y4s_14";
const classes$6 = {
  container: container$2,
  area,
  toolbar: toolbar$1
};
function combinePos(a, b) {
  if (a === INTERNAL || b === INTERNAL) {
    return INTERNAL;
  }
  let lin1, col1, lin2, col2;
  if (a.lin1 < b.lin1) {
    lin1 = a.lin1;
    col1 = a.col1;
  } else if (b.lin1 < a.lin1) {
    lin1 = b.lin1;
    col1 = b.col1;
  } else {
    lin1 = a.lin1;
    col1 = Math.min(a.col1, b.col1);
  }
  if (a.lin2 > b.lin2) {
    lin2 = a.lin2;
    col2 = a.col2;
  } else if (b.lin2 > a.lin2) {
    lin2 = b.lin2;
    col2 = b.col2;
  } else {
    lin2 = a.lin2;
    col2 = Math.max(a.col2, b.col2);
  }
  return { lin1, col1, lin2, col2 };
}
function fallbackPos(t, tBefore) {
  return {
    lin1: (t == null ? void 0 : t.lin1) ?? tBefore.lin2,
    col1: (t == null ? void 0 : t.col1) ?? tBefore.col2,
    lin2: (t == null ? void 0 : t.lin2) ?? tBefore.lin2,
    col2: (t == null ? void 0 : t.col2) ?? tBefore.col2
  };
}
const INTERNAL = Object.freeze({
  lin1: 0,
  col1: 0,
  lin2: 0,
  col2: 0
});
class Base {
  constructor(pos) {
    this.pos = pos;
  }
  static toString(token) {
    return (token == null ? void 0 : token.toString()) ?? "nothing";
  }
  debugPrint(out, prefix2) {
    if (this.pos === INTERNAL) {
      out.push(`!!${this.constructor.name}
`);
    } else {
      out.push(`!!${this.constructor.name} # ${this.pos.lin1}:${this.pos.col1}-${this.pos.lin2}:${this.pos.col2}
`);
    }
  }
}
const ERROR = 2;
const INVALID = 1;
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload2(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep, importerUrl);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        const isBaseRelative = !!importerUrl;
        if (isBaseRelative) {
          for (let i = links.length - 1; i >= 0; i--) {
            const link2 = links[i];
            if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
              return;
            }
          }
        } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e = new Event("vite:preloadError", {
      cancelable: true
    });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item2 of res || []) {
      if (item2.status !== "rejected") continue;
      handlePreloadError(item2.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
const beanDeclarations = () => [
  __vitePreload(() => import("./_beans-CfCNPWRd.js"), true ? __vite__mapDeps([0,1,2]) : void 0, import.meta.url),
  __vitePreload(() => import("./_beans-BUNWTXnV.js"), true ? __vite__mapDeps([3,4,5,6,7,8]) : void 0, import.meta.url),
  __vitePreload(() => import("./_beans-CyXv1buW.js"), true ? __vite__mapDeps([9,2,4,5,6,7,10,11]) : void 0, import.meta.url),
  __vitePreload(() => import("./_beans-DrWhs8Lt.js"), true ? __vite__mapDeps([12,13]) : void 0, import.meta.url),
  __vitePreload(() => import("./_beans-CM3-gej0.js"), true ? __vite__mapDeps([14,1,2,15,10,16,17]) : void 0, import.meta.url),
  __vitePreload(() => import("./_beans-DKlJfwLP.js"), true ? __vite__mapDeps([18,1,2,4,5,6,7,8,15,19,10,20,21,11]) : void 0, import.meta.url),
  __vitePreload(() => import("./_beans-BKorO9SS.js"), true ? __vite__mapDeps([22,4,5,6,8,11]) : void 0, import.meta.url),
  __vitePreload(() => import("./_beans-D5qDzQp1.js"), true ? __vite__mapDeps([23,19,10,24]) : void 0, import.meta.url),
  __vitePreload(() => import("./_beans-B71FwR43.js"), true ? __vite__mapDeps([25,16]) : void 0, import.meta.url),
  __vitePreload(() => import("./_beans-C8msONes.js"), true ? __vite__mapDeps([26,5,6,20]) : void 0, import.meta.url),
  __vitePreload(() => import("./_beans-BSqjJ_Ny.js"), true ? __vite__mapDeps([27,24]) : void 0, import.meta.url),
  __vitePreload(() => import("./_beans-CLdlX0cW.js"), true ? __vite__mapDeps([28,21,11]) : void 0, import.meta.url),
  __vitePreload(() => import("./_beans-RJm3-CdN.js"), true ? __vite__mapDeps([29,6,7,19,10,17]) : void 0, import.meta.url)
];
let declareAllBeansPromise;
function declareAllBeans() {
  if (declareAllBeansPromise) {
    return declareAllBeansPromise;
  }
  return declareAllBeansPromise = Promise.all(beanDeclarations()).then(
    (imports) => imports.forEach((m) => m.declareBeans())
  );
}
class Bean {
}
function declareBeanInterface(name) {
  return { key: Symbol(name) };
}
function list(i) {
  return {
    load: (loader) => {
      const containers = registry[i.key] ?? {};
      for (const name in containers) {
        loader.load(containers[name]);
      }
    },
    resolve: () => {
      const containers = registry[i.key] ?? {};
      return Object.keys(containers).map((name) => internalGetBean(containers[name])).sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));
    }
  };
}
function one(i, name) {
  return {
    load: (loader) => {
      var _a;
      if (name) {
        const container2 = (_a = registry[i.key] ?? {}) == null ? void 0 : _a[name];
        if (container2) {
          loader.load(container2);
        }
      } else {
        const containers = registry[i.key] ?? {};
        for (const name2 in containers) {
          loader.load(containers[name2]);
        }
      }
    },
    resolve: () => {
      var _a;
      if (name) {
        const container2 = (_a = registry[i.key] ?? {}) == null ? void 0 : _a[name];
        return container2 ? internalGetBean(container2) : null;
      } else {
        const containers = registry[i.key] ?? {};
        const names = Object.keys(containers);
        if (names.length > 1) {
          throw new Error(
            `Several beans declared for interface '${i.key.description}' ('${names.join(
              `', '`
            )}') but one has been requested.`
          );
        }
        return internalGetBean(containers[names[0]]);
      }
    }
  };
}
function single(i, name) {
  const { load, resolve } = one(i, name);
  return {
    load,
    resolve() {
      const result = resolve();
      if (!result) {
        throw new Error(`No beans declared for interface '${i.key.description}'${name ? ` and name '${name}'` : ""}`);
      }
      return result;
    }
  };
}
async function loadAndResolve(spec) {
  const loader = new BeanLoader();
  spec.load(loader);
  await loader.getPromise();
  return spec.resolve();
}
const registry = {};
class BeanLoader {
  constructor() {
    this.promises = [];
    this.processedBCs = /* @__PURE__ */ new Set();
  }
  load(bc) {
    if (this.processedBCs.has(bc.key)) {
      return;
    }
    this.processedBCs.add(bc.key);
    if (!bc.module) {
      if (!bc.loadModulePromise) {
        console.log(`Loading "${bc.name}"...`);
        bc.loadModulePromise = (async () => {
          await Promise.resolve();
          bc.module = await bc.loadModule();
        })();
      }
      this.promises.push(bc.loadModulePromise);
    }
    for (const dep of bc.dependencies) {
      dep.load(this);
    }
  }
  getPromise() {
    return Promise.all(this.promises);
  }
}
function internalGetBean(bc) {
  if (bc.bean) {
    return bc.bean;
  }
  const dst = bc.bean = {};
  const src = bc.factory(
    bc.module,
    bc.dependencies.map((dep) => dep.resolve())
  );
  Object.setPrototypeOf(dst, Object.getPrototypeOf(src));
  Object.defineProperties(dst, Object.getOwnPropertyDescriptors(src));
  return bc.bean;
}
async function getOneBean(i, name) {
  return await loadAndResolve(one(i, name));
}
async function getSingleBean(i, name) {
  return await loadAndResolve(single(i, name));
}
function declareBean({
  name,
  provides,
  dependencies,
  loadModule,
  factory
}) {
  const bc = {
    name,
    key: Symbol(),
    dependencies,
    loadModule,
    factory
  };
  for (const provide of provides) {
    let registryKey = registry[provide.key];
    if (!registryKey) {
      registry[provide.key] = registryKey = {};
    }
    if (registryKey[name]) {
      throw new Error(`Bean with interface '${provide.key.description}' and name '${name}' already declared`);
    }
    registryKey[name] = bc;
  }
}
const codegen = declareBeanInterface("Codegen");
class ModuleInput {
  constructor(name, sourceCode) {
    this.name = name;
    this.sourceCode = sourceCode;
  }
}
const parser = declareBeanInterface("Parser");
async function compile(sourceCode, { debugTree }) {
  await declareAllBeans();
  const _parser = await getSingleBean(parser);
  const _codegen = await getSingleBean(codegen);
  const errors = [];
  const out = [];
  let p;
  try {
    p = await _parser.parse([new ModuleInput("main", sourceCode)]);
    errors.push(...p.errors);
  } catch (err) {
    errors.push({ level: ERROR, message: err.stack, pos: INTERNAL });
  }
  let codegenOutput = "";
  if (errors.length === 0) {
    try {
      codegenOutput = _codegen.generateCode(p.application);
    } catch (err) {
      errors.push({ level: ERROR, message: err.stack, pos: INTERNAL });
    }
  }
  let codegenPrettyOutput = "";
  if (codegenOutput) {
    codegenPrettyOutput = `function app(args) {
  ${codegenOutput.replaceAll("\n", "\n  ").trimEnd()}
}
`;
  }
  if (errors.length === 0) {
    out.push("# Compile successful!\n");
  } else {
    out.push("# Compile errors:\n");
    errors.forEach(
      (item2) => out.push(
        `- ${item2.pos !== INTERNAL ? `[${item2.pos.lin1}:${item2.pos.col1}-${item2.pos.lin2}:${item2.pos.col2}] ` : ""}${item2.message}
`
      )
    );
  }
  if (p) {
    out.push("---\n");
    out.push("ParserResult:\n");
    Object.values(p.application.symbols).forEach((s) => {
      out.push("- ");
      s.debugPrint(out, "  ");
    });
  }
  return {
    errors,
    parserOutput: out.join(""),
    codegenOutput,
    codegenPrettyOutput
  };
}
const toolButton = "_toolButton_1dqrl_1";
const classes$5 = {
  toolButton
};
function ToolButton({
  text,
  icon: FeatherIcon,
  variant = "normal",
  onClick
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classes$5.toolButton, "data-variant": variant, onClick, children: [
    FeatherIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(FeatherIcon, { style: { marginLeft: -4 }, size: 20 }),
    text
  ] });
}
const toolbar = "_toolbar_1mvp9_1";
const classes$4 = {
  toolbar
};
function Toolbar({ children, className = "" }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${classes$4.toolbar} ${className}`, children });
}
var ace$1 = { exports: {} };
(function(module, exports) {
  (function() {
    var ACE_NAMESPACE = "ace";
    var global = /* @__PURE__ */ function() {
      return this;
    }();
    if (!global && typeof window != "undefined") global = window;
    var define = function(module2, deps, payload) {
      if (typeof module2 !== "string") {
        if (define.original)
          define.original.apply(this, arguments);
        else {
          console.error("dropping module because define wasn't a string.");
          console.trace();
        }
        return;
      }
      if (arguments.length == 2)
        payload = deps;
      if (!define.modules[module2]) {
        define.payloads[module2] = payload;
        define.modules[module2] = null;
      }
    };
    define.modules = {};
    define.payloads = {};
    var _require = function(parentId, module2, callback) {
      if (typeof module2 === "string") {
        var payload = lookup(parentId, module2);
        if (payload != void 0) {
          callback && callback();
          return payload;
        }
      } else if (Object.prototype.toString.call(module2) === "[object Array]") {
        var params = [];
        for (var i = 0, l = module2.length; i < l; ++i) {
          var dep = lookup(parentId, module2[i]);
          if (dep == void 0 && require2.original)
            return;
          params.push(dep);
        }
        return callback && callback.apply(null, params) || true;
      }
    };
    var require2 = function(module2, callback) {
      var packagedModule = _require("", module2, callback);
      if (packagedModule == void 0 && require2.original)
        return require2.original.apply(this, arguments);
      return packagedModule;
    };
    var normalizeModule = function(parentId, moduleName) {
      if (moduleName.indexOf("!") !== -1) {
        var chunks = moduleName.split("!");
        return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
      }
      if (moduleName.charAt(0) == ".") {
        var base = parentId.split("/").slice(0, -1).join("/");
        moduleName = base + "/" + moduleName;
        while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
          var previous = moduleName;
          moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
        }
      }
      return moduleName;
    };
    var lookup = function(parentId, moduleName) {
      moduleName = normalizeModule(parentId, moduleName);
      var module2 = define.modules[moduleName];
      if (!module2) {
        module2 = define.payloads[moduleName];
        if (typeof module2 === "function") {
          var exports2 = {};
          var mod = {
            id: moduleName,
            uri: "",
            exports: exports2,
            packaged: true
          };
          var req = function(module3, callback) {
            return _require(moduleName, module3, callback);
          };
          var returnValue = module2(req, exports2, mod);
          exports2 = returnValue || mod.exports;
          define.modules[moduleName] = exports2;
          delete define.payloads[moduleName];
        }
        module2 = define.modules[moduleName] = exports2 || module2;
      }
      return module2;
    };
    function exportAce(ns) {
      var root2 = global;
      {
        if (!global[ns])
          global[ns] = {};
        root2 = global[ns];
      }
      if (!root2.define || !root2.define.packaged) {
        define.original = root2.define;
        root2.define = define;
        root2.define.packaged = true;
      }
      if (!root2.require || !root2.require.packaged) {
        require2.original = root2.require;
        root2.require = require2;
        root2.require.packaged = true;
      }
    }
    exportAce(ACE_NAMESPACE);
  })();
  ace.define("ace/lib/es6-shim", ["require", "exports", "module"], function(require2, exports2, module2) {
    function defineProp(obj, name, val) {
      Object.defineProperty(obj, name, {
        value: val,
        enumerable: false,
        writable: true,
        configurable: true
      });
    }
    if (!String.prototype.startsWith) {
      defineProp(String.prototype, "startsWith", function(searchString, position) {
        position = position || 0;
        return this.lastIndexOf(searchString, position) === position;
      });
    }
    if (!String.prototype.endsWith) {
      defineProp(String.prototype, "endsWith", function(searchString, position) {
        var subjectString = this;
        if (position === void 0 || position > subjectString.length) {
          position = subjectString.length;
        }
        position -= searchString.length;
        var lastIndex = subjectString.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
      });
    }
    if (!String.prototype.repeat) {
      defineProp(String.prototype, "repeat", function(count) {
        var result = "";
        var string = this;
        while (count > 0) {
          if (count & 1)
            result += string;
          if (count >>= 1)
            string += string;
        }
        return result;
      });
    }
    if (!String.prototype.includes) {
      defineProp(String.prototype, "includes", function(str, position) {
        return this.indexOf(str, position) != -1;
      });
    }
    if (!Object.assign) {
      Object.assign = function(target) {
        if (target === void 0 || target === null) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        var output = Object(target);
        for (var index2 = 1; index2 < arguments.length; index2++) {
          var source = arguments[index2];
          if (source !== void 0 && source !== null) {
            Object.keys(source).forEach(function(key) {
              output[key] = source[key];
            });
          }
        }
        return output;
      };
    }
    if (!Object.values) {
      Object.values = function(o) {
        return Object.keys(o).map(function(k) {
          return o[k];
        });
      };
    }
    if (!Array.prototype.find) {
      defineProp(Array.prototype, "find", function(predicate) {
        var len = this.length;
        var thisArg = arguments[1];
        for (var k = 0; k < len; k++) {
          var kValue = this[k];
          if (predicate.call(thisArg, kValue, k, this)) {
            return kValue;
          }
        }
      });
    }
    if (!Array.prototype.findIndex) {
      defineProp(Array.prototype, "findIndex", function(predicate) {
        var len = this.length;
        var thisArg = arguments[1];
        for (var k = 0; k < len; k++) {
          var kValue = this[k];
          if (predicate.call(thisArg, kValue, k, this)) {
            return k;
          }
        }
      });
    }
    if (!Array.prototype.includes) {
      defineProp(Array.prototype, "includes", function(item2, position) {
        return this.indexOf(item2, position) != -1;
      });
    }
    if (!Array.prototype.fill) {
      defineProp(Array.prototype, "fill", function(value) {
        var O = this;
        var len = O.length >>> 0;
        var start = arguments[1];
        var relativeStart = start >> 0;
        var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
        var end = arguments[2];
        var relativeEnd = end === void 0 ? len : end >> 0;
        var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
        while (k < final) {
          O[k] = value;
          k++;
        }
        return O;
      });
    }
    if (!Array.of) {
      defineProp(Array, "of", function() {
        return Array.prototype.slice.call(arguments);
      });
    }
  });
  ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module", "ace/lib/es6-shim"], function(require2, exports2, module2) {
    require2("./es6-shim");
  });
  ace.define("ace/lib/deep_copy", ["require", "exports", "module"], function(require2, exports2, module2) {
    exports2.deepCopy = function deepCopy(obj) {
      if (typeof obj !== "object" || !obj)
        return obj;
      var copy;
      if (Array.isArray(obj)) {
        copy = [];
        for (var key = 0; key < obj.length; key++) {
          copy[key] = deepCopy(obj[key]);
        }
        return copy;
      }
      if (Object.prototype.toString.call(obj) !== "[object Object]")
        return obj;
      copy = {};
      for (var key in obj)
        copy[key] = deepCopy(obj[key]);
      return copy;
    };
  });
  ace.define("ace/lib/lang", ["require", "exports", "module", "ace/lib/deep_copy"], function(require2, exports2, module2) {
    exports2.last = function(a) {
      return a[a.length - 1];
    };
    exports2.stringReverse = function(string) {
      return string.split("").reverse().join("");
    };
    exports2.stringRepeat = function(string, count) {
      var result = "";
      while (count > 0) {
        if (count & 1)
          result += string;
        if (count >>= 1)
          string += string;
      }
      return result;
    };
    var trimBeginRegexp = /^\s\s*/;
    var trimEndRegexp = /\s\s*$/;
    exports2.stringTrimLeft = function(string) {
      return string.replace(trimBeginRegexp, "");
    };
    exports2.stringTrimRight = function(string) {
      return string.replace(trimEndRegexp, "");
    };
    exports2.copyObject = function(obj) {
      var copy = {};
      for (var key in obj) {
        copy[key] = obj[key];
      }
      return copy;
    };
    exports2.copyArray = function(array) {
      var copy = [];
      for (var i = 0, l = array.length; i < l; i++) {
        if (array[i] && typeof array[i] == "object")
          copy[i] = this.copyObject(array[i]);
        else
          copy[i] = array[i];
      }
      return copy;
    };
    exports2.deepCopy = require2("./deep_copy").deepCopy;
    exports2.arrayToMap = function(arr) {
      var map = {};
      for (var i = 0; i < arr.length; i++) {
        map[arr[i]] = 1;
      }
      return map;
    };
    exports2.createMap = function(props) {
      var map = /* @__PURE__ */ Object.create(null);
      for (var i in props) {
        map[i] = props[i];
      }
      return map;
    };
    exports2.arrayRemove = function(array, value) {
      for (var i = 0; i <= array.length; i++) {
        if (value === array[i]) {
          array.splice(i, 1);
        }
      }
    };
    exports2.escapeRegExp = function(str) {
      return str.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
    };
    exports2.escapeHTML = function(str) {
      return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
    };
    exports2.getMatchOffsets = function(string, regExp) {
      var matches = [];
      string.replace(regExp, function(str) {
        matches.push({
          offset: arguments[arguments.length - 2],
          length: str.length
        });
      });
      return matches;
    };
    exports2.deferredCall = function(fcn) {
      var timer = null;
      var callback = function() {
        timer = null;
        fcn();
      };
      var deferred = function(timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
      };
      deferred.schedule = deferred;
      deferred.call = function() {
        this.cancel();
        fcn();
        return deferred;
      };
      deferred.cancel = function() {
        clearTimeout(timer);
        timer = null;
        return deferred;
      };
      deferred.isPending = function() {
        return timer;
      };
      return deferred;
    };
    exports2.delayedCall = function(fcn, defaultTimeout) {
      var timer = null;
      var callback = function() {
        timer = null;
        fcn();
      };
      var _self = function(timeout) {
        if (timer == null)
          timer = setTimeout(callback, timeout || defaultTimeout);
      };
      _self.delay = function(timeout) {
        timer && clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
      };
      _self.schedule = _self;
      _self.call = function() {
        this.cancel();
        fcn();
      };
      _self.cancel = function() {
        timer && clearTimeout(timer);
        timer = null;
      };
      _self.isPending = function() {
        return timer;
      };
      return _self;
    };
    exports2.supportsLookbehind = function() {
      try {
        new RegExp("(?<=.)");
      } catch (e) {
        return false;
      }
      return true;
    };
    exports2.skipEmptyMatch = function(line, last, supportsUnicodeFlag) {
      return supportsUnicodeFlag && line.codePointAt(last) > 65535 ? 2 : 1;
    };
  });
  ace.define("ace/lib/useragent", ["require", "exports", "module"], function(require2, exports2, module2) {
    exports2.OS = {
      LINUX: "LINUX",
      MAC: "MAC",
      WINDOWS: "WINDOWS"
    };
    exports2.getOS = function() {
      if (exports2.isMac) {
        return exports2.OS.MAC;
      } else if (exports2.isLinux) {
        return exports2.OS.LINUX;
      } else {
        return exports2.OS.WINDOWS;
      }
    };
    var _navigator = typeof navigator == "object" ? navigator : {};
    var os = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
    var ua = _navigator.userAgent || "";
    var appName = _navigator.appName || "";
    exports2.isWin = os == "win";
    exports2.isMac = os == "mac";
    exports2.isLinux = os == "linux";
    exports2.isIE = appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]);
    exports2.isOldIE = exports2.isIE && exports2.isIE < 9;
    exports2.isGecko = exports2.isMozilla = ua.match(/ Gecko\/\d+/);
    exports2.isOpera = typeof opera == "object" && Object.prototype.toString.call(window["opera"]) == "[object Opera]";
    exports2.isWebKit = parseFloat(ua.split("WebKit/")[1]) || void 0;
    exports2.isChrome = parseFloat(ua.split(" Chrome/")[1]) || void 0;
    exports2.isSafari = parseFloat(ua.split(" Safari/")[1]) && !exports2.isChrome || void 0;
    exports2.isEdge = parseFloat(ua.split(" Edge/")[1]) || void 0;
    exports2.isAIR = ua.indexOf("AdobeAIR") >= 0;
    exports2.isAndroid = ua.indexOf("Android") >= 0;
    exports2.isChromeOS = ua.indexOf(" CrOS ") >= 0;
    exports2.isIOS = /iPad|iPhone|iPod/.test(ua) && !window["MSStream"];
    if (exports2.isIOS)
      exports2.isMac = true;
    exports2.isMobile = exports2.isIOS || exports2.isAndroid;
  });
  ace.define("ace/lib/dom", ["require", "exports", "module", "ace/lib/useragent"], function(require2, exports2, module2) {
    var useragent = require2("./useragent");
    var XHTML_NS = "http://www.w3.org/1999/xhtml";
    exports2.buildDom = function buildDom(arr, parent, refs) {
      if (typeof arr == "string" && arr) {
        var txt = document.createTextNode(arr);
        if (parent)
          parent.appendChild(txt);
        return txt;
      }
      if (!Array.isArray(arr)) {
        if (arr && arr.appendChild && parent)
          parent.appendChild(arr);
        return arr;
      }
      if (typeof arr[0] != "string" || !arr[0]) {
        var els = [];
        for (var i = 0; i < arr.length; i++) {
          var ch = buildDom(arr[i], parent, refs);
          ch && els.push(ch);
        }
        return els;
      }
      var el = document.createElement(arr[0]);
      var options = arr[1];
      var childIndex = 1;
      if (options && typeof options == "object" && !Array.isArray(options))
        childIndex = 2;
      for (var i = childIndex; i < arr.length; i++)
        buildDom(arr[i], el, refs);
      if (childIndex == 2) {
        Object.keys(options).forEach(function(n) {
          var val = options[n];
          if (n === "class") {
            el.className = Array.isArray(val) ? val.join(" ") : val;
          } else if (typeof val == "function" || n == "value" || n[0] == "$") {
            el[n] = val;
          } else if (n === "ref") {
            if (refs)
              refs[val] = el;
          } else if (n === "style") {
            if (typeof val == "string")
              el.style.cssText = val;
          } else if (val != null) {
            el.setAttribute(n, val);
          }
        });
      }
      if (parent)
        parent.appendChild(el);
      return el;
    };
    exports2.getDocumentHead = function(doc) {
      if (!doc)
        doc = document;
      return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
    };
    exports2.createElement = function(tag, ns) {
      return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
    };
    exports2.removeChildren = function(element) {
      element.innerHTML = "";
    };
    exports2.createTextNode = function(textContent, element) {
      var doc = element ? element.ownerDocument : document;
      return doc.createTextNode(textContent);
    };
    exports2.createFragment = function(element) {
      var doc = element ? element.ownerDocument : document;
      return doc.createDocumentFragment();
    };
    exports2.hasCssClass = function(el, name) {
      var classes2 = (el.className + "").split(/\s+/g);
      return classes2.indexOf(name) !== -1;
    };
    exports2.addCssClass = function(el, name) {
      if (!exports2.hasCssClass(el, name)) {
        el.className += " " + name;
      }
    };
    exports2.removeCssClass = function(el, name) {
      var classes2 = el.className.split(/\s+/g);
      while (true) {
        var index2 = classes2.indexOf(name);
        if (index2 == -1) {
          break;
        }
        classes2.splice(index2, 1);
      }
      el.className = classes2.join(" ");
    };
    exports2.toggleCssClass = function(el, name) {
      var classes2 = el.className.split(/\s+/g), add = true;
      while (true) {
        var index2 = classes2.indexOf(name);
        if (index2 == -1) {
          break;
        }
        add = false;
        classes2.splice(index2, 1);
      }
      if (add)
        classes2.push(name);
      el.className = classes2.join(" ");
      return add;
    };
    exports2.setCssClass = function(node, className, include) {
      if (include) {
        exports2.addCssClass(node, className);
      } else {
        exports2.removeCssClass(node, className);
      }
    };
    exports2.hasCssString = function(id2, doc) {
      var index2 = 0, sheets;
      doc = doc || document;
      if (sheets = doc.querySelectorAll("style")) {
        while (index2 < sheets.length) {
          if (sheets[index2++].id === id2) {
            return true;
          }
        }
      }
    };
    exports2.removeElementById = function(id2, doc) {
      doc = doc || document;
      if (doc.getElementById(id2)) {
        doc.getElementById(id2).remove();
      }
    };
    var strictCSP;
    var cssCache = [];
    exports2.useStrictCSP = function(value) {
      strictCSP = value;
      if (value == false)
        insertPendingStyles();
      else if (!cssCache)
        cssCache = [];
    };
    function insertPendingStyles() {
      var cache = cssCache;
      cssCache = null;
      cache && cache.forEach(function(item2) {
        importCssString(item2[0], item2[1]);
      });
    }
    function importCssString(cssText, id2, target) {
      if (typeof document == "undefined")
        return;
      if (cssCache) {
        if (target) {
          insertPendingStyles();
        } else if (target === false) {
          return cssCache.push([cssText, id2]);
        }
      }
      if (strictCSP)
        return;
      var container2 = target;
      if (!target || !target.getRootNode) {
        container2 = document;
      } else {
        container2 = target.getRootNode();
        if (!container2 || container2 == target)
          container2 = document;
      }
      var doc = container2.ownerDocument || container2;
      if (id2 && exports2.hasCssString(id2, container2))
        return null;
      if (id2)
        cssText += "\n/*# sourceURL=ace/css/" + id2 + " */";
      var style2 = exports2.createElement("style");
      style2.appendChild(doc.createTextNode(cssText));
      if (id2)
        style2.id = id2;
      if (container2 == doc)
        container2 = exports2.getDocumentHead(doc);
      container2.insertBefore(style2, container2.firstChild);
    }
    exports2.importCssString = importCssString;
    exports2.importCssStylsheet = function(uri, doc) {
      exports2.buildDom(["link", { rel: "stylesheet", href: uri }], exports2.getDocumentHead(doc));
    };
    exports2.scrollbarWidth = function(doc) {
      var inner = exports2.createElement("ace_inner");
      inner.style.width = "100%";
      inner.style.minWidth = "0px";
      inner.style.height = "200px";
      inner.style.display = "block";
      var outer = exports2.createElement("ace_outer");
      var style2 = outer.style;
      style2.position = "absolute";
      style2.left = "-10000px";
      style2.overflow = "hidden";
      style2.width = "200px";
      style2.minWidth = "0px";
      style2.height = "150px";
      style2.display = "block";
      outer.appendChild(inner);
      var body = doc && doc.documentElement || document && document.documentElement;
      if (!body)
        return 0;
      body.appendChild(outer);
      var noScrollbar = inner.offsetWidth;
      style2.overflow = "scroll";
      var withScrollbar = inner.offsetWidth;
      if (noScrollbar === withScrollbar) {
        withScrollbar = outer.clientWidth;
      }
      body.removeChild(outer);
      return noScrollbar - withScrollbar;
    };
    exports2.computedStyle = function(element, style2) {
      return window.getComputedStyle(element, "") || {};
    };
    exports2.setStyle = function(styles, property, value) {
      if (styles[property] !== value) {
        styles[property] = value;
      }
    };
    exports2.HAS_CSS_ANIMATION = false;
    exports2.HAS_CSS_TRANSFORMS = false;
    exports2.HI_DPI = useragent.isWin ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5 : true;
    if (useragent.isChromeOS)
      exports2.HI_DPI = false;
    if (typeof document !== "undefined") {
      var div = document.createElement("div");
      if (exports2.HI_DPI && div.style.transform !== void 0)
        exports2.HAS_CSS_TRANSFORMS = true;
      if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
        exports2.HAS_CSS_ANIMATION = true;
      div = null;
    }
    if (exports2.HAS_CSS_TRANSFORMS) {
      exports2.translate = function(element, tx, ty) {
        element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
      };
    } else {
      exports2.translate = function(element, tx, ty) {
        element.style.top = Math.round(ty) + "px";
        element.style.left = Math.round(tx) + "px";
      };
    }
  });
  ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
    /*
    * based on code from:
    *
    * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
    * Available via the MIT or new BSD license.
    * see: http://github.com/jrburke/requirejs for details
    */
    var dom = require2("./dom");
    exports2.get = function(url, callback) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", url, true);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          callback(xhr.responseText);
        }
      };
      xhr.send(null);
    };
    exports2.loadScript = function(path, callback) {
      var head = dom.getDocumentHead();
      var s = document.createElement("script");
      s.src = path;
      head.appendChild(s);
      s.onload = s.onreadystatechange = function(_, isAbort) {
        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
          s = s.onload = s.onreadystatechange = null;
          if (!isAbort)
            callback();
        }
      };
    };
    exports2.qualifyURL = function(url) {
      var a = document.createElement("a");
      a.href = url;
      return a.href;
    };
  });
  ace.define("ace/lib/oop", ["require", "exports", "module"], function(require2, exports2, module2) {
    exports2.inherits = function(ctor, superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
    exports2.mixin = function(obj, mixin) {
      for (var key in mixin) {
        obj[key] = mixin[key];
      }
      return obj;
    };
    exports2.implement = function(proto, mixin) {
      exports2.mixin(proto, mixin);
    };
  });
  ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function(require2, exports2, module2) {
    var EventEmitter = {};
    var stopPropagation = function() {
      this.propagationStopped = true;
    };
    var preventDefault = function() {
      this.defaultPrevented = true;
    };
    EventEmitter._emit = EventEmitter._dispatchEvent = function(eventName, e) {
      this._eventRegistry || (this._eventRegistry = {});
      this._defaultHandlers || (this._defaultHandlers = {});
      var listeners = this._eventRegistry[eventName] || [];
      var defaultHandler = this._defaultHandlers[eventName];
      if (!listeners.length && !defaultHandler)
        return;
      if (typeof e != "object" || !e)
        e = {};
      if (!e.type)
        e.type = eventName;
      if (!e.stopPropagation)
        e.stopPropagation = stopPropagation;
      if (!e.preventDefault)
        e.preventDefault = preventDefault;
      listeners = listeners.slice();
      for (var i = 0; i < listeners.length; i++) {
        listeners[i](e, this);
        if (e.propagationStopped)
          break;
      }
      if (defaultHandler && !e.defaultPrevented)
        return defaultHandler(e, this);
    };
    EventEmitter._signal = function(eventName, e) {
      var listeners = (this._eventRegistry || {})[eventName];
      if (!listeners)
        return;
      listeners = listeners.slice();
      for (var i = 0; i < listeners.length; i++)
        listeners[i](e, this);
    };
    EventEmitter.once = function(eventName, callback) {
      var _self = this;
      this.on(eventName, function newCallback() {
        _self.off(eventName, newCallback);
        callback.apply(null, arguments);
      });
      if (!callback) {
        return new Promise(function(resolve) {
          callback = resolve;
        });
      }
    };
    EventEmitter.setDefaultHandler = function(eventName, callback) {
      var handlers = this._defaultHandlers;
      if (!handlers)
        handlers = this._defaultHandlers = { _disabled_: {} };
      if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
          handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1)
          disabled.splice(i, 1);
      }
      handlers[eventName] = callback;
    };
    EventEmitter.removeDefaultHandler = function(eventName, callback) {
      var handlers = this._defaultHandlers;
      if (!handlers)
        return;
      var disabled = handlers._disabled_[eventName];
      if (handlers[eventName] == callback) {
        if (disabled)
          this.setDefaultHandler(eventName, disabled.pop());
      } else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
          disabled.splice(i, 1);
      }
    };
    EventEmitter.on = EventEmitter.addEventListener = function(eventName, callback, capturing) {
      this._eventRegistry = this._eventRegistry || {};
      var listeners = this._eventRegistry[eventName];
      if (!listeners)
        listeners = this._eventRegistry[eventName] = [];
      if (listeners.indexOf(callback) == -1)
        listeners[capturing ? "unshift" : "push"](callback);
      return callback;
    };
    EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function(eventName, callback) {
      this._eventRegistry = this._eventRegistry || {};
      var listeners = this._eventRegistry[eventName];
      if (!listeners)
        return;
      var index2 = listeners.indexOf(callback);
      if (index2 !== -1)
        listeners.splice(index2, 1);
    };
    EventEmitter.removeAllListeners = function(eventName) {
      if (!eventName)
        this._eventRegistry = this._defaultHandlers = void 0;
      if (this._eventRegistry)
        this._eventRegistry[eventName] = void 0;
      if (this._defaultHandlers)
        this._defaultHandlers[eventName] = void 0;
    };
    exports2.EventEmitter = EventEmitter;
  });
  ace.define("ace/lib/report_error", ["require", "exports", "module"], function(require2, exports2, module2) {
    exports2.reportError = function reportError2(msg, data) {
      var e = new Error(msg);
      e["data"] = data;
      if (typeof console == "object" && console.error)
        console.error(e);
      setTimeout(function() {
        throw e;
      });
    };
  });
  ace.define("ace/lib/default_english_messages", ["require", "exports", "module"], function(require2, exports2, module2) {
    var defaultEnglishMessages = {
      "autocomplete.popup.aria-roledescription": "Autocomplete suggestions",
      "autocomplete.popup.aria-label": "Autocomplete suggestions",
      "autocomplete.popup.item.aria-roledescription": "item",
      "autocomplete.loading": "Loading...",
      "editor.scroller.aria-roledescription": "editor",
      "editor.scroller.aria-label": "Editor content, press Enter to start editing, press Escape to exit",
      "editor.gutter.aria-roledescription": "editor gutter",
      "editor.gutter.aria-label": "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit",
      "error-marker.good-state": "Looks good!",
      "prompt.recently-used": "Recently used",
      "prompt.other-commands": "Other commands",
      "prompt.no-matching-commands": "No matching commands",
      "search-box.find.placeholder": "Search for",
      "search-box.find-all.text": "All",
      "search-box.replace.placeholder": "Replace with",
      "search-box.replace-next.text": "Replace",
      "search-box.replace-all.text": "All",
      "search-box.toggle-replace.title": "Toggle Replace mode",
      "search-box.toggle-regexp.title": "RegExp Search",
      "search-box.toggle-case.title": "CaseSensitive Search",
      "search-box.toggle-whole-word.title": "Whole Word Search",
      "search-box.toggle-in-selection.title": "Search In Selection",
      "search-box.search-counter": "$0 of $1",
      "text-input.aria-roledescription": "editor",
      "text-input.aria-label": "Cursor at row $0",
      "gutter.code-folding.range.aria-label": "Toggle code folding, rows $0 through $1",
      "gutter.code-folding.closed.aria-label": "Toggle code folding, rows $0 through $1",
      "gutter.code-folding.open.aria-label": "Toggle code folding, row $0",
      "gutter.code-folding.closed.title": "Unfold code",
      "gutter.code-folding.open.title": "Fold code",
      "gutter.annotation.aria-label.error": "Error, read annotations row $0",
      "gutter.annotation.aria-label.warning": "Warning, read annotations row $0",
      "gutter.annotation.aria-label.info": "Info, read annotations row $0",
      "inline-fold.closed.title": "Unfold code",
      "gutter-tooltip.aria-label.error.singular": "error",
      "gutter-tooltip.aria-label.error.plural": "errors",
      "gutter-tooltip.aria-label.warning.singular": "warning",
      "gutter-tooltip.aria-label.warning.plural": "warnings",
      "gutter-tooltip.aria-label.info.singular": "information message",
      "gutter-tooltip.aria-label.info.plural": "information messages",
      "gutter.annotation.aria-label.security": "Security finding, read annotations row $0",
      "gutter.annotation.aria-label.hint": "Suggestion, read annotations row $0",
      "gutter-tooltip.aria-label.security.singular": "security finding",
      "gutter-tooltip.aria-label.security.plural": "security findings",
      "gutter-tooltip.aria-label.hint.singular": "suggestion",
      "gutter-tooltip.aria-label.hint.plural": "suggestions",
      "editor.tooltip.disable-editing": "Editing is disabled"
    };
    exports2.defaultEnglishMessages = defaultEnglishMessages;
  });
  ace.define("ace/lib/app_config", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter", "ace/lib/report_error", "ace/lib/default_english_messages"], function(require2, exports2, module2) {
    "no use strict";
    var oop = require2("./oop");
    var EventEmitter = require2("./event_emitter").EventEmitter;
    var reportError2 = require2("./report_error").reportError;
    var defaultEnglishMessages = require2("./default_english_messages").defaultEnglishMessages;
    var optionsProvider = {
      setOptions: function(optList) {
        Object.keys(optList).forEach(function(key) {
          this.setOption(key, optList[key]);
        }, this);
      },
      getOptions: function(optionNames) {
        var result = {};
        if (!optionNames) {
          var options = this.$options;
          optionNames = Object.keys(options).filter(function(key) {
            return !options[key].hidden;
          });
        } else if (!Array.isArray(optionNames)) {
          optionNames = Object.keys(optionNames);
        }
        optionNames.forEach(function(key) {
          result[key] = this.getOption(key);
        }, this);
        return result;
      },
      setOption: function(name, value) {
        if (this["$" + name] === value)
          return;
        var opt = this.$options[name];
        if (!opt) {
          return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
          return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
        if (!opt.handlesSet)
          this["$" + name] = value;
        if (opt && opt.set)
          opt.set.call(this, value);
      },
      getOption: function(name) {
        var opt = this.$options[name];
        if (!opt) {
          return warn('misspelled option "' + name + '"');
        }
        if (opt.forwardTo)
          return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
        return opt && opt.get ? opt.get.call(this) : this["$" + name];
      }
    };
    function warn(message) {
      if (typeof console != "undefined" && console.warn)
        console.warn.apply(console, arguments);
    }
    var messages;
    var nlsPlaceholders;
    var AppConfig = (
      /** @class */
      function() {
        function AppConfig2() {
          this.$defaultOptions = {};
          messages = defaultEnglishMessages;
          nlsPlaceholders = "dollarSigns";
        }
        AppConfig2.prototype.defineOptions = function(obj, path, options) {
          if (!obj.$options)
            this.$defaultOptions[path] = obj.$options = {};
          Object.keys(options).forEach(function(key) {
            var opt = options[key];
            if (typeof opt == "string")
              opt = { forwardTo: opt };
            opt.name || (opt.name = key);
            obj.$options[opt.name] = opt;
            if ("initialValue" in opt)
              obj["$" + opt.name] = opt.initialValue;
          });
          oop.implement(obj, optionsProvider);
          return this;
        };
        AppConfig2.prototype.resetOptions = function(obj) {
          Object.keys(obj.$options).forEach(function(key) {
            var opt = obj.$options[key];
            if ("value" in opt)
              obj.setOption(key, opt.value);
          });
        };
        AppConfig2.prototype.setDefaultValue = function(path, name, value) {
          if (!path) {
            for (path in this.$defaultOptions)
              if (this.$defaultOptions[path][name])
                break;
            if (!this.$defaultOptions[path][name])
              return false;
          }
          var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
          if (opts[name]) {
            if (opts.forwardTo)
              this.setDefaultValue(opts.forwardTo, name, value);
            else
              opts[name].value = value;
          }
        };
        AppConfig2.prototype.setDefaultValues = function(path, optionHash) {
          Object.keys(optionHash).forEach(function(key) {
            this.setDefaultValue(path, key, optionHash[key]);
          }, this);
        };
        AppConfig2.prototype.setMessages = function(value, options) {
          messages = value;
          if (options && options.placeholders) {
            nlsPlaceholders = options.placeholders;
          }
        };
        AppConfig2.prototype.nls = function(key, defaultString, params) {
          if (!messages[key]) {
            warn("No message found for the key '" + key + "' in messages with id " + messages.$id + ", trying to find a translation for the default string '" + defaultString + "'.");
            if (!messages[defaultString]) {
              warn("No message found for the default string '" + defaultString + "' in the provided messages. Falling back to the default English message.");
            }
          }
          var translated = messages[key] || messages[defaultString] || defaultString;
          if (params) {
            if (nlsPlaceholders === "dollarSigns") {
              translated = translated.replace(/\$(\$|[\d]+)/g, function(_, dollarMatch) {
                if (dollarMatch == "$")
                  return "$";
                return params[dollarMatch];
              });
            }
            if (nlsPlaceholders === "curlyBrackets") {
              translated = translated.replace(/\{([^\}]+)\}/g, function(_, curlyBracketMatch) {
                return params[curlyBracketMatch];
              });
            }
          }
          return translated;
        };
        return AppConfig2;
      }()
    );
    AppConfig.prototype.warn = warn;
    AppConfig.prototype.reportError = reportError2;
    oop.implement(AppConfig.prototype, EventEmitter);
    exports2.AppConfig = AppConfig;
  });
  ace.define("ace/theme/textmate-css", ["require", "exports", "module"], function(require2, exports2, module2) {
    module2.exports = '.ace-tm .ace_gutter {\n  background: #f0f0f0;\n  color: #333;\n}\n\n.ace-tm .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-tm .ace_fold {\n    background-color: #6B72E6;\n}\n\n.ace-tm {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-tm .ace_cursor {\n  color: black;\n}\n        \n.ace-tm .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-tm .ace_storage,\n.ace-tm .ace_keyword {\n  color: blue;\n}\n\n.ace-tm .ace_constant {\n  color: rgb(197, 6, 11);\n}\n\n.ace-tm .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-tm .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-tm .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_invalid {\n  background-color: rgba(255, 0, 0, 0.1);\n  color: red;\n}\n\n.ace-tm .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-tm .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_support.ace_type,\n.ace-tm .ace_support.ace_class {\n  color: rgb(109, 121, 222);\n}\n\n.ace-tm .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-tm .ace_string {\n  color: rgb(3, 106, 7);\n}\n\n.ace-tm .ace_comment {\n  color: rgb(76, 136, 107);\n}\n\n.ace-tm .ace_comment.ace_doc {\n  color: rgb(0, 102, 255);\n}\n\n.ace-tm .ace_comment.ace_doc.ace_tag {\n  color: rgb(128, 159, 191);\n}\n\n.ace-tm .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-tm .ace_variable {\n  color: rgb(49, 132, 149);\n}\n\n.ace-tm .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-tm .ace_entity.ace_name.ace_function {\n  color: #0000A2;\n}\n\n\n.ace-tm .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-tm .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-tm .ace_meta.ace_tag {\n  color:rgb(0, 22, 142);\n}\n\n.ace-tm .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-tm .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n.ace-tm.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px white;\n}\n.ace-tm .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-tm .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-tm .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-tm .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-tm .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-tm .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-tm .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-tm .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n}\n';
  });
  ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/theme/textmate-css", "ace/lib/dom"], function(require2, exports2, module2) {
    exports2.isDark = false;
    exports2.cssClass = "ace-tm";
    exports2.cssText = require2("./textmate-css");
    exports2.$id = "ace/theme/textmate";
    var dom = require2("../lib/dom");
    dom.importCssString(exports2.cssText, exports2.cssClass, false);
  });
  ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/net", "ace/lib/dom", "ace/lib/app_config", "ace/theme/textmate"], function(require2, exports2, module2) {
    "no use strict";
    var lang = require2("./lib/lang");
    var net = require2("./lib/net");
    var dom = require2("./lib/dom");
    var AppConfig = require2("./lib/app_config").AppConfig;
    module2.exports = exports2 = new AppConfig();
    var options = {
      packaged: false,
      workerPath: null,
      modePath: null,
      themePath: null,
      basePath: "",
      suffix: ".js",
      $moduleUrls: {},
      loadWorkerFromBlob: true,
      sharedPopups: false,
      useStrictCSP: null
    };
    exports2.get = function(key) {
      if (!options.hasOwnProperty(key))
        throw new Error("Unknown config key: " + key);
      return options[key];
    };
    exports2.set = function(key, value) {
      if (options.hasOwnProperty(key))
        options[key] = value;
      else if (this.setDefaultValue("", key, value) == false)
        throw new Error("Unknown config key: " + key);
      if (key == "useStrictCSP")
        dom.useStrictCSP(value);
    };
    exports2.all = function() {
      return lang.copyObject(options);
    };
    exports2.$modes = {};
    exports2.moduleUrl = function(name, component) {
      if (options.$moduleUrls[name])
        return options.$moduleUrls[name];
      var parts = name.split("/");
      component = component || parts[parts.length - 2] || "";
      var sep = component == "snippets" ? "/" : "-";
      var base = parts[parts.length - 1];
      if (component == "worker" && sep == "-") {
        var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
        base = base.replace(re, "");
      }
      if ((!base || base == component) && parts.length > 1)
        base = parts[parts.length - 2];
      var path = options[component + "Path"];
      if (path == null) {
        path = options.basePath;
      } else if (sep == "/") {
        component = sep = "";
      }
      if (path && path.slice(-1) != "/")
        path += "/";
      return path + component + sep + base + this.get("suffix");
    };
    exports2.setModuleUrl = function(name, subst) {
      return options.$moduleUrls[name] = subst;
    };
    var loader = function(moduleName, cb) {
      if (moduleName === "ace/theme/textmate" || moduleName === "./theme/textmate")
        return cb(null, require2("./theme/textmate"));
      if (customLoader)
        return customLoader(moduleName, cb);
      console.error("loader is not configured");
    };
    var customLoader;
    exports2.setLoader = function(cb) {
      customLoader = cb;
    };
    exports2.dynamicModules = /* @__PURE__ */ Object.create(null);
    exports2.$loading = {};
    exports2.$loaded = {};
    exports2.loadModule = function(moduleId, onLoad) {
      var loadedModule;
      if (Array.isArray(moduleId)) {
        var moduleType = moduleId[0];
        var moduleName = moduleId[1];
      } else if (typeof moduleId == "string") {
        var moduleName = moduleId;
      }
      var load = function(module3) {
        if (module3 && !exports2.$loading[moduleName])
          return onLoad && onLoad(module3);
        if (!exports2.$loading[moduleName])
          exports2.$loading[moduleName] = [];
        exports2.$loading[moduleName].push(onLoad);
        if (exports2.$loading[moduleName].length > 1)
          return;
        var afterLoad = function() {
          loader(moduleName, function(err, module4) {
            if (module4)
              exports2.$loaded[moduleName] = module4;
            exports2._emit("load.module", { name: moduleName, module: module4 });
            var listeners = exports2.$loading[moduleName];
            exports2.$loading[moduleName] = null;
            listeners.forEach(function(onLoad2) {
              onLoad2 && onLoad2(module4);
            });
          });
        };
        if (!exports2.get("packaged"))
          return afterLoad();
        net.loadScript(exports2.moduleUrl(moduleName, moduleType), afterLoad);
        reportErrorIfPathIsNotConfigured();
      };
      if (exports2.dynamicModules[moduleName]) {
        exports2.dynamicModules[moduleName]().then(function(module3) {
          if (module3.default) {
            load(module3.default);
          } else {
            load(module3);
          }
        });
      } else {
        try {
          loadedModule = this.$require(moduleName);
        } catch (e) {
        }
        load(loadedModule || exports2.$loaded[moduleName]);
      }
    };
    exports2.$require = function(moduleName) {
      if (typeof module2["require"] == "function") {
        var req = "require";
        return module2[req](moduleName);
      }
    };
    exports2.setModuleLoader = function(moduleName, onLoad) {
      exports2.dynamicModules[moduleName] = onLoad;
    };
    var reportErrorIfPathIsNotConfigured = function() {
      if (!options.basePath && !options.workerPath && !options.modePath && !options.themePath && !Object.keys(options.$moduleUrls).length) {
        console.error("Unable to infer path to ace from script src,", "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes", "or with webpack use ace/webpack-resolver");
        reportErrorIfPathIsNotConfigured = function() {
        };
      }
    };
    exports2.version = "1.43.3";
  });
  ace.define("ace/loader_build", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/config"], function(require2, exports2, module2) {
    require2("./lib/fixoldbrowsers");
    var config = require2("./config");
    config.setLoader(function(moduleName, cb) {
      require2([moduleName], function(module3) {
        cb(null, module3);
      });
    });
    var global = /* @__PURE__ */ function() {
      return this || typeof window != "undefined" && window;
    }();
    module2.exports = function(ace2) {
      config.init = init;
      config.$require = require2;
      ace2.require = require2;
    };
    init(true);
    function init(packaged) {
      if (!global || !global.document)
        return;
      config.set("packaged", packaged || require2.packaged || module2.packaged || global.define && (void 0).packaged);
      var scriptOptions = {};
      var scriptUrl = "";
      var currentScript = document.currentScript || document._currentScript;
      var currentDocument = currentScript && currentScript.ownerDocument || document;
      if (currentScript && currentScript.src) {
        scriptUrl = currentScript.src.split(/[?#]/)[0].split("/").slice(0, -1).join("/") || "";
      }
      var scripts = currentDocument.getElementsByTagName("script");
      for (var i = 0; i < scripts.length; i++) {
        var script = scripts[i];
        var src = script.src || script.getAttribute("src");
        if (!src)
          continue;
        var attributes = script.attributes;
        for (var j = 0, l = attributes.length; j < l; j++) {
          var attr = attributes[j];
          if (attr.name.indexOf("data-ace-") === 0) {
            scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
          }
        }
        var m = src.match(/^(.*)\/ace([\-.]\w+)?\.js(\?|$)/);
        if (m)
          scriptUrl = m[1];
      }
      if (scriptUrl) {
        scriptOptions.base = scriptOptions.base || scriptUrl;
        scriptOptions.packaged = true;
      }
      scriptOptions.basePath = scriptOptions.base;
      scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
      scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
      scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
      delete scriptOptions.base;
      for (var key in scriptOptions)
        if (typeof scriptOptions[key] !== "undefined")
          config.set(key, scriptOptions[key]);
    }
    function deHyphenate(str) {
      return str.replace(/-(.)/g, function(m, m1) {
        return m1.toUpperCase();
      });
    }
  });
  ace.define("ace/range", ["require", "exports", "module"], function(require2, exports2, module2) {
    var Range = (
      /** @class */
      function() {
        function Range2(startRow, startColumn, endRow, endColumn) {
          this.start = {
            row: startRow,
            column: startColumn
          };
          this.end = {
            row: endRow,
            column: endColumn
          };
        }
        Range2.prototype.isEqual = function(range) {
          return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
        };
        Range2.prototype.toString = function() {
          return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
        };
        Range2.prototype.contains = function(row, column) {
          return this.compare(row, column) == 0;
        };
        Range2.prototype.compareRange = function(range) {
          var cmp, end = range.end, start = range.start;
          cmp = this.compare(end.row, end.column);
          if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
              return 2;
            } else if (cmp == 0) {
              return 1;
            } else {
              return 0;
            }
          } else if (cmp == -1) {
            return -2;
          } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
              return -1;
            } else if (cmp == 1) {
              return 42;
            } else {
              return 0;
            }
          }
        };
        Range2.prototype.comparePoint = function(p) {
          return this.compare(p.row, p.column);
        };
        Range2.prototype.containsRange = function(range) {
          return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
        };
        Range2.prototype.intersects = function(range) {
          var cmp = this.compareRange(range);
          return cmp == -1 || cmp == 0 || cmp == 1;
        };
        Range2.prototype.isEnd = function(row, column) {
          return this.end.row == row && this.end.column == column;
        };
        Range2.prototype.isStart = function(row, column) {
          return this.start.row == row && this.start.column == column;
        };
        Range2.prototype.setStart = function(row, column) {
          if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
          } else {
            this.start.row = row;
            this.start.column = column;
          }
        };
        Range2.prototype.setEnd = function(row, column) {
          if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
          } else {
            this.end.row = row;
            this.end.column = column;
          }
        };
        Range2.prototype.inside = function(row, column) {
          if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
              return false;
            } else {
              return true;
            }
          }
          return false;
        };
        Range2.prototype.insideStart = function(row, column) {
          if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
              return false;
            } else {
              return true;
            }
          }
          return false;
        };
        Range2.prototype.insideEnd = function(row, column) {
          if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
              return false;
            } else {
              return true;
            }
          }
          return false;
        };
        Range2.prototype.compare = function(row, column) {
          if (!this.isMultiLine()) {
            if (row === this.start.row) {
              return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
            }
          }
          if (row < this.start.row)
            return -1;
          if (row > this.end.row)
            return 1;
          if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;
          if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;
          return 0;
        };
        Range2.prototype.compareStart = function(row, column) {
          if (this.start.row == row && this.start.column == column) {
            return -1;
          } else {
            return this.compare(row, column);
          }
        };
        Range2.prototype.compareEnd = function(row, column) {
          if (this.end.row == row && this.end.column == column) {
            return 1;
          } else {
            return this.compare(row, column);
          }
        };
        Range2.prototype.compareInside = function(row, column) {
          if (this.end.row == row && this.end.column == column) {
            return 1;
          } else if (this.start.row == row && this.start.column == column) {
            return -1;
          } else {
            return this.compare(row, column);
          }
        };
        Range2.prototype.clipRows = function(firstRow, lastRow) {
          if (this.end.row > lastRow)
            var end = { row: lastRow + 1, column: 0 };
          else if (this.end.row < firstRow)
            var end = { row: firstRow, column: 0 };
          if (this.start.row > lastRow)
            var start = { row: lastRow + 1, column: 0 };
          else if (this.start.row < firstRow)
            var start = { row: firstRow, column: 0 };
          return Range2.fromPoints(start || this.start, end || this.end);
        };
        Range2.prototype.extend = function(row, column) {
          var cmp = this.compare(row, column);
          if (cmp == 0)
            return this;
          else if (cmp == -1)
            var start = { row, column };
          else
            var end = { row, column };
          return Range2.fromPoints(start || this.start, end || this.end);
        };
        Range2.prototype.isEmpty = function() {
          return this.start.row === this.end.row && this.start.column === this.end.column;
        };
        Range2.prototype.isMultiLine = function() {
          return this.start.row !== this.end.row;
        };
        Range2.prototype.clone = function() {
          return Range2.fromPoints(this.start, this.end);
        };
        Range2.prototype.collapseRows = function() {
          if (this.end.column == 0)
            return new Range2(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
          else
            return new Range2(this.start.row, 0, this.end.row, 0);
        };
        Range2.prototype.toScreenRange = function(session) {
          var screenPosStart = session.documentToScreenPosition(this.start);
          var screenPosEnd = session.documentToScreenPosition(this.end);
          return new Range2(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
        };
        Range2.prototype.moveBy = function(row, column) {
          this.start.row += row;
          this.start.column += column;
          this.end.row += row;
          this.end.column += column;
        };
        return Range2;
      }()
    );
    Range.fromPoints = function(start, end) {
      return new Range(start.row, start.column, end.row, end.column);
    };
    Range.comparePoints = function(p1, p2) {
      return p1.row - p2.row || p1.column - p2.column;
    };
    exports2.Range = Range;
  });
  ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/oop"], function(require2, exports2, module2) {
    var oop = require2("./oop");
    var Keys = {
      MODIFIER_KEYS: {
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        224: "Meta",
        91: "MetaLeft",
        92: "MetaRight",
        93: "ContextMenu"
      },
      KEY_MODS: {
        "ctrl": 1,
        "alt": 2,
        "option": 2,
        "shift": 4,
        "super": 8,
        "meta": 8,
        "command": 8,
        "cmd": 8,
        "control": 1
      },
      FUNCTION_KEYS: {
        8: "Backspace",
        9: "Tab",
        13: "Return",
        19: "Pause",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "Print",
        45: "Insert",
        46: "Delete",
        "-13": "NumpadEnter",
        144: "Numlock",
        145: "Scrolllock"
      },
      PRINTABLE_KEYS: {
        32: " ",
        59: ";",
        61: "=",
        107: "+",
        109: "-",
        110: ".",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        111: "/",
        106: "*"
      }
    };
    var codeToKeyCode = {
      Command: 224,
      Backspace: 8,
      Tab: 9,
      Return: 13,
      Enter: 13,
      Pause: 19,
      Escape: 27,
      PageUp: 33,
      PageDown: 34,
      End: 35,
      Home: 36,
      Insert: 45,
      Delete: 46,
      ArrowLeft: 37,
      ArrowUp: 38,
      ArrowRight: 39,
      ArrowDown: 40,
      Backquote: 192,
      Minus: 189,
      Equal: 187,
      BracketLeft: 219,
      Backslash: 220,
      BracketRight: 221,
      Semicolon: 186,
      Quote: 222,
      Comma: 188,
      Period: 190,
      Slash: 191,
      Space: 32,
      NumpadAdd: 107,
      NumpadDecimal: 110,
      NumpadSubtract: 109,
      NumpadDivide: 111,
      NumpadMultiply: 106
    };
    for (var i = 0; i < 10; i++) {
      codeToKeyCode["Digit" + i] = 48 + i;
      codeToKeyCode["Numpad" + i] = 96 + i;
      Keys.PRINTABLE_KEYS[48 + i] = "" + i;
      Keys.FUNCTION_KEYS[96 + i] = "Numpad" + i;
    }
    for (var i = 65; i < 91; i++) {
      var chr = String.fromCharCode(i + 32);
      codeToKeyCode["Key" + chr.toUpperCase()] = i;
      Keys.PRINTABLE_KEYS[i] = chr;
    }
    for (var i = 1; i < 13; i++) {
      codeToKeyCode["F" + i] = 111 + i;
      Keys.FUNCTION_KEYS[111 + i] = "F" + i;
    }
    var modifiers = {
      Shift: 16,
      Control: 17,
      Alt: 18,
      Meta: 224
    };
    for (var mod in modifiers) {
      codeToKeyCode[mod] = codeToKeyCode[mod + "Left"] = codeToKeyCode[mod + "Right"] = modifiers[mod];
    }
    exports2.$codeToKeyCode = codeToKeyCode;
    Keys.PRINTABLE_KEYS[173] = "-";
    for (var j in Keys.FUNCTION_KEYS) {
      var name = Keys.FUNCTION_KEYS[j].toLowerCase();
      Keys[name] = parseInt(j, 10);
    }
    for (var j in Keys.PRINTABLE_KEYS) {
      var name = Keys.PRINTABLE_KEYS[j].toLowerCase();
      Keys[name] = parseInt(j, 10);
    }
    oop.mixin(Keys, Keys.MODIFIER_KEYS);
    oop.mixin(Keys, Keys.PRINTABLE_KEYS);
    oop.mixin(Keys, Keys.FUNCTION_KEYS);
    Keys.enter = Keys["return"];
    Keys.escape = Keys.esc;
    Keys.del = Keys["delete"];
    (function() {
      var mods = ["cmd", "ctrl", "alt", "shift"];
      for (var i2 = Math.pow(2, mods.length); i2--; ) {
        Keys.KEY_MODS[i2] = mods.filter(function(x) {
          return i2 & Keys.KEY_MODS[x];
        }).join("-") + "-";
      }
    })();
    Keys.KEY_MODS[0] = "";
    Keys.KEY_MODS[-1] = "input-";
    oop.mixin(exports2, Keys);
    exports2.default = exports2;
    exports2.keyCodeToString = function(keyCode) {
      var keyString = Keys[keyCode];
      if (typeof keyString != "string")
        keyString = String.fromCharCode(keyCode);
      return keyString.toLowerCase();
    };
  });
  ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(require2, exports2, module2) {
    var keys = require2("./keys");
    var useragent = require2("./useragent");
    var pressedKeys = null;
    var ts = 0;
    var activeListenerOptions;
    function detectListenerOptionsSupport() {
      activeListenerOptions = false;
      try {
        document.createComment("").addEventListener("test", function() {
        }, {
          get passive() {
            activeListenerOptions = { passive: false };
            return true;
          }
        });
      } catch (e) {
      }
    }
    function getListenerOptions() {
      if (activeListenerOptions == void 0)
        detectListenerOptionsSupport();
      return activeListenerOptions;
    }
    function EventListener(elem, type, callback) {
      this.elem = elem;
      this.type = type;
      this.callback = callback;
    }
    EventListener.prototype.destroy = function() {
      removeListener(this.elem, this.type, this.callback);
      this.elem = this.type = this.callback = void 0;
    };
    var addListener = exports2.addListener = function(elem, type, callback, destroyer) {
      elem.addEventListener(type, callback, getListenerOptions());
      if (destroyer)
        destroyer.$toDestroy.push(new EventListener(elem, type, callback));
    };
    var removeListener = exports2.removeListener = function(elem, type, callback) {
      elem.removeEventListener(type, callback, getListenerOptions());
    };
    exports2.stopEvent = function(e) {
      exports2.stopPropagation(e);
      exports2.preventDefault(e);
      return false;
    };
    exports2.stopPropagation = function(e) {
      if (e.stopPropagation)
        e.stopPropagation();
    };
    exports2.preventDefault = function(e) {
      if (e.preventDefault)
        e.preventDefault();
    };
    exports2.getButton = function(e) {
      if (e.type == "dblclick")
        return 0;
      if (e.type == "contextmenu" || useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey))
        return 2;
      return e.button;
    };
    exports2.capture = function(el, eventHandler, releaseCaptureHandler) {
      var ownerDocument = el && el.ownerDocument || document;
      function onMouseUp(e) {
        eventHandler && eventHandler(e);
        releaseCaptureHandler && releaseCaptureHandler(e);
        removeListener(ownerDocument, "mousemove", eventHandler);
        removeListener(ownerDocument, "mouseup", onMouseUp);
        removeListener(ownerDocument, "dragstart", onMouseUp);
      }
      addListener(ownerDocument, "mousemove", eventHandler);
      addListener(ownerDocument, "mouseup", onMouseUp);
      addListener(ownerDocument, "dragstart", onMouseUp);
      return onMouseUp;
    };
    exports2.addMouseWheelListener = function(el, callback, destroyer) {
      addListener(el, "wheel", function(e) {
        var factor = 0.15;
        var deltaX = e.deltaX || 0;
        var deltaY = e.deltaY || 0;
        switch (e.deltaMode) {
          case e.DOM_DELTA_PIXEL:
            e.wheelX = deltaX * factor;
            e.wheelY = deltaY * factor;
            break;
          case e.DOM_DELTA_LINE:
            var linePixels = 15;
            e.wheelX = deltaX * linePixels;
            e.wheelY = deltaY * linePixels;
            break;
          case e.DOM_DELTA_PAGE:
            var pagePixels = 150;
            e.wheelX = deltaX * pagePixels;
            e.wheelY = deltaY * pagePixels;
            break;
        }
        callback(e);
      }, destroyer);
    };
    exports2.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName, destroyer) {
      var clicks = 0;
      var startX, startY, timer;
      var eventNames = {
        2: "dblclick",
        3: "tripleclick",
        4: "quadclick"
      };
      function onMousedown(e) {
        if (exports2.getButton(e) !== 0) {
          clicks = 0;
        } else if (e.detail > 1) {
          clicks++;
          if (clicks > 4)
            clicks = 1;
        } else {
          clicks = 1;
        }
        if (useragent.isIE) {
          var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
          if (!timer || isNewClick)
            clicks = 1;
          if (timer)
            clearTimeout(timer);
          timer = setTimeout(function() {
            timer = null;
          }, timeouts[clicks - 1] || 600);
          if (clicks == 1) {
            startX = e.clientX;
            startY = e.clientY;
          }
        }
        e._clicks = clicks;
        eventHandler[callbackName]("mousedown", e);
        if (clicks > 4)
          clicks = 0;
        else if (clicks > 1)
          return eventHandler[callbackName](eventNames[clicks], e);
      }
      if (!Array.isArray(elements))
        elements = [elements];
      elements.forEach(function(el) {
        addListener(el, "mousedown", onMousedown, destroyer);
      });
    };
    function getModifierHash(e) {
      return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
    }
    exports2.getModifierString = function(e) {
      return keys.KEY_MODS[getModifierHash(e)];
    };
    function normalizeCommandKeys(callback, e, keyCode) {
      var hashId = getModifierHash(e);
      if (!keyCode && e.code) {
        keyCode = keys.$codeToKeyCode[e.code] || keyCode;
      }
      if (!useragent.isMac && pressedKeys) {
        if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
          hashId |= 8;
        if (pressedKeys.altGr) {
          if ((3 & hashId) != 3)
            pressedKeys.altGr = 0;
          else
            return;
        }
        if (keyCode === 18 || keyCode === 17) {
          var location = e.location;
          if (keyCode === 17 && location === 1) {
            if (pressedKeys[keyCode] == 1)
              ts = e.timeStamp;
          } else if (keyCode === 18 && hashId === 3 && location === 2) {
            var dt = e.timeStamp - ts;
            if (dt < 50)
              pressedKeys.altGr = true;
          }
        }
      }
      if (keyCode in keys.MODIFIER_KEYS) {
        keyCode = -1;
      }
      if (!hashId && keyCode === 13) {
        if (e.location === 3) {
          callback(e, hashId, -keyCode);
          if (e.defaultPrevented)
            return;
        }
      }
      if (useragent.isChromeOS && hashId & 8) {
        callback(e, hashId, keyCode);
        if (e.defaultPrevented)
          return;
        else
          hashId &= -9;
      }
      if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
        return false;
      }
      return callback(e, hashId, keyCode);
    }
    exports2.addCommandKeyListener = function(el, callback, destroyer) {
      var lastDefaultPrevented = null;
      addListener(el, "keydown", function(e) {
        pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
        var result = normalizeCommandKeys(callback, e, e.keyCode);
        lastDefaultPrevented = e.defaultPrevented;
        return result;
      }, destroyer);
      addListener(el, "keypress", function(e) {
        if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
          exports2.stopEvent(e);
          lastDefaultPrevented = null;
        }
      }, destroyer);
      addListener(el, "keyup", function(e) {
        pressedKeys[e.keyCode] = null;
      }, destroyer);
      if (!pressedKeys) {
        resetPressedKeys();
        addListener(window, "focus", resetPressedKeys);
      }
    };
    function resetPressedKeys() {
      pressedKeys = /* @__PURE__ */ Object.create(null);
    }
    if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
      var postMessageId = 1;
      exports2.nextTick = function(callback, win) {
        win = win || window;
        var messageName = "zero-timeout-message-" + postMessageId++;
        var listener = function(e) {
          if (e.data == messageName) {
            exports2.stopPropagation(e);
            removeListener(win, "message", listener);
            callback();
          }
        };
        addListener(win, "message", listener);
        win.postMessage(messageName, "*");
      };
    }
    exports2.$idleBlocked = false;
    exports2.onIdle = function(cb, timeout) {
      return setTimeout(function handler() {
        if (!exports2.$idleBlocked) {
          cb();
        } else {
          setTimeout(handler, 100);
        }
      }, timeout);
    };
    exports2.$idleBlockId = null;
    exports2.blockIdle = function(delay) {
      if (exports2.$idleBlockId)
        clearTimeout(exports2.$idleBlockId);
      exports2.$idleBlocked = true;
      exports2.$idleBlockId = setTimeout(function() {
        exports2.$idleBlocked = false;
      }, delay || 100);
    };
    exports2.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window["mozRequestAnimationFrame"] || window["webkitRequestAnimationFrame"] || window["msRequestAnimationFrame"] || window["oRequestAnimationFrame"]);
    if (exports2.nextFrame)
      exports2.nextFrame = exports2.nextFrame.bind(window);
    else
      exports2.nextFrame = function(callback) {
        setTimeout(callback, 17);
      };
  });
  ace.define("ace/clipboard", ["require", "exports", "module"], function(require2, exports2, module2) {
    var $cancelT;
    module2.exports = {
      lineMode: false,
      pasteCancelled: function() {
        if ($cancelT && $cancelT > Date.now() - 50)
          return true;
        return $cancelT = false;
      },
      cancel: function() {
        $cancelT = Date.now();
      }
    };
  });
  ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/config", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang", "ace/clipboard", "ace/lib/keys"], function(require2, exports2, module2) {
    var event = require2("../lib/event");
    var nls = require2("../config").nls;
    var useragent = require2("../lib/useragent");
    var dom = require2("../lib/dom");
    var lang = require2("../lib/lang");
    var clipboard = require2("../clipboard");
    var BROKEN_SETDATA = useragent.isChrome < 18;
    var USE_IE_MIME_TYPE = useragent.isIE;
    var HAS_FOCUS_ARGS = useragent.isChrome > 63;
    var MAX_LINE_LENGTH = 400;
    var KEYS = require2("../lib/keys");
    var MODS = KEYS.KEY_MODS;
    var isIOS = useragent.isIOS;
    var valueResetRegex = isIOS ? /\s/ : /\n/;
    var isMobile = useragent.isMobile;
    var TextInput = (
      /** @class */
      function() {
        function TextInput2(parentNode, host) {
          var _this = this;
          this.host = host;
          this.text = dom.createElement("textarea");
          this.text.className = "ace_text-input";
          this.text.setAttribute("wrap", "off");
          this.text.setAttribute("autocomplete", "off");
          this.text.setAttribute("autocorrect", "off");
          this.text.setAttribute("autocapitalize", "off");
          this.text.setAttribute("spellcheck", "false");
          this.text.style.opacity = "0";
          parentNode.insertBefore(this.text, parentNode.firstChild);
          this.copied = false;
          this.pasted = false;
          this.inComposition = false;
          this.sendingText = false;
          this.tempStyle = "";
          if (!isMobile)
            this.text.style.fontSize = "1px";
          this.commandMode = false;
          this.ignoreFocusEvents = false;
          this.lastValue = "";
          this.lastSelectionStart = 0;
          this.lastSelectionEnd = 0;
          this.lastRestoreEnd = 0;
          this.rowStart = Number.MAX_SAFE_INTEGER;
          this.rowEnd = Number.MIN_SAFE_INTEGER;
          this.numberOfExtraLines = 0;
          try {
            this.$isFocused = document.activeElement === this.text;
          } catch (e) {
          }
          this.cancelComposition = this.cancelComposition.bind(this);
          this.setAriaOptions({ role: "textbox" });
          event.addListener(this.text, "blur", function(e) {
            if (_this.ignoreFocusEvents)
              return;
            host.onBlur(e);
            _this.$isFocused = false;
          }, host);
          event.addListener(this.text, "focus", function(e) {
            if (_this.ignoreFocusEvents)
              return;
            _this.$isFocused = true;
            if (useragent.isEdge) {
              try {
                if (!document.hasFocus())
                  return;
              } catch (e2) {
              }
            }
            host.onFocus(e);
            if (useragent.isEdge)
              setTimeout(_this.resetSelection.bind(_this));
            else
              _this.resetSelection();
          }, host);
          this.$focusScroll = false;
          host.on("beforeEndOperation", function() {
            var curOp = host.curOp;
            var commandName = curOp && curOp.command && curOp.command.name;
            if (commandName == "insertstring")
              return;
            var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
            if (_this.inComposition && isUserAction) {
              _this.lastValue = _this.text.value = "";
              _this.onCompositionEnd();
            }
            _this.resetSelection();
          });
          host.on("changeSelection", this.setAriaLabel.bind(this));
          this.resetSelection = isIOS ? this.$resetSelectionIOS : this.$resetSelection;
          if (this.$isFocused)
            host.onFocus();
          this.inputHandler = null;
          this.afterContextMenu = false;
          event.addCommandKeyListener(this.text, function(e, hashId, keyCode) {
            if (_this.inComposition)
              return;
            return host.onCommandKey(e, hashId, keyCode);
          }, host);
          event.addListener(this.text, "select", this.onSelect.bind(this), host);
          event.addListener(this.text, "input", this.onInput.bind(this), host);
          event.addListener(this.text, "cut", this.onCut.bind(this), host);
          event.addListener(this.text, "copy", this.onCopy.bind(this), host);
          event.addListener(this.text, "paste", this.onPaste.bind(this), host);
          if (!("oncut" in this.text) || !("oncopy" in this.text) || !("onpaste" in this.text)) {
            event.addListener(parentNode, "keydown", function(e) {
              if (useragent.isMac && !e.metaKey || !e.ctrlKey)
                return;
              switch (e.keyCode) {
                case 67:
                  _this.onCopy(e);
                  break;
                case 86:
                  _this.onPaste(e);
                  break;
                case 88:
                  _this.onCut(e);
                  break;
              }
            }, host);
          }
          this.syncComposition = lang.delayedCall(this.onCompositionUpdate.bind(this), 50).schedule.bind(null, null);
          event.addListener(this.text, "compositionstart", this.onCompositionStart.bind(this), host);
          event.addListener(this.text, "compositionupdate", this.onCompositionUpdate.bind(this), host);
          event.addListener(this.text, "keyup", this.onKeyup.bind(this), host);
          event.addListener(this.text, "keydown", this.syncComposition.bind(this), host);
          event.addListener(this.text, "compositionend", this.onCompositionEnd.bind(this), host);
          this.closeTimeout;
          event.addListener(this.text, "mouseup", this.$onContextMenu.bind(this), host);
          event.addListener(this.text, "mousedown", function(e) {
            e.preventDefault();
            _this.onContextMenuClose();
          }, host);
          event.addListener(host.renderer.scroller, "contextmenu", this.$onContextMenu.bind(this), host);
          event.addListener(this.text, "contextmenu", this.$onContextMenu.bind(this), host);
          if (isIOS)
            this.addIosSelectionHandler(parentNode, host, this.text);
        }
        TextInput2.prototype.addIosSelectionHandler = function(parentNode, host, text) {
          var _this = this;
          var typingResetTimeout = null;
          var typing = false;
          text.addEventListener("keydown", function(e) {
            if (typingResetTimeout)
              clearTimeout(typingResetTimeout);
            typing = true;
          }, true);
          text.addEventListener("keyup", function(e) {
            typingResetTimeout = setTimeout(function() {
              typing = false;
            }, 100);
          }, true);
          var detectArrowKeys = function(e) {
            if (document.activeElement !== text)
              return;
            if (typing || _this.inComposition || host.$mouseHandler.isMousePressed)
              return;
            if (_this.copied) {
              return;
            }
            var selectionStart = text.selectionStart;
            var selectionEnd = text.selectionEnd;
            var key = null;
            var modifier = 0;
            if (selectionStart == 0) {
              key = KEYS.up;
            } else if (selectionStart == 1) {
              key = KEYS.home;
            } else if (selectionEnd > _this.lastSelectionEnd && _this.lastValue[selectionEnd] == "\n") {
              key = KEYS.end;
            } else if (selectionStart < _this.lastSelectionStart && _this.lastValue[selectionStart - 1] == " ") {
              key = KEYS.left;
              modifier = MODS.option;
            } else if (selectionStart < _this.lastSelectionStart || selectionStart == _this.lastSelectionStart && _this.lastSelectionEnd != _this.lastSelectionStart && selectionStart == selectionEnd) {
              key = KEYS.left;
            } else if (selectionEnd > _this.lastSelectionEnd && _this.lastValue.slice(0, selectionEnd).split("\n").length > 2) {
              key = KEYS.down;
            } else if (selectionEnd > _this.lastSelectionEnd && _this.lastValue[selectionEnd - 1] == " ") {
              key = KEYS.right;
              modifier = MODS.option;
            } else if (selectionEnd > _this.lastSelectionEnd || selectionEnd == _this.lastSelectionEnd && _this.lastSelectionEnd != _this.lastSelectionStart && selectionStart == selectionEnd) {
              key = KEYS.right;
            }
            if (selectionStart !== selectionEnd)
              modifier |= MODS.shift;
            if (key) {
              var result = host.onCommandKey({}, modifier, key);
              if (!result && host.commands) {
                key = KEYS.keyCodeToString(key);
                var command = host.commands.findKeyCommand(modifier, key);
                if (command)
                  host.execCommand(command);
              }
              _this.lastSelectionStart = selectionStart;
              _this.lastSelectionEnd = selectionEnd;
              _this.resetSelection("");
            }
          };
          document.addEventListener("selectionchange", detectArrowKeys);
          host.on("destroy", function() {
            document.removeEventListener("selectionchange", detectArrowKeys);
          });
        };
        TextInput2.prototype.onContextMenuClose = function() {
          var _this = this;
          clearTimeout(this.closeTimeout);
          this.closeTimeout = setTimeout(function() {
            if (_this.tempStyle) {
              _this.text.style.cssText = _this.tempStyle;
              _this.tempStyle = "";
            }
            _this.host.renderer.$isMousePressed = false;
            if (_this.host.renderer.$keepTextAreaAtCursor)
              _this.host.renderer.$moveTextAreaToCursor();
          }, 0);
        };
        TextInput2.prototype.$onContextMenu = function(e) {
          this.host.textInput.onContextMenu(e);
          this.onContextMenuClose();
        };
        TextInput2.prototype.onKeyup = function(e) {
          if (e.keyCode == 27 && this.text.value.length < this.text.selectionStart) {
            if (!this.inComposition)
              this.lastValue = this.text.value;
            this.lastSelectionStart = this.lastSelectionEnd = -1;
            this.resetSelection();
          }
          this.syncComposition();
        };
        TextInput2.prototype.cancelComposition = function() {
          this.ignoreFocusEvents = true;
          this.text.blur();
          this.text.focus();
          this.ignoreFocusEvents = false;
        };
        TextInput2.prototype.onCompositionStart = function(e) {
          if (this.inComposition || !this.host.onCompositionStart || this.host.$readOnly)
            return;
          this.inComposition = {};
          if (this.commandMode)
            return;
          if (e.data)
            this.inComposition.useTextareaForIME = false;
          setTimeout(this.onCompositionUpdate.bind(this), 0);
          this.host._signal("compositionStart");
          this.host.on("mousedown", this.cancelComposition);
          var range = this.host.getSelectionRange();
          range.end.row = range.start.row;
          range.end.column = range.start.column;
          this.inComposition.markerRange = range;
          this.inComposition.selectionStart = this.lastSelectionStart;
          this.host.onCompositionStart(this.inComposition);
          if (this.inComposition.useTextareaForIME) {
            this.lastValue = this.text.value = "";
            this.lastSelectionStart = 0;
            this.lastSelectionEnd = 0;
          } else {
            if (this.text.msGetInputContext)
              this.inComposition.context = this.text.msGetInputContext();
            if (this.text.getInputContext)
              this.inComposition.context = this.text.getInputContext();
          }
        };
        TextInput2.prototype.onCompositionUpdate = function() {
          if (!this.inComposition || !this.host.onCompositionUpdate || this.host.$readOnly)
            return;
          if (this.commandMode)
            return this.cancelComposition();
          if (this.inComposition.useTextareaForIME) {
            this.host.onCompositionUpdate(this.text.value);
          } else {
            var data = this.text.value;
            this.sendText(data);
            if (this.inComposition.markerRange) {
              if (this.inComposition.context) {
                this.inComposition.markerRange.start.column = this.inComposition.selectionStart = this.inComposition.context.compositionStartOffset;
              }
              this.inComposition.markerRange.end.column = this.inComposition.markerRange.start.column + this.lastSelectionEnd - this.inComposition.selectionStart + this.lastRestoreEnd;
            }
          }
        };
        TextInput2.prototype.onCompositionEnd = function(e) {
          if (!this.host.onCompositionEnd || this.host.$readOnly)
            return;
          this.inComposition = false;
          this.host.onCompositionEnd();
          this.host.off("mousedown", this.cancelComposition);
          if (e)
            this.onInput();
        };
        TextInput2.prototype.onCut = function(e) {
          this.doCopy(e, true);
        };
        TextInput2.prototype.onCopy = function(e) {
          this.doCopy(e, false);
        };
        TextInput2.prototype.onPaste = function(e) {
          var data = this.handleClipboardData(e);
          if (clipboard.pasteCancelled())
            return;
          if (typeof data == "string") {
            if (data)
              this.host.onPaste(data, e);
            if (useragent.isIE)
              setTimeout(this.resetSelection);
            event.preventDefault(e);
          } else {
            this.text.value = "";
            this.pasted = true;
          }
        };
        TextInput2.prototype.doCopy = function(e, isCut) {
          var _this = this;
          var data = this.host.getCopyText();
          if (!data)
            return event.preventDefault(e);
          if (this.handleClipboardData(e, data)) {
            if (isIOS) {
              this.resetSelection(data);
              this.copied = data;
              setTimeout(function() {
                _this.copied = false;
              }, 10);
            }
            isCut ? this.host.onCut() : this.host.onCopy();
            event.preventDefault(e);
          } else {
            this.copied = true;
            this.text.value = data;
            this.text.select();
            setTimeout(function() {
              _this.copied = false;
              _this.resetSelection();
              isCut ? _this.host.onCut() : _this.host.onCopy();
            });
          }
        };
        TextInput2.prototype.handleClipboardData = function(e, data, forceIEMime) {
          var clipboardData = e.clipboardData || window["clipboardData"];
          if (!clipboardData || BROKEN_SETDATA)
            return;
          var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
          try {
            if (data) {
              return clipboardData.setData(mime, data) !== false;
            } else {
              return clipboardData.getData(mime);
            }
          } catch (e2) {
            if (!forceIEMime)
              return this.handleClipboardData(e2, data, true);
          }
        };
        TextInput2.prototype.onInput = function(e) {
          if (this.inComposition)
            return this.onCompositionUpdate();
          if (e && e.inputType) {
            if (e.inputType == "historyUndo")
              return this.host.execCommand("undo");
            if (e.inputType == "historyRedo")
              return this.host.execCommand("redo");
          }
          var data = this.text.value;
          var inserted = this.sendText(data, true);
          if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted) || isMobile && this.lastSelectionStart < 1 && this.lastSelectionStart == this.lastSelectionEnd) {
            this.resetSelection();
          }
        };
        TextInput2.prototype.sendText = function(value, fromInput) {
          if (this.afterContextMenu)
            this.afterContextMenu = false;
          if (this.pasted) {
            this.resetSelection();
            if (value)
              this.host.onPaste(value);
            this.pasted = false;
            return "";
          } else {
            var selectionStart = this.text.selectionStart;
            var selectionEnd = this.text.selectionEnd;
            var extendLeft = this.lastSelectionStart;
            var extendRight = this.lastValue.length - this.lastSelectionEnd;
            var inserted = value;
            var restoreStart = value.length - selectionStart;
            var restoreEnd = value.length - selectionEnd;
            var i = 0;
            while (extendLeft > 0 && this.lastValue[i] == value[i]) {
              i++;
              extendLeft--;
            }
            inserted = inserted.slice(i);
            i = 1;
            while (extendRight > 0 && this.lastValue.length - i > this.lastSelectionStart - 1 && this.lastValue[this.lastValue.length - i] == value[value.length - i]) {
              i++;
              extendRight--;
            }
            restoreStart -= i - 1;
            restoreEnd -= i - 1;
            var endIndex = inserted.length - i + 1;
            if (endIndex < 0) {
              extendLeft = -endIndex;
              endIndex = 0;
            }
            inserted = inserted.slice(0, endIndex);
            if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)
              return "";
            this.sendingText = true;
            var shouldReset = false;
            if (useragent.isAndroid && inserted == ". ") {
              inserted = "  ";
              shouldReset = true;
            }
            if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || this.commandMode) {
              this.host.onTextInput(inserted);
            } else {
              this.host.onTextInput(inserted, {
                extendLeft,
                extendRight,
                restoreStart,
                restoreEnd
              });
            }
            this.sendingText = false;
            this.lastValue = value;
            this.lastSelectionStart = selectionStart;
            this.lastSelectionEnd = selectionEnd;
            this.lastRestoreEnd = restoreEnd;
            return shouldReset ? "\n" : inserted;
          }
        };
        TextInput2.prototype.onSelect = function(e) {
          var _this = this;
          if (this.inComposition)
            return;
          var isAllSelected = function(text) {
            return text.selectionStart === 0 && text.selectionEnd >= _this.lastValue.length && text.value === _this.lastValue && _this.lastValue && text.selectionEnd !== _this.lastSelectionEnd;
          };
          if (this.copied) {
            this.copied = false;
          } else if (isAllSelected(this.text)) {
            this.host.selectAll();
            this.resetSelection();
          } else if (isMobile && this.text.selectionStart != this.lastSelectionStart) {
            this.resetSelection();
          }
        };
        TextInput2.prototype.$resetSelectionIOS = function(value) {
          if (!this.$isFocused || this.copied && !value || this.sendingText)
            return;
          if (!value)
            value = "";
          var newValue = "\n ab" + value + "cde fg\n";
          if (newValue != this.text.value)
            this.text.value = this.lastValue = newValue;
          var selectionStart = 4;
          var selectionEnd = 4 + (value.length || (this.host.selection.isEmpty() ? 0 : 1));
          if (this.lastSelectionStart != selectionStart || this.lastSelectionEnd != selectionEnd) {
            this.text.setSelectionRange(selectionStart, selectionEnd);
          }
          this.lastSelectionStart = selectionStart;
          this.lastSelectionEnd = selectionEnd;
        };
        TextInput2.prototype.$resetSelection = function() {
          var _this = this;
          if (this.inComposition || this.sendingText)
            return;
          if (!this.$isFocused && !this.afterContextMenu)
            return;
          this.inComposition = true;
          var selectionStart = 0;
          var selectionEnd = 0;
          var line = "";
          var positionToSelection = function(row2, column) {
            var selection2 = column;
            for (var i2 = 1; i2 <= row2 - _this.rowStart && i2 < 2 * _this.numberOfExtraLines + 1; i2++) {
              selection2 += _this.host.session.getLine(row2 - i2).length + 1;
            }
            return selection2;
          };
          if (this.host.session) {
            var selection = this.host.selection;
            var range = selection.getRange();
            var row = selection.cursor.row;
            if (row === this.rowEnd + 1) {
              this.rowStart = this.rowEnd + 1;
              this.rowEnd = this.rowStart + 2 * this.numberOfExtraLines;
            } else if (row === this.rowStart - 1) {
              this.rowEnd = this.rowStart - 1;
              this.rowStart = this.rowEnd - 2 * this.numberOfExtraLines;
            } else if (row < this.rowStart - 1 || row > this.rowEnd + 1) {
              this.rowStart = row > this.numberOfExtraLines ? row - this.numberOfExtraLines : 0;
              this.rowEnd = row > this.numberOfExtraLines ? row + this.numberOfExtraLines : 2 * this.numberOfExtraLines;
            }
            var lines = [];
            for (var i = this.rowStart; i <= this.rowEnd; i++) {
              lines.push(this.host.session.getLine(i));
            }
            line = lines.join("\n");
            selectionStart = positionToSelection(range.start.row, range.start.column);
            selectionEnd = positionToSelection(range.end.row, range.end.column);
            if (range.start.row < this.rowStart) {
              var prevLine = this.host.session.getLine(this.rowStart - 1);
              selectionStart = range.start.row < this.rowStart - 1 ? 0 : selectionStart;
              selectionEnd += prevLine.length + 1;
              line = prevLine + "\n" + line;
            } else if (range.end.row > this.rowEnd) {
              var nextLine = this.host.session.getLine(this.rowEnd + 1);
              selectionEnd = range.end.row > this.rowEnd + 1 ? nextLine.length : range.end.column;
              selectionEnd += line.length + 1;
              line = line + "\n" + nextLine;
            } else if (isMobile && row > 0) {
              line = "\n" + line;
              selectionEnd += 1;
              selectionStart += 1;
            }
            if (line.length > MAX_LINE_LENGTH) {
              if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
                line = line.slice(0, MAX_LINE_LENGTH);
              } else {
                line = "\n";
                if (selectionStart == selectionEnd) {
                  selectionStart = selectionEnd = 0;
                } else {
                  selectionStart = 0;
                  selectionEnd = 1;
                }
              }
            }
            var newValue = line + "\n\n";
            if (newValue != this.lastValue) {
              this.text.value = this.lastValue = newValue;
              this.lastSelectionStart = this.lastSelectionEnd = newValue.length;
            }
          }
          if (this.afterContextMenu) {
            this.lastSelectionStart = this.text.selectionStart;
            this.lastSelectionEnd = this.text.selectionEnd;
          }
          if (this.lastSelectionEnd != selectionEnd || this.lastSelectionStart != selectionStart || this.text.selectionEnd != this.lastSelectionEnd) {
            try {
              this.text.setSelectionRange(selectionStart, selectionEnd);
              this.lastSelectionStart = selectionStart;
              this.lastSelectionEnd = selectionEnd;
            } catch (e) {
            }
          }
          this.inComposition = false;
        };
        TextInput2.prototype.setHost = function(newHost) {
          this.host = newHost;
        };
        TextInput2.prototype.setNumberOfExtraLines = function(number) {
          this.rowStart = Number.MAX_SAFE_INTEGER;
          this.rowEnd = Number.MIN_SAFE_INTEGER;
          if (number < 0) {
            this.numberOfExtraLines = 0;
            return;
          }
          this.numberOfExtraLines = number;
        };
        TextInput2.prototype.setAriaLabel = function() {
          var ariaLabel = "";
          if (this.host.$textInputAriaLabel) {
            ariaLabel += "".concat(this.host.$textInputAriaLabel, ", ");
          }
          if (this.host.session) {
            var row = this.host.session.selection.cursor.row;
            ariaLabel += nls("text-input.aria-label", "Cursor at row $0", [row + 1]);
          }
          this.text.setAttribute("aria-label", ariaLabel);
        };
        TextInput2.prototype.setAriaOptions = function(options) {
          if (options.activeDescendant) {
            this.text.setAttribute("aria-haspopup", "true");
            this.text.setAttribute("aria-autocomplete", options.inline ? "both" : "list");
            this.text.setAttribute("aria-activedescendant", options.activeDescendant);
          } else {
            this.text.setAttribute("aria-haspopup", "false");
            this.text.setAttribute("aria-autocomplete", "both");
            this.text.removeAttribute("aria-activedescendant");
          }
          if (options.role) {
            this.text.setAttribute("role", options.role);
          }
          if (options.setLabel) {
            this.text.setAttribute("aria-roledescription", nls("text-input.aria-roledescription", "editor"));
            this.setAriaLabel();
          }
        };
        TextInput2.prototype.focus = function() {
          var _this = this;
          this.setAriaOptions({
            setLabel: this.host.renderer.enableKeyboardAccessibility
          });
          if (this.tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser")
            return this.text.focus({ preventScroll: true });
          var top = this.text.style.top;
          this.text.style.position = "fixed";
          this.text.style.top = "0px";
          try {
            var isTransformed = this.text.getBoundingClientRect().top != 0;
          } catch (e) {
            return;
          }
          var ancestors = [];
          if (isTransformed) {
            var t = this.text.parentElement;
            while (t && t.nodeType == 1) {
              ancestors.push(t);
              t.setAttribute("ace_nocontext", "true");
              if (!t.parentElement && t.getRootNode)
                t = t.getRootNode()["host"];
              else
                t = t.parentElement;
            }
          }
          this.text.focus({ preventScroll: true });
          if (isTransformed) {
            ancestors.forEach(function(p) {
              p.removeAttribute("ace_nocontext");
            });
          }
          setTimeout(function() {
            _this.text.style.position = "";
            if (_this.text.style.top == "0px")
              _this.text.style.top = top;
          }, 0);
        };
        TextInput2.prototype.blur = function() {
          this.text.blur();
        };
        TextInput2.prototype.isFocused = function() {
          return this.$isFocused;
        };
        TextInput2.prototype.setInputHandler = function(cb) {
          this.inputHandler = cb;
        };
        TextInput2.prototype.getInputHandler = function() {
          return this.inputHandler;
        };
        TextInput2.prototype.getElement = function() {
          return this.text;
        };
        TextInput2.prototype.setCommandMode = function(value) {
          this.commandMode = value;
          this.text.readOnly = false;
        };
        TextInput2.prototype.setReadOnly = function(readOnly) {
          if (!this.commandMode)
            this.text.readOnly = readOnly;
        };
        TextInput2.prototype.setCopyWithEmptySelection = function(value) {
        };
        TextInput2.prototype.onContextMenu = function(e) {
          this.afterContextMenu = true;
          this.resetSelection();
          this.host._emit("nativecontextmenu", {
            target: this.host,
            domEvent: e
          });
          this.moveToMouse(e, true);
        };
        TextInput2.prototype.moveToMouse = function(e, bringToFront) {
          var _this = this;
          if (!this.tempStyle)
            this.tempStyle = this.text.style.cssText;
          this.text.style.cssText = (bringToFront ? "z-index:100000;" : "") + (useragent.isIE ? "opacity:0.1;" : "") + "text-indent: -" + (this.lastSelectionStart + this.lastSelectionEnd) * this.host.renderer.characterWidth * 0.5 + "px;";
          var rect = this.host.container.getBoundingClientRect();
          var style2 = dom.computedStyle(this.host.container);
          var top = rect.top + (parseInt(style2.borderTopWidth) || 0);
          var left = rect.left + (parseInt(style2.borderLeftWidth) || 0);
          var maxTop = rect.bottom - top - this.text.clientHeight - 2;
          var move = function(e2) {
            dom.translate(_this.text, e2.clientX - left - 2, Math.min(e2.clientY - top - 2, maxTop));
          };
          move(e);
          if (e.type != "mousedown")
            return;
          this.host.renderer.$isMousePressed = true;
          clearTimeout(this.closeTimeout);
          if (useragent.isWin)
            event.capture(this.host.container, move, this.onContextMenuClose.bind(this));
        };
        TextInput2.prototype.destroy = function() {
          if (this.text.parentElement)
            this.text.parentElement.removeChild(this.text);
        };
        return TextInput2;
      }()
    );
    exports2.TextInput = TextInput;
    exports2.$setUserAgentForTests = function(_isMobile, _isIOS) {
      isMobile = _isMobile;
      isIOS = _isIOS;
    };
  });
  ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/useragent"], function(require2, exports2, module2) {
    var useragent = require2("../lib/useragent");
    var DRAG_OFFSET = 0;
    var SCROLL_COOLDOWN_T = 550;
    var DefaultHandlers = (
      /** @class */
      function() {
        function DefaultHandlers2(mouseHandler) {
          mouseHandler.$clickSelection = null;
          var editor2 = mouseHandler.editor;
          editor2.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
          editor2.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
          editor2.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
          editor2.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
          editor2.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
          var exports3 = [
            "select",
            "startSelect",
            "selectEnd",
            "selectAllEnd",
            "selectByWordsEnd",
            "selectByLinesEnd",
            "dragWait",
            "dragWaitEnd",
            "focusWait"
          ];
          exports3.forEach(function(x) {
            mouseHandler[x] = this[x];
          }, this);
          mouseHandler["selectByLines"] = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
          mouseHandler["selectByWords"] = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
        }
        DefaultHandlers2.prototype.onMouseDown = function(ev) {
          var inSelection = ev.inSelection();
          var pos = ev.getDocumentPosition();
          this.mousedownEvent = ev;
          var editor2 = this.editor;
          var button = ev.getButton();
          if (button !== 0) {
            var selectionRange = editor2.getSelectionRange();
            var selectionEmpty = selectionRange.isEmpty();
            if (selectionEmpty || button == 1)
              editor2.selection.moveToPosition(pos);
            if (button == 2) {
              editor2.textInput.onContextMenu(ev.domEvent);
              if (!useragent.isMozilla)
                ev.preventDefault();
            }
            return;
          }
          this.mousedownEvent.time = Date.now();
          if (inSelection && !editor2.isFocused()) {
            editor2.focus();
            if (this.$focusTimeout && !this.$clickSelection && !editor2.inMultiSelectMode) {
              this.setState("focusWait");
              this.captureMouse(ev);
              return;
            }
          }
          this.captureMouse(ev);
          this.startSelect(pos, ev.domEvent._clicks > 1);
          return ev.preventDefault();
        };
        DefaultHandlers2.prototype.startSelect = function(pos, waitForClickSelection) {
          pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
          var editor2 = this.editor;
          if (!this.mousedownEvent)
            return;
          if (this.mousedownEvent.getShiftKey())
            editor2.selection.selectToPosition(pos);
          else if (!waitForClickSelection)
            editor2.selection.moveToPosition(pos);
          if (!waitForClickSelection)
            this.select();
          editor2.setStyle("ace_selecting");
          this.setState("select");
        };
        DefaultHandlers2.prototype.select = function() {
          var anchor, editor2 = this.editor;
          var cursor = editor2.renderer.screenToTextCoordinates(this.x, this.y);
          if (this.$clickSelection) {
            var cmp = this.$clickSelection.comparePoint(cursor);
            if (cmp == -1) {
              anchor = this.$clickSelection.end;
            } else if (cmp == 1) {
              anchor = this.$clickSelection.start;
            } else {
              var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
              cursor = orientedRange.cursor;
              anchor = orientedRange.anchor;
            }
            editor2.selection.setSelectionAnchor(anchor.row, anchor.column);
          }
          editor2.selection.selectToPosition(cursor);
          editor2.renderer.scrollCursorIntoView();
        };
        DefaultHandlers2.prototype.extendSelectionBy = function(unitName) {
          var anchor, editor2 = this.editor;
          var cursor = editor2.renderer.screenToTextCoordinates(this.x, this.y);
          var range = editor2.selection[unitName](cursor.row, cursor.column);
          if (this.$clickSelection) {
            var cmpStart = this.$clickSelection.comparePoint(range.start);
            var cmpEnd = this.$clickSelection.comparePoint(range.end);
            if (cmpStart == -1 && cmpEnd <= 0) {
              anchor = this.$clickSelection.end;
              if (range.end.row != cursor.row || range.end.column != cursor.column)
                cursor = range.start;
            } else if (cmpEnd == 1 && cmpStart >= 0) {
              anchor = this.$clickSelection.start;
              if (range.start.row != cursor.row || range.start.column != cursor.column)
                cursor = range.end;
            } else if (cmpStart == -1 && cmpEnd == 1) {
              cursor = range.end;
              anchor = range.start;
            } else {
              var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
              cursor = orientedRange.cursor;
              anchor = orientedRange.anchor;
            }
            editor2.selection.setSelectionAnchor(anchor.row, anchor.column);
          }
          editor2.selection.selectToPosition(cursor);
          editor2.renderer.scrollCursorIntoView();
        };
        DefaultHandlers2.prototype.selectByLinesEnd = function() {
          this.$clickSelection = null;
          this.editor.unsetStyle("ace_selecting");
        };
        DefaultHandlers2.prototype.focusWait = function() {
          var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
          var time = Date.now();
          if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)
            this.startSelect(this.mousedownEvent.getDocumentPosition());
        };
        DefaultHandlers2.prototype.onDoubleClick = function(ev) {
          var pos = ev.getDocumentPosition();
          var editor2 = this.editor;
          var session = editor2.session;
          var range = session.getBracketRange(pos);
          if (range) {
            if (range.isEmpty()) {
              range.start.column--;
              range.end.column++;
            }
            this.setState("select");
          } else {
            range = editor2.selection.getWordRange(pos.row, pos.column);
            this.setState("selectByWords");
          }
          this.$clickSelection = range;
          this.select();
        };
        DefaultHandlers2.prototype.onTripleClick = function(ev) {
          var pos = ev.getDocumentPosition();
          var editor2 = this.editor;
          this.setState("selectByLines");
          var range = editor2.getSelectionRange();
          if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
            this.$clickSelection = editor2.selection.getLineRange(range.start.row);
            this.$clickSelection.end = editor2.selection.getLineRange(range.end.row).end;
          } else {
            this.$clickSelection = editor2.selection.getLineRange(pos.row);
          }
          this.select();
        };
        DefaultHandlers2.prototype.onQuadClick = function(ev) {
          var editor2 = this.editor;
          editor2.selectAll();
          this.$clickSelection = editor2.getSelectionRange();
          this.setState("selectAll");
        };
        DefaultHandlers2.prototype.onMouseWheel = function(ev) {
          if (ev.getAccelKey())
            return;
          if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
            ev.wheelX = ev.wheelY;
            ev.wheelY = 0;
          }
          var editor2 = this.editor;
          if (!this.$lastScroll)
            this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };
          var prevScroll = this.$lastScroll;
          var t = ev.domEvent.timeStamp;
          var dt = t - prevScroll.t;
          var vx = dt ? ev.wheelX / dt : prevScroll.vx;
          var vy = dt ? ev.wheelY / dt : prevScroll.vy;
          if (dt < SCROLL_COOLDOWN_T) {
            vx = (vx + prevScroll.vx) / 2;
            vy = (vy + prevScroll.vy) / 2;
          }
          var direction = Math.abs(vx / vy);
          var canScroll = false;
          if (direction >= 1 && editor2.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
            canScroll = true;
          if (direction <= 1 && editor2.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
            canScroll = true;
          if (canScroll) {
            prevScroll.allowed = t;
          } else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {
            var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx) && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);
            if (isSlower) {
              canScroll = true;
              prevScroll.allowed = t;
            } else {
              prevScroll.allowed = 0;
            }
          }
          prevScroll.t = t;
          prevScroll.vx = vx;
          prevScroll.vy = vy;
          if (canScroll) {
            editor2.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
          }
        };
        return DefaultHandlers2;
      }()
    );
    DefaultHandlers.prototype.selectEnd = DefaultHandlers.prototype.selectByLinesEnd;
    DefaultHandlers.prototype.selectAllEnd = DefaultHandlers.prototype.selectByLinesEnd;
    DefaultHandlers.prototype.selectByWordsEnd = DefaultHandlers.prototype.selectByLinesEnd;
    exports2.DefaultHandlers = DefaultHandlers;
    function calcDistance(ax, ay, bx, by) {
      return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
    }
    function calcRangeOrientation(range, cursor) {
      if (range.start.row == range.end.row)
        var cmp = 2 * cursor.column - range.start.column - range.end.column;
      else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
        var cmp = cursor.column - 4;
      else
        var cmp = 2 * cursor.row - range.start.row - range.end.row;
      if (cmp < 0)
        return { cursor: range.start, anchor: range.end };
      else
        return { cursor: range.end, anchor: range.start };
    }
  });
  ace.define("ace/lib/scroll", ["require", "exports", "module"], function(require2, exports2, module2) {
    exports2.preventParentScroll = function preventParentScroll(event) {
      event.stopPropagation();
      var target = event.currentTarget;
      var contentOverflows = target.scrollHeight > target.clientHeight;
      if (!contentOverflows) {
        event.preventDefault();
      }
    };
  });
  ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/range", "ace/lib/scroll"], function(require2, exports2, module2) {
    var __extends = this && this.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __values = this && this.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var dom = require2("./lib/dom");
    require2("./lib/event");
    var Range = require2("./range").Range;
    var preventParentScroll = require2("./lib/scroll").preventParentScroll;
    var CLASSNAME = "ace_tooltip";
    var Tooltip = (
      /** @class */
      function() {
        function Tooltip2(parentNode) {
          this.isOpen = false;
          this.$element = null;
          this.$parentNode = parentNode;
        }
        Tooltip2.prototype.$init = function() {
          this.$element = dom.createElement("div");
          this.$element.className = CLASSNAME;
          this.$element.style.display = "none";
          this.$parentNode.appendChild(this.$element);
          return this.$element;
        };
        Tooltip2.prototype.getElement = function() {
          return this.$element || this.$init();
        };
        Tooltip2.prototype.setText = function(text) {
          this.getElement().textContent = text;
        };
        Tooltip2.prototype.setHtml = function(html) {
          this.getElement().innerHTML = html;
        };
        Tooltip2.prototype.setPosition = function(x, y) {
          var el = this.getElement();
          var rootRect = el.offsetParent && el.offsetParent.getBoundingClientRect();
          el.style.left = x - (rootRect ? rootRect.left : 0) + "px";
          el.style.top = y - (rootRect ? rootRect.top : 0) + "px";
        };
        Tooltip2.prototype.setClassName = function(className) {
          dom.addCssClass(this.getElement(), className);
        };
        Tooltip2.prototype.setTheme = function(theme) {
          this.$element.className = CLASSNAME + " " + (theme.isDark ? "ace_dark " : "") + (theme.cssClass || "");
        };
        Tooltip2.prototype.show = function(text, x, y) {
          if (text != null)
            this.setText(text);
          if (x != null && y != null)
            this.setPosition(x, y);
          if (!this.isOpen) {
            this.getElement().style.display = "block";
            this.isOpen = true;
          }
        };
        Tooltip2.prototype.hide = function(e) {
          if (this.isOpen) {
            this.getElement().style.display = "none";
            this.getElement().className = CLASSNAME;
            this.isOpen = false;
          }
        };
        Tooltip2.prototype.getHeight = function() {
          return this.getElement().offsetHeight;
        };
        Tooltip2.prototype.getWidth = function() {
          return this.getElement().offsetWidth;
        };
        Tooltip2.prototype.destroy = function() {
          this.isOpen = false;
          if (this.$element && this.$element.parentNode) {
            this.$element.parentNode.removeChild(this.$element);
          }
        };
        return Tooltip2;
      }()
    );
    var PopupManager = (
      /** @class */
      function() {
        function PopupManager2() {
          this.popups = [];
        }
        PopupManager2.prototype.addPopup = function(popup) {
          this.popups.push(popup);
          this.updatePopups();
        };
        PopupManager2.prototype.removePopup = function(popup) {
          var index2 = this.popups.indexOf(popup);
          if (index2 !== -1) {
            this.popups.splice(index2, 1);
            this.updatePopups();
          }
        };
        PopupManager2.prototype.updatePopups = function() {
          var e_1, _a, e_2, _b;
          this.popups.sort(function(a, b) {
            return b.priority - a.priority;
          });
          var visiblepopups = [];
          try {
            for (var _c = __values(this.popups), _d = _c.next(); !_d.done; _d = _c.next()) {
              var popup = _d.value;
              var shouldDisplay = true;
              try {
                for (var visiblepopups_1 = (e_2 = void 0, __values(visiblepopups)), visiblepopups_1_1 = visiblepopups_1.next(); !visiblepopups_1_1.done; visiblepopups_1_1 = visiblepopups_1.next()) {
                  var visiblePopup = visiblepopups_1_1.value;
                  if (this.doPopupsOverlap(visiblePopup, popup)) {
                    shouldDisplay = false;
                    break;
                  }
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (visiblepopups_1_1 && !visiblepopups_1_1.done && (_b = visiblepopups_1.return)) _b.call(visiblepopups_1);
                } finally {
                  if (e_2) throw e_2.error;
                }
              }
              if (shouldDisplay) {
                visiblepopups.push(popup);
              } else {
                popup.hide();
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        };
        PopupManager2.prototype.doPopupsOverlap = function(popupA, popupB) {
          var rectA = popupA.getElement().getBoundingClientRect();
          var rectB = popupB.getElement().getBoundingClientRect();
          return rectA.left < rectB.right && rectA.right > rectB.left && rectA.top < rectB.bottom && rectA.bottom > rectB.top;
        };
        return PopupManager2;
      }()
    );
    var popupManager = new PopupManager();
    exports2.popupManager = popupManager;
    exports2.Tooltip = Tooltip;
    var HoverTooltip = (
      /** @class */
      function(_super) {
        __extends(HoverTooltip2, _super);
        function HoverTooltip2(parentNode) {
          if (parentNode === void 0) {
            parentNode = document.body;
          }
          var _this = _super.call(this, parentNode) || this;
          _this.timeout = void 0;
          _this.lastT = 0;
          _this.idleTime = 350;
          _this.lastEvent = void 0;
          _this.onMouseOut = _this.onMouseOut.bind(_this);
          _this.onMouseMove = _this.onMouseMove.bind(_this);
          _this.waitForHover = _this.waitForHover.bind(_this);
          _this.hide = _this.hide.bind(_this);
          var el = _this.getElement();
          el.style.whiteSpace = "pre-wrap";
          el.style.pointerEvents = "auto";
          el.addEventListener("mouseout", _this.onMouseOut);
          el.tabIndex = -1;
          el.addEventListener("blur", (function() {
            if (!el.contains(document.activeElement))
              this.hide();
          }).bind(_this));
          el.addEventListener("wheel", preventParentScroll);
          return _this;
        }
        HoverTooltip2.prototype.addToEditor = function(editor2) {
          editor2.on("mousemove", this.onMouseMove);
          editor2.on("mousedown", this.hide);
          editor2.renderer.getMouseEventTarget().addEventListener("mouseout", this.onMouseOut, true);
        };
        HoverTooltip2.prototype.removeFromEditor = function(editor2) {
          editor2.off("mousemove", this.onMouseMove);
          editor2.off("mousedown", this.hide);
          editor2.renderer.getMouseEventTarget().removeEventListener("mouseout", this.onMouseOut, true);
          if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
          }
        };
        HoverTooltip2.prototype.onMouseMove = function(e, editor2) {
          this.lastEvent = e;
          this.lastT = Date.now();
          var isMousePressed = editor2.$mouseHandler.isMousePressed;
          if (this.isOpen) {
            var pos = this.lastEvent && this.lastEvent.getDocumentPosition();
            if (!this.range || !this.range.contains(pos.row, pos.column) || isMousePressed || this.isOutsideOfText(this.lastEvent)) {
              this.hide();
            }
          }
          if (this.timeout || isMousePressed)
            return;
          this.lastEvent = e;
          this.timeout = setTimeout(this.waitForHover, this.idleTime);
        };
        HoverTooltip2.prototype.waitForHover = function() {
          if (this.timeout)
            clearTimeout(this.timeout);
          var dt = Date.now() - this.lastT;
          if (this.idleTime - dt > 10) {
            this.timeout = setTimeout(this.waitForHover, this.idleTime - dt);
            return;
          }
          this.timeout = null;
          if (this.lastEvent && !this.isOutsideOfText(this.lastEvent)) {
            this.$gatherData(this.lastEvent, this.lastEvent.editor);
          }
        };
        HoverTooltip2.prototype.isOutsideOfText = function(e) {
          var editor2 = e.editor;
          var docPos = e.getDocumentPosition();
          var line = editor2.session.getLine(docPos.row);
          if (docPos.column == line.length) {
            var screenPos = editor2.renderer.pixelToScreenCoordinates(e.clientX, e.clientY);
            var clippedPos = editor2.session.documentToScreenPosition(docPos.row, docPos.column);
            if (clippedPos.column != screenPos.column || clippedPos.row != screenPos.row) {
              return true;
            }
          }
          return false;
        };
        HoverTooltip2.prototype.setDataProvider = function(value) {
          this.$gatherData = value;
        };
        HoverTooltip2.prototype.showForRange = function(editor2, range, domNode, startingEvent) {
          var MARGIN = 10;
          if (startingEvent && startingEvent != this.lastEvent)
            return;
          if (this.isOpen && document.activeElement == this.getElement())
            return;
          var renderer = editor2.renderer;
          if (!this.isOpen) {
            popupManager.addPopup(this);
            this.$registerCloseEvents();
            this.setTheme(renderer.theme);
          }
          this.isOpen = true;
          this.addMarker(range, editor2.session);
          this.range = Range.fromPoints(range.start, range.end);
          var position = renderer.textToScreenCoordinates(range.start.row, range.start.column);
          var rect = renderer.scroller.getBoundingClientRect();
          if (position.pageX < rect.left)
            position.pageX = rect.left;
          var element = this.getElement();
          element.innerHTML = "";
          element.appendChild(domNode);
          element.style.maxHeight = "";
          element.style.display = "block";
          var labelHeight = element.clientHeight;
          var labelWidth = element.clientWidth;
          var spaceBelow = window.innerHeight - position.pageY - renderer.lineHeight;
          var isAbove = true;
          if (position.pageY - labelHeight < 0 && position.pageY < spaceBelow) {
            isAbove = false;
          }
          element.style.maxHeight = (isAbove ? position.pageY : spaceBelow) - MARGIN + "px";
          element.style.top = isAbove ? "" : position.pageY + renderer.lineHeight + "px";
          element.style.bottom = isAbove ? window.innerHeight - position.pageY + "px" : "";
          element.style.left = Math.min(position.pageX, window.innerWidth - labelWidth - MARGIN) + "px";
        };
        HoverTooltip2.prototype.addMarker = function(range, session) {
          if (this.marker) {
            this.$markerSession.removeMarker(this.marker);
          }
          this.$markerSession = session;
          this.marker = session && session.addMarker(range, "ace_highlight-marker", "text");
        };
        HoverTooltip2.prototype.hide = function(e) {
          if (!e && document.activeElement == this.getElement())
            return;
          if (e && e.target && (e.type != "keydown" || e.ctrlKey || e.metaKey) && this.$element.contains(e.target))
            return;
          this.lastEvent = null;
          if (this.timeout)
            clearTimeout(this.timeout);
          this.timeout = null;
          this.addMarker(null);
          if (this.isOpen) {
            this.$removeCloseEvents();
            this.getElement().style.display = "none";
            this.isOpen = false;
            popupManager.removePopup(this);
          }
        };
        HoverTooltip2.prototype.$registerCloseEvents = function() {
          window.addEventListener("keydown", this.hide, true);
          window.addEventListener("wheel", this.hide, true);
          window.addEventListener("mousedown", this.hide, true);
        };
        HoverTooltip2.prototype.$removeCloseEvents = function() {
          window.removeEventListener("keydown", this.hide, true);
          window.removeEventListener("wheel", this.hide, true);
          window.removeEventListener("mousedown", this.hide, true);
        };
        HoverTooltip2.prototype.onMouseOut = function(e) {
          if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
          }
          this.lastEvent = null;
          if (!this.isOpen)
            return;
          if (!e.relatedTarget || this.getElement().contains(e.relatedTarget))
            return;
          if (e && e.currentTarget.contains(e.relatedTarget))
            return;
          if (!e.relatedTarget.classList.contains("ace_content"))
            this.hide();
        };
        return HoverTooltip2;
      }(Tooltip)
    );
    exports2.HoverTooltip = HoverTooltip;
  });
  ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/tooltip", "ace/config"], function(require2, exports2, module2) {
    var __extends = this && this.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __values = this && this.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var dom = require2("../lib/dom");
    var event = require2("../lib/event");
    var Tooltip = require2("../tooltip").Tooltip;
    var nls = require2("../config").nls;
    var GUTTER_TOOLTIP_LEFT_OFFSET = 5;
    var GUTTER_TOOLTIP_TOP_OFFSET = 3;
    exports2.GUTTER_TOOLTIP_LEFT_OFFSET = GUTTER_TOOLTIP_LEFT_OFFSET;
    exports2.GUTTER_TOOLTIP_TOP_OFFSET = GUTTER_TOOLTIP_TOP_OFFSET;
    function GutterHandler(mouseHandler) {
      var editor2 = mouseHandler.editor;
      var gutter = editor2.renderer.$gutterLayer;
      var tooltip = new GutterTooltip(editor2, true);
      mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
        if (!editor2.isFocused() || e.getButton() != 0)
          return;
        var gutterRegion = gutter.getRegion(e);
        if (gutterRegion == "foldWidgets")
          return;
        var row = e.getDocumentPosition().row;
        var selection = editor2.session.selection;
        if (e.getShiftKey())
          selection.selectTo(row, 0);
        else {
          if (e.domEvent.detail == 2) {
            editor2.selectAll();
            return e.preventDefault();
          }
          mouseHandler.$clickSelection = editor2.selection.getLineRange(row);
        }
        mouseHandler.setState("selectByLines");
        mouseHandler.captureMouse(e);
        return e.preventDefault();
      });
      var tooltipTimeout, mouseEvent;
      function showTooltip() {
        var row = mouseEvent.getDocumentPosition().row;
        var maxRow = editor2.session.getLength();
        if (row == maxRow) {
          var screenRow = editor2.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
          var pos = mouseEvent.$pos;
          if (screenRow > editor2.session.documentToScreenRow(pos.row, pos.column))
            return hideTooltip();
        }
        tooltip.showTooltip(row);
        if (!tooltip.isOpen)
          return;
        editor2.on("mousewheel", hideTooltip);
        editor2.on("changeSession", hideTooltip);
        window.addEventListener("keydown", hideTooltip, true);
        if (mouseHandler.$tooltipFollowsMouse) {
          moveTooltip(mouseEvent);
        } else {
          var gutterRow = mouseEvent.getGutterRow();
          var gutterCell = gutter.$lines.get(gutterRow);
          if (gutterCell) {
            var gutterElement = gutterCell.element.querySelector(".ace_gutter_annotation");
            var rect = gutterElement.getBoundingClientRect();
            var style2 = tooltip.getElement().style;
            style2.left = rect.right - GUTTER_TOOLTIP_LEFT_OFFSET + "px";
            style2.top = rect.bottom - GUTTER_TOOLTIP_TOP_OFFSET + "px";
          } else {
            moveTooltip(mouseEvent);
          }
        }
      }
      function hideTooltip(e) {
        if (e && e.type === "keydown" && (e.ctrlKey || e.metaKey))
          return;
        if (e && e.type === "mouseout" && (!e.relatedTarget || tooltip.getElement().contains(e.relatedTarget)))
          return;
        if (tooltipTimeout)
          tooltipTimeout = clearTimeout(tooltipTimeout);
        if (tooltip.isOpen) {
          tooltip.hideTooltip();
          editor2.off("mousewheel", hideTooltip);
          editor2.off("changeSession", hideTooltip);
          window.removeEventListener("keydown", hideTooltip, true);
        }
      }
      function moveTooltip(e) {
        tooltip.setPosition(e.x, e.y);
      }
      mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
        var target = e.domEvent.target || e.domEvent.srcElement;
        if (dom.hasCssClass(target, "ace_fold-widget") || dom.hasCssClass(target, "ace_custom-widget"))
          return hideTooltip();
        if (tooltip.isOpen && mouseHandler.$tooltipFollowsMouse)
          moveTooltip(e);
        mouseEvent = e;
        if (tooltipTimeout)
          return;
        tooltipTimeout = setTimeout(function() {
          tooltipTimeout = null;
          if (mouseEvent && !mouseHandler.isMousePressed)
            showTooltip();
        }, 50);
      });
      event.addListener(editor2.renderer.$gutter, "mouseout", function(e) {
        mouseEvent = null;
        if (!tooltip.isOpen)
          return;
        tooltipTimeout = setTimeout(function() {
          tooltipTimeout = null;
          hideTooltip(e);
        }, 50);
      }, editor2);
    }
    exports2.GutterHandler = GutterHandler;
    var GutterTooltip = (
      /** @class */
      function(_super) {
        __extends(GutterTooltip2, _super);
        function GutterTooltip2(editor2, isHover) {
          if (isHover === void 0) {
            isHover = false;
          }
          var _this = _super.call(this, editor2.container) || this;
          _this.id = "gt" + ++GutterTooltip2.$uid;
          _this.editor = editor2;
          _this.visibleTooltipRow;
          var el = _this.getElement();
          el.setAttribute("role", "tooltip");
          el.setAttribute("id", _this.id);
          el.style.pointerEvents = "auto";
          if (isHover) {
            _this.onMouseOut = _this.onMouseOut.bind(_this);
            el.addEventListener("mouseout", _this.onMouseOut);
          }
          return _this;
        }
        GutterTooltip2.prototype.onMouseOut = function(e) {
          if (!this.isOpen)
            return;
          if (!e.relatedTarget || this.getElement().contains(e.relatedTarget))
            return;
          if (e && e.currentTarget.contains(e.relatedTarget))
            return;
          this.hideTooltip();
        };
        GutterTooltip2.prototype.setPosition = function(x, y) {
          var windowWidth = window.innerWidth || document.documentElement.clientWidth;
          var windowHeight = window.innerHeight || document.documentElement.clientHeight;
          var width = this.getWidth();
          var height = this.getHeight();
          x += 15;
          y += 15;
          if (x + width > windowWidth) {
            x -= x + width - windowWidth;
          }
          if (y + height > windowHeight) {
            y -= 20 + height;
          }
          Tooltip.prototype.setPosition.call(this, x, y);
        };
        Object.defineProperty(GutterTooltip2, "annotationLabels", {
          get: function() {
            return {
              error: {
                singular: nls("gutter-tooltip.aria-label.error.singular", "error"),
                plural: nls("gutter-tooltip.aria-label.error.plural", "errors")
              },
              security: {
                singular: nls("gutter-tooltip.aria-label.security.singular", "security finding"),
                plural: nls("gutter-tooltip.aria-label.security.plural", "security findings")
              },
              warning: {
                singular: nls("gutter-tooltip.aria-label.warning.singular", "warning"),
                plural: nls("gutter-tooltip.aria-label.warning.plural", "warnings")
              },
              info: {
                singular: nls("gutter-tooltip.aria-label.info.singular", "information message"),
                plural: nls("gutter-tooltip.aria-label.info.plural", "information messages")
              },
              hint: {
                singular: nls("gutter-tooltip.aria-label.hint.singular", "suggestion"),
                plural: nls("gutter-tooltip.aria-label.hint.plural", "suggestions")
              }
            };
          },
          enumerable: false,
          configurable: true
        });
        GutterTooltip2.prototype.showTooltip = function(row) {
          var _a;
          var gutter = this.editor.renderer.$gutterLayer;
          var annotationsInRow = gutter.$annotations[row];
          var annotation;
          if (annotationsInRow)
            annotation = {
              displayText: Array.from(annotationsInRow.displayText),
              type: Array.from(annotationsInRow.type)
            };
          else
            annotation = { displayText: [], type: [] };
          var fold = gutter.session.getFoldLine(row);
          if (fold && gutter.$showFoldedAnnotations) {
            var annotationsInFold = { error: [], security: [], warning: [], info: [], hint: [] };
            var severityRank = { error: 1, security: 2, warning: 3, info: 4, hint: 5 };
            var mostSevereAnnotationTypeInFold;
            for (var i = row + 1; i <= fold.end.row; i++) {
              if (!gutter.$annotations[i])
                continue;
              for (var j = 0; j < gutter.$annotations[i].text.length; j++) {
                var annotationType = gutter.$annotations[i].type[j];
                annotationsInFold[annotationType].push(gutter.$annotations[i].text[j]);
                if (!mostSevereAnnotationTypeInFold || severityRank[annotationType] < severityRank[mostSevereAnnotationTypeInFold]) {
                  mostSevereAnnotationTypeInFold = annotationType;
                }
              }
            }
            if (["error", "security", "warning"].includes(mostSevereAnnotationTypeInFold)) {
              var summaryFoldedAnnotations = "".concat(GutterTooltip2.annotationsToSummaryString(annotationsInFold), " in folded code.");
              annotation.displayText.push(summaryFoldedAnnotations);
              annotation.type.push(mostSevereAnnotationTypeInFold + "_fold");
            }
          }
          if (annotation.displayText.length === 0)
            return this.hideTooltip();
          var annotationMessages = { error: [], security: [], warning: [], info: [], hint: [] };
          var iconClassName = gutter.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
          for (var i = 0; i < annotation.displayText.length; i++) {
            var lineElement = dom.createElement("span");
            var iconElement = dom.createElement("span");
            (_a = iconElement.classList).add.apply(_a, ["ace_".concat(annotation.type[i]), iconClassName]);
            iconElement.setAttribute("aria-label", "".concat(GutterTooltip2.annotationLabels[annotation.type[i].replace("_fold", "")].singular));
            iconElement.setAttribute("role", "img");
            iconElement.appendChild(dom.createTextNode(" "));
            lineElement.appendChild(iconElement);
            lineElement.appendChild(dom.createTextNode(annotation.displayText[i]));
            lineElement.appendChild(dom.createElement("br"));
            annotationMessages[annotation.type[i].replace("_fold", "")].push(lineElement);
          }
          var tooltipElement = this.getElement();
          dom.removeChildren(tooltipElement);
          annotationMessages.error.forEach(function(el) {
            return tooltipElement.appendChild(el);
          });
          annotationMessages.security.forEach(function(el) {
            return tooltipElement.appendChild(el);
          });
          annotationMessages.warning.forEach(function(el) {
            return tooltipElement.appendChild(el);
          });
          annotationMessages.info.forEach(function(el) {
            return tooltipElement.appendChild(el);
          });
          annotationMessages.hint.forEach(function(el) {
            return tooltipElement.appendChild(el);
          });
          tooltipElement.setAttribute("aria-live", "polite");
          if (!this.isOpen) {
            this.setTheme(this.editor.renderer.theme);
            this.setClassName("ace_gutter-tooltip");
          }
          var annotationNode = this.$findLinkedAnnotationNode(row);
          if (annotationNode) {
            annotationNode.setAttribute("aria-describedby", this.id);
          }
          this.show();
          this.visibleTooltipRow = row;
          this.editor._signal("showGutterTooltip", this);
        };
        GutterTooltip2.prototype.$findLinkedAnnotationNode = function(row) {
          var cell = this.$findCellByRow(row);
          if (cell) {
            var element = cell.element;
            if (element.childNodes.length > 2) {
              return element.childNodes[2];
            }
          }
        };
        GutterTooltip2.prototype.$findCellByRow = function(row) {
          return this.editor.renderer.$gutterLayer.$lines.cells.find(function(el) {
            return el.row === row;
          });
        };
        GutterTooltip2.prototype.hideTooltip = function() {
          if (!this.isOpen) {
            return;
          }
          this.$element.removeAttribute("aria-live");
          this.hide();
          if (this.visibleTooltipRow != void 0) {
            var annotationNode = this.$findLinkedAnnotationNode(this.visibleTooltipRow);
            if (annotationNode) {
              annotationNode.removeAttribute("aria-describedby");
            }
          }
          this.visibleTooltipRow = void 0;
          this.editor._signal("hideGutterTooltip", this);
        };
        GutterTooltip2.annotationsToSummaryString = function(annotations) {
          var e_1, _a;
          var summary = [];
          var annotationTypes = ["error", "security", "warning", "info", "hint"];
          try {
            for (var annotationTypes_1 = __values(annotationTypes), annotationTypes_1_1 = annotationTypes_1.next(); !annotationTypes_1_1.done; annotationTypes_1_1 = annotationTypes_1.next()) {
              var annotationType = annotationTypes_1_1.value;
              if (!annotations[annotationType].length)
                continue;
              var label = annotations[annotationType].length === 1 ? GutterTooltip2.annotationLabels[annotationType].singular : GutterTooltip2.annotationLabels[annotationType].plural;
              summary.push("".concat(annotations[annotationType].length, " ").concat(label));
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (annotationTypes_1_1 && !annotationTypes_1_1.done && (_a = annotationTypes_1.return)) _a.call(annotationTypes_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return summary.join(", ");
        };
        return GutterTooltip2;
      }(Tooltip)
    );
    GutterTooltip.$uid = 0;
    exports2.GutterTooltip = GutterTooltip;
  });
  ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(require2, exports2, module2) {
    var event = require2("../lib/event");
    var useragent = require2("../lib/useragent");
    var MouseEvent = (
      /** @class */
      function() {
        function MouseEvent2(domEvent, editor2) {
          this.speed;
          this.wheelX;
          this.wheelY;
          this.domEvent = domEvent;
          this.editor = editor2;
          this.x = this.clientX = domEvent.clientX;
          this.y = this.clientY = domEvent.clientY;
          this.$pos = null;
          this.$inSelection = null;
          this.propagationStopped = false;
          this.defaultPrevented = false;
        }
        MouseEvent2.prototype.stopPropagation = function() {
          event.stopPropagation(this.domEvent);
          this.propagationStopped = true;
        };
        MouseEvent2.prototype.preventDefault = function() {
          event.preventDefault(this.domEvent);
          this.defaultPrevented = true;
        };
        MouseEvent2.prototype.stop = function() {
          this.stopPropagation();
          this.preventDefault();
        };
        MouseEvent2.prototype.getDocumentPosition = function() {
          if (this.$pos)
            return this.$pos;
          this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
          return this.$pos;
        };
        MouseEvent2.prototype.getGutterRow = function() {
          var documentRow = this.getDocumentPosition().row;
          var screenRow = this.editor.session.documentToScreenRow(documentRow, 0);
          var screenTopRow = this.editor.session.documentToScreenRow(this.editor.renderer.$gutterLayer.$lines.get(0).row, 0);
          return screenRow - screenTopRow;
        };
        MouseEvent2.prototype.inSelection = function() {
          if (this.$inSelection !== null)
            return this.$inSelection;
          var editor2 = this.editor;
          var selectionRange = editor2.getSelectionRange();
          if (selectionRange.isEmpty())
            this.$inSelection = false;
          else {
            var pos = this.getDocumentPosition();
            this.$inSelection = selectionRange.contains(pos.row, pos.column);
          }
          return this.$inSelection;
        };
        MouseEvent2.prototype.getButton = function() {
          return event.getButton(this.domEvent);
        };
        MouseEvent2.prototype.getShiftKey = function() {
          return this.domEvent.shiftKey;
        };
        MouseEvent2.prototype.getAccelKey = function() {
          return useragent.isMac ? this.domEvent.metaKey : this.domEvent.ctrlKey;
        };
        return MouseEvent2;
      }()
    );
    exports2.MouseEvent = MouseEvent;
  });
  ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function(require2, exports2, module2) {
    var dom = require2("../lib/dom");
    var event = require2("../lib/event");
    var useragent = require2("../lib/useragent");
    var AUTOSCROLL_DELAY = 200;
    var SCROLL_CURSOR_DELAY = 200;
    var SCROLL_CURSOR_HYSTERESIS = 5;
    function DragdropHandler(mouseHandler) {
      var editor2 = mouseHandler.editor;
      var dragImage = dom.createElement("div");
      dragImage.style.cssText = "top:-100px;position:absolute;z-index:2147483647;opacity:0.5";
      dragImage.textContent = " ";
      var exports3 = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
      exports3.forEach(function(x2) {
        mouseHandler[x2] = this[x2];
      }, this);
      editor2.on("mousedown", this.onMouseDown.bind(mouseHandler));
      var mouseTarget = editor2.container;
      var dragSelectionMarker, x, y;
      var timerId, range;
      var dragCursor, counter = 0;
      var dragOperation;
      var isInternal;
      var autoScrollStartTime;
      var cursorMovedTime;
      var cursorPointOnCaretMoved;
      this.onDragStart = function(e) {
        if (this.cancelDrag || !mouseTarget.draggable) {
          var self2 = this;
          setTimeout(function() {
            self2.startSelect();
            self2.captureMouse(e);
          }, 0);
          return e.preventDefault();
        }
        range = editor2.getSelectionRange();
        var dataTransfer = e.dataTransfer;
        dataTransfer.effectAllowed = editor2.getReadOnly() ? "copy" : "copyMove";
        editor2.container.appendChild(dragImage);
        dataTransfer.setDragImage && dataTransfer.setDragImage(dragImage, 0, 0);
        setTimeout(function() {
          editor2.container.removeChild(dragImage);
        });
        dataTransfer.clearData();
        dataTransfer.setData("Text", editor2.session.getTextRange());
        isInternal = true;
        this.setState("drag");
      };
      this.onDragEnd = function(e) {
        mouseTarget.draggable = false;
        isInternal = false;
        this.setState(null);
        if (!editor2.getReadOnly()) {
          var dropEffect = e.dataTransfer.dropEffect;
          if (!dragOperation && dropEffect == "move")
            editor2.session.remove(editor2.getSelectionRange());
          editor2.$resetCursorStyle();
        }
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
      };
      this.onDragEnter = function(e) {
        if (editor2.getReadOnly() || !canAccept(e.dataTransfer))
          return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker)
          addDragMarker();
        counter++;
        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
      };
      this.onDragOver = function(e) {
        if (editor2.getReadOnly() || !canAccept(e.dataTransfer))
          return;
        x = e.clientX;
        y = e.clientY;
        if (!dragSelectionMarker) {
          addDragMarker();
          counter++;
        }
        if (onMouseMoveTimer !== null)
          onMouseMoveTimer = null;
        e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
        return event.preventDefault(e);
      };
      this.onDragLeave = function(e) {
        counter--;
        if (counter <= 0 && dragSelectionMarker) {
          clearDragMarker();
          dragOperation = null;
          return event.preventDefault(e);
        }
      };
      this.onDrop = function(e) {
        if (!dragCursor)
          return;
        var dataTransfer = e.dataTransfer;
        if (isInternal) {
          switch (dragOperation) {
            case "move":
              if (range.contains(dragCursor.row, dragCursor.column)) {
                range = {
                  start: dragCursor,
                  end: dragCursor
                };
              } else {
                range = editor2.moveText(range, dragCursor);
              }
              break;
            case "copy":
              range = editor2.moveText(range, dragCursor, true);
              break;
          }
        } else {
          var dropData = dataTransfer.getData("Text");
          range = {
            start: dragCursor,
            end: editor2.session.insert(dragCursor, dropData)
          };
          editor2.focus();
          dragOperation = null;
        }
        clearDragMarker();
        return event.preventDefault(e);
      };
      event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler), editor2);
      event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler), editor2);
      event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler), editor2);
      event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler), editor2);
      event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler), editor2);
      event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler), editor2);
      function scrollCursorIntoView(cursor, prevCursor) {
        var now2 = Date.now();
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        var hMovement = !prevCursor || cursor.column != prevCursor.column;
        if (!cursorMovedTime || vMovement || hMovement) {
          editor2.moveCursorToPosition(cursor);
          cursorMovedTime = now2;
          cursorPointOnCaretMoved = { x, y };
        } else {
          var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
          if (distance > SCROLL_CURSOR_HYSTERESIS) {
            cursorMovedTime = null;
          } else if (now2 - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
            editor2.renderer.scrollCursorIntoView();
            cursorMovedTime = null;
          }
        }
      }
      function autoScroll(cursor, prevCursor) {
        var now2 = Date.now();
        var lineHeight = editor2.renderer.layerConfig.lineHeight;
        var characterWidth = editor2.renderer.layerConfig.characterWidth;
        var editorRect = editor2.renderer.scroller.getBoundingClientRect();
        var offsets = {
          x: {
            left: x - editorRect.left,
            right: editorRect.right - x
          },
          y: {
            top: y - editorRect.top,
            bottom: editorRect.bottom - y
          }
        };
        var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
        var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
        var scrollCursor = { row: cursor.row, column: cursor.column };
        if (nearestXOffset / characterWidth <= 2) {
          scrollCursor.column += offsets.x.left < offsets.x.right ? -3 : 2;
        }
        if (nearestYOffset / lineHeight <= 1) {
          scrollCursor.row += offsets.y.top < offsets.y.bottom ? -1 : 1;
        }
        var vScroll = cursor.row != scrollCursor.row;
        var hScroll = cursor.column != scrollCursor.column;
        var vMovement = !prevCursor || cursor.row != prevCursor.row;
        if (vScroll || hScroll && !vMovement) {
          if (!autoScrollStartTime)
            autoScrollStartTime = now2;
          else if (now2 - autoScrollStartTime >= AUTOSCROLL_DELAY)
            editor2.renderer.scrollCursorIntoView(scrollCursor);
        } else {
          autoScrollStartTime = null;
        }
      }
      function onDragInterval() {
        var prevCursor = dragCursor;
        dragCursor = editor2.renderer.screenToTextCoordinates(x, y);
        scrollCursorIntoView(dragCursor, prevCursor);
        autoScroll(dragCursor, prevCursor);
      }
      function addDragMarker() {
        range = editor2.selection.toOrientedRange();
        dragSelectionMarker = editor2.session.addMarker(range, "ace_selection", editor2.getSelectionStyle());
        editor2.clearSelection();
        if (editor2.isFocused())
          editor2.renderer.$cursorLayer.setBlinking(false);
        clearInterval(timerId);
        onDragInterval();
        timerId = setInterval(onDragInterval, 20);
        counter = 0;
        event.addListener(document, "mousemove", onMouseMove);
      }
      function clearDragMarker() {
        clearInterval(timerId);
        editor2.session.removeMarker(dragSelectionMarker);
        dragSelectionMarker = null;
        editor2.selection.fromOrientedRange(range);
        if (editor2.isFocused() && !isInternal)
          editor2.$resetCursorStyle();
        range = null;
        dragCursor = null;
        counter = 0;
        autoScrollStartTime = null;
        cursorMovedTime = null;
        event.removeListener(document, "mousemove", onMouseMove);
      }
      var onMouseMoveTimer = null;
      function onMouseMove() {
        if (onMouseMoveTimer == null) {
          onMouseMoveTimer = setTimeout(function() {
            if (onMouseMoveTimer != null && dragSelectionMarker)
              clearDragMarker();
          }, 20);
        }
      }
      function canAccept(dataTransfer) {
        var types = dataTransfer.types;
        return !types || Array.prototype.some.call(types, function(type) {
          return type == "text/plain" || type == "Text";
        });
      }
      function getDropEffect(e) {
        var copyAllowed = ["copy", "copymove", "all", "uninitialized"];
        var moveAllowed = ["move", "copymove", "linkmove", "all", "uninitialized"];
        var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
        var effectAllowed = "uninitialized";
        try {
          effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
        } catch (e2) {
        }
        var dropEffect = "none";
        if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
          dropEffect = "copy";
        else if (moveAllowed.indexOf(effectAllowed) >= 0)
          dropEffect = "move";
        else if (copyAllowed.indexOf(effectAllowed) >= 0)
          dropEffect = "copy";
        return dropEffect;
      }
    }
    (function() {
      this.dragWait = function() {
        var interval = Date.now() - this.mousedownEvent.time;
        if (interval > this.editor.getDragDelay())
          this.startDrag();
      };
      this.dragWaitEnd = function() {
        var target = this.editor.container;
        target.draggable = false;
        this.startSelect(this.mousedownEvent.getDocumentPosition());
        this.selectEnd();
      };
      this.dragReadyEnd = function(e) {
        this.editor.$resetCursorStyle();
        this.editor.unsetStyle("ace_dragging");
        this.editor.renderer.setCursorStyle("");
        this.dragWaitEnd();
      };
      this.startDrag = function() {
        this.cancelDrag = false;
        var editor2 = this.editor;
        var target = editor2.container;
        target.draggable = true;
        editor2.renderer.$cursorLayer.setBlinking(false);
        editor2.setStyle("ace_dragging");
        var cursorStyle = useragent.isWin ? "default" : "move";
        editor2.renderer.setCursorStyle(cursorStyle);
        this.setState("dragReady");
      };
      this.onMouseDrag = function(e) {
        var target = this.editor.container;
        if (useragent.isIE && this.state == "dragReady") {
          var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
          if (distance > 3)
            target.dragDrop();
        }
        if (this.state === "dragWait") {
          var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
          if (distance > 0) {
            target.draggable = false;
            this.startSelect(this.mousedownEvent.getDocumentPosition());
          }
        }
      };
      this.onMouseDown = function(e) {
        if (!this.$dragEnabled)
          return;
        this.mousedownEvent = e;
        var editor2 = this.editor;
        var inSelection = e.inSelection();
        var button = e.getButton();
        var clickCount = e.domEvent.detail || 1;
        if (clickCount === 1 && button === 0 && inSelection) {
          if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
            return;
          this.mousedownEvent.time = Date.now();
          var eventTarget = e.domEvent.target || e.domEvent.srcElement;
          if ("unselectable" in eventTarget)
            eventTarget.unselectable = "on";
          if (editor2.getDragDelay()) {
            if (useragent.isWebKit) {
              this.cancelDrag = true;
              var mouseTarget = editor2.container;
              mouseTarget.draggable = true;
            }
            this.setState("dragWait");
          } else {
            this.startDrag();
          }
          this.captureMouse(e, this.onMouseDrag.bind(this));
          e.defaultPrevented = true;
        }
      };
    }).call(DragdropHandler.prototype);
    function calcDistance(ax, ay, bx, by) {
      return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
    }
    exports2.DragdropHandler = DragdropHandler;
  });
  ace.define("ace/mouse/touch_handler", ["require", "exports", "module", "ace/mouse/mouse_event", "ace/lib/event", "ace/lib/dom"], function(require2, exports2, module2) {
    var MouseEvent = require2("./mouse_event").MouseEvent;
    var event = require2("../lib/event");
    var dom = require2("../lib/dom");
    exports2.addTouchListeners = function(el, editor2) {
      var mode = "scroll";
      var startX;
      var startY;
      var touchStartT;
      var lastT;
      var longTouchTimer;
      var animationTimer;
      var animationSteps = 0;
      var pos;
      var clickCount = 0;
      var vX = 0;
      var vY = 0;
      var pressed;
      var contextMenu;
      function createContextMenu() {
        var clipboard = window.navigator && window.navigator.clipboard;
        var isOpen = false;
        var updateMenu = function() {
          var selected = editor2.getCopyText();
          var hasUndo = editor2.session.getUndoManager().hasUndo();
          contextMenu.replaceChild(dom.buildDom(isOpen ? [
            "span",
            !selected && canExecuteCommand("selectall") && ["span", { class: "ace_mobile-button", action: "selectall" }, "Select All"],
            selected && canExecuteCommand("copy") && ["span", { class: "ace_mobile-button", action: "copy" }, "Copy"],
            selected && canExecuteCommand("cut") && ["span", { class: "ace_mobile-button", action: "cut" }, "Cut"],
            clipboard && canExecuteCommand("paste") && ["span", { class: "ace_mobile-button", action: "paste" }, "Paste"],
            hasUndo && canExecuteCommand("undo") && ["span", { class: "ace_mobile-button", action: "undo" }, "Undo"],
            canExecuteCommand("find") && ["span", { class: "ace_mobile-button", action: "find" }, "Find"],
            canExecuteCommand("openCommandPalette") && ["span", { class: "ace_mobile-button", action: "openCommandPalette" }, "Palette"]
          ] : ["span"]), contextMenu.firstChild);
        };
        var canExecuteCommand = function(cmd) {
          return editor2.commands.canExecute(cmd, editor2);
        };
        var handleClick = function(e) {
          var action = e.target.getAttribute("action");
          if (action == "more" || !isOpen) {
            isOpen = !isOpen;
            return updateMenu();
          }
          if (action == "paste") {
            clipboard.readText().then(function(text) {
              editor2.execCommand(action, text);
            });
          } else if (action) {
            if (action == "cut" || action == "copy") {
              if (clipboard)
                clipboard.writeText(editor2.getCopyText());
              else
                document.execCommand("copy");
            }
            editor2.execCommand(action);
          }
          contextMenu.firstChild.style.display = "none";
          isOpen = false;
          if (action != "openCommandPalette")
            editor2.focus();
        };
        contextMenu = dom.buildDom([
          "div",
          {
            class: "ace_mobile-menu",
            ontouchstart: function(e) {
              mode = "menu";
              e.stopPropagation();
              e.preventDefault();
              editor2.textInput.focus();
            },
            ontouchend: function(e) {
              e.stopPropagation();
              e.preventDefault();
              handleClick(e);
            },
            onclick: handleClick
          },
          ["span"],
          ["span", { class: "ace_mobile-button", action: "more" }, "..."]
        ], editor2.container);
      }
      function showContextMenu() {
        if (!editor2.getOption("enableMobileMenu")) {
          if (contextMenu) {
            hideContextMenu();
          }
          return;
        }
        if (!contextMenu)
          createContextMenu();
        var cursor = editor2.selection.cursor;
        var pagePos = editor2.renderer.textToScreenCoordinates(cursor.row, cursor.column);
        var leftOffset = editor2.renderer.textToScreenCoordinates(0, 0).pageX;
        var scrollLeft = editor2.renderer.scrollLeft;
        var rect = editor2.container.getBoundingClientRect();
        contextMenu.style.top = pagePos.pageY - rect.top - 3 + "px";
        if (pagePos.pageX - rect.left < rect.width - 70) {
          contextMenu.style.left = "";
          contextMenu.style.right = "10px";
        } else {
          contextMenu.style.right = "";
          contextMenu.style.left = leftOffset + scrollLeft - rect.left + "px";
        }
        contextMenu.style.display = "";
        contextMenu.firstChild.style.display = "none";
        editor2.on("input", hideContextMenu);
      }
      function hideContextMenu(e) {
        if (contextMenu)
          contextMenu.style.display = "none";
        editor2.off("input", hideContextMenu);
      }
      function handleLongTap() {
        longTouchTimer = null;
        clearTimeout(longTouchTimer);
        var range = editor2.selection.getRange();
        var inSelection = range.contains(pos.row, pos.column);
        if (range.isEmpty() || !inSelection) {
          editor2.selection.moveToPosition(pos);
          editor2.selection.selectWord();
        }
        mode = "wait";
        showContextMenu();
      }
      function switchToSelectionMode() {
        longTouchTimer = null;
        clearTimeout(longTouchTimer);
        editor2.selection.moveToPosition(pos);
        var range = clickCount >= 2 ? editor2.selection.getLineRange(pos.row) : editor2.session.getBracketRange(pos);
        if (range && !range.isEmpty()) {
          editor2.selection.setRange(range);
        } else {
          editor2.selection.selectWord();
        }
        mode = "wait";
      }
      event.addListener(el, "contextmenu", function(e) {
        if (!pressed)
          return;
        var textarea = editor2.textInput.getElement();
        textarea.focus();
      }, editor2);
      event.addListener(el, "touchstart", function(e) {
        var touches = e.touches;
        if (longTouchTimer || touches.length > 1) {
          clearTimeout(longTouchTimer);
          longTouchTimer = null;
          touchStartT = -1;
          mode = "zoom";
          return;
        }
        pressed = editor2.$mouseHandler.isMousePressed = true;
        var h = editor2.renderer.layerConfig.lineHeight;
        var w = editor2.renderer.layerConfig.lineHeight;
        var t = e.timeStamp;
        lastT = t;
        var touchObj = touches[0];
        var x = touchObj.clientX;
        var y = touchObj.clientY;
        if (Math.abs(startX - x) + Math.abs(startY - y) > h)
          touchStartT = -1;
        startX = e.clientX = x;
        startY = e.clientY = y;
        vX = vY = 0;
        var ev = new MouseEvent(e, editor2);
        pos = ev.getDocumentPosition();
        if (t - touchStartT < 500 && touches.length == 1 && !animationSteps) {
          clickCount++;
          e.preventDefault();
          e.button = 0;
          switchToSelectionMode();
        } else {
          clickCount = 0;
          var cursor = editor2.selection.cursor;
          var anchor = editor2.selection.isEmpty() ? cursor : editor2.selection.anchor;
          var cursorPos = editor2.renderer.$cursorLayer.getPixelPosition(cursor, true);
          var anchorPos = editor2.renderer.$cursorLayer.getPixelPosition(anchor, true);
          var rect = editor2.renderer.scroller.getBoundingClientRect();
          var offsetTop = editor2.renderer.layerConfig.offset;
          var offsetLeft = editor2.renderer.scrollLeft;
          var weightedDistance = function(x2, y2) {
            x2 = x2 / w;
            y2 = y2 / h - 0.75;
            return x2 * x2 + y2 * y2;
          };
          if (e.clientX < rect.left) {
            mode = "zoom";
            return;
          }
          var diff1 = weightedDistance(e.clientX - rect.left - cursorPos.left + offsetLeft, e.clientY - rect.top - cursorPos.top + offsetTop);
          var diff2 = weightedDistance(e.clientX - rect.left - anchorPos.left + offsetLeft, e.clientY - rect.top - anchorPos.top + offsetTop);
          if (diff1 < 3.5 && diff2 < 3.5)
            mode = diff1 > diff2 ? "cursor" : "anchor";
          if (diff2 < 3.5)
            mode = "anchor";
          else if (diff1 < 3.5)
            mode = "cursor";
          else
            mode = "scroll";
          longTouchTimer = setTimeout(handleLongTap, 450);
        }
        touchStartT = t;
      }, editor2);
      event.addListener(el, "touchend", function(e) {
        pressed = editor2.$mouseHandler.isMousePressed = false;
        if (animationTimer)
          clearInterval(animationTimer);
        if (mode == "zoom") {
          mode = "";
          animationSteps = 0;
        } else if (longTouchTimer) {
          editor2.selection.moveToPosition(pos);
          animationSteps = 0;
          showContextMenu();
        } else if (mode == "scroll") {
          animate();
          hideContextMenu();
        } else {
          showContextMenu();
        }
        clearTimeout(longTouchTimer);
        longTouchTimer = null;
      }, editor2);
      event.addListener(el, "touchmove", function(e) {
        if (longTouchTimer) {
          clearTimeout(longTouchTimer);
          longTouchTimer = null;
        }
        var touches = e.touches;
        if (touches.length > 1 || mode == "zoom")
          return;
        var touchObj = touches[0];
        var wheelX = startX - touchObj.clientX;
        var wheelY = startY - touchObj.clientY;
        if (mode == "wait") {
          if (wheelX * wheelX + wheelY * wheelY > 4)
            mode = "cursor";
          else
            return e.preventDefault();
        }
        startX = touchObj.clientX;
        startY = touchObj.clientY;
        e.clientX = touchObj.clientX;
        e.clientY = touchObj.clientY;
        var t = e.timeStamp;
        var dt = t - lastT;
        lastT = t;
        if (mode == "scroll") {
          var mouseEvent = new MouseEvent(e, editor2);
          mouseEvent.speed = 1;
          mouseEvent.wheelX = wheelX;
          mouseEvent.wheelY = wheelY;
          if (10 * Math.abs(wheelX) < Math.abs(wheelY))
            wheelX = 0;
          if (10 * Math.abs(wheelY) < Math.abs(wheelX))
            wheelY = 0;
          if (dt != 0) {
            vX = wheelX / dt;
            vY = wheelY / dt;
          }
          editor2._emit("mousewheel", mouseEvent);
          if (!mouseEvent.propagationStopped) {
            vX = vY = 0;
          }
        } else {
          var ev = new MouseEvent(e, editor2);
          var pos2 = ev.getDocumentPosition();
          if (mode == "cursor")
            editor2.selection.moveCursorToPosition(pos2);
          else if (mode == "anchor")
            editor2.selection.setSelectionAnchor(pos2.row, pos2.column);
          editor2.renderer.scrollCursorIntoView(pos2);
          e.preventDefault();
        }
      }, editor2);
      function animate() {
        animationSteps += 60;
        animationTimer = setInterval(function() {
          if (animationSteps-- <= 0) {
            clearInterval(animationTimer);
            animationTimer = null;
          }
          if (Math.abs(vX) < 0.01)
            vX = 0;
          if (Math.abs(vY) < 0.01)
            vY = 0;
          if (animationSteps < 20)
            vX = 0.9 * vX;
          if (animationSteps < 20)
            vY = 0.9 * vY;
          var oldScrollTop = editor2.session.getScrollTop();
          editor2.renderer.scrollBy(10 * vX, 10 * vY);
          if (oldScrollTop == editor2.session.getScrollTop())
            animationSteps = 0;
        }, 10);
      }
    };
  });
  ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/mouse/touch_handler", "ace/config"], function(require2, exports2, module2) {
    var event = require2("../lib/event");
    var useragent = require2("../lib/useragent");
    var DefaultHandlers = require2("./default_handlers").DefaultHandlers;
    var DefaultGutterHandler = require2("./default_gutter_handler").GutterHandler;
    var MouseEvent = require2("./mouse_event").MouseEvent;
    var DragdropHandler = require2("./dragdrop_handler").DragdropHandler;
    var addTouchListeners = require2("./touch_handler").addTouchListeners;
    var config = require2("../config");
    var MouseHandler = (
      /** @class */
      function() {
        function MouseHandler2(editor2) {
          this.$dragDelay;
          this.$dragEnabled;
          this.$mouseMoved;
          this.mouseEvent;
          this.$focusTimeout;
          var _self = this;
          this.editor = editor2;
          new DefaultHandlers(this);
          new DefaultGutterHandler(this);
          new DragdropHandler(this);
          var focusEditor = function(e) {
            var windowBlurred = !document.hasFocus || !document.hasFocus() || !editor2.isFocused() && document.activeElement == (editor2.textInput && editor2.textInput.getElement());
            if (windowBlurred)
              window.focus();
            editor2.focus();
            setTimeout(function() {
              if (!editor2.isFocused())
                editor2.focus();
            });
          };
          var mouseTarget = editor2.renderer.getMouseEventTarget();
          event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"), editor2);
          event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"), editor2);
          event.addMultiMouseDownListener([
            mouseTarget,
            editor2.renderer.scrollBarV && editor2.renderer.scrollBarV.inner,
            editor2.renderer.scrollBarH && editor2.renderer.scrollBarH.inner,
            editor2.textInput && editor2.textInput.getElement()
          ].filter(Boolean), [400, 300, 250], this, "onMouseEvent", editor2);
          event.addMouseWheelListener(editor2.container, this.onMouseWheel.bind(this, "mousewheel"), editor2);
          addTouchListeners(editor2.container, editor2);
          var gutterEl = editor2.renderer.$gutter;
          event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), editor2);
          event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"), editor2);
          event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), editor2);
          event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), editor2);
          event.addListener(mouseTarget, "mousedown", focusEditor, editor2);
          event.addListener(gutterEl, "mousedown", focusEditor, editor2);
          if (useragent.isIE && editor2.renderer.scrollBarV) {
            event.addListener(editor2.renderer.scrollBarV.element, "mousedown", focusEditor, editor2);
            event.addListener(editor2.renderer.scrollBarH.element, "mousedown", focusEditor, editor2);
          }
          editor2.on(
            "mousemove",
            function(e) {
              if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
                return;
              var character = editor2.renderer.screenToTextCoordinates(e.x, e.y);
              var range = editor2.session.selection.getRange();
              var renderer = editor2.renderer;
              if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
                renderer.setCursorStyle("default");
              } else {
                renderer.setCursorStyle("");
              }
            },
            //@ts-expect-error TODO: seems mistyping - should be boolean
            editor2
          );
        }
        MouseHandler2.prototype.onMouseEvent = function(name, e) {
          if (!this.editor.session)
            return;
          this.editor._emit(name, new MouseEvent(e, this.editor));
        };
        MouseHandler2.prototype.onMouseMove = function(name, e) {
          var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
          if (!listeners || !listeners.length)
            return;
          this.editor._emit(name, new MouseEvent(e, this.editor));
        };
        MouseHandler2.prototype.onMouseWheel = function(name, e) {
          var mouseEvent = new MouseEvent(e, this.editor);
          mouseEvent.speed = this.$scrollSpeed * 2;
          mouseEvent.wheelX = e.wheelX;
          mouseEvent.wheelY = e.wheelY;
          this.editor._emit(name, mouseEvent);
        };
        MouseHandler2.prototype.setState = function(state) {
          this.state = state;
        };
        MouseHandler2.prototype.captureMouse = function(ev, mouseMoveHandler) {
          this.x = ev.x;
          this.y = ev.y;
          this.isMousePressed = true;
          var editor2 = this.editor;
          var renderer = this.editor.renderer;
          renderer.$isMousePressed = true;
          var self2 = this;
          var continueCapture = true;
          var onMouseMove = function(e) {
            if (!e)
              return;
            if (useragent.isWebKit && !e.which && self2.releaseMouse)
              return self2.releaseMouse();
            self2.x = e.clientX;
            self2.y = e.clientY;
            mouseMoveHandler && mouseMoveHandler(e);
            self2.mouseEvent = new MouseEvent(e, self2.editor);
            self2.$mouseMoved = true;
          };
          var onCaptureEnd = function(e) {
            editor2.off("beforeEndOperation", onOperationEnd);
            continueCapture = false;
            if (editor2.session)
              onCaptureUpdate();
            self2[self2.state + "End"] && self2[self2.state + "End"](e);
            self2.state = "";
            self2.isMousePressed = renderer.$isMousePressed = false;
            if (renderer.$keepTextAreaAtCursor)
              renderer.$moveTextAreaToCursor();
            self2.$onCaptureMouseMove = self2.releaseMouse = null;
            e && self2.onMouseEvent("mouseup", e);
            editor2.endOperation();
          };
          var onCaptureUpdate = function() {
            self2[self2.state] && self2[self2.state]();
            self2.$mouseMoved = false;
          };
          var onCaptureInterval = function() {
            if (continueCapture) {
              onCaptureUpdate();
              event.nextFrame(onCaptureInterval);
            }
          };
          if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
            return setTimeout(function() {
              onCaptureEnd(ev);
            });
          }
          var onOperationEnd = function(e) {
            if (!self2.releaseMouse)
              return;
            if (editor2.curOp.command.name && editor2.curOp.selectionChanged) {
              self2[self2.state + "End"] && self2[self2.state + "End"]();
              self2.state = "";
              self2.releaseMouse();
            }
          };
          editor2.on("beforeEndOperation", onOperationEnd);
          editor2.startOperation({ command: { name: "mouse" } });
          self2.$onCaptureMouseMove = onMouseMove;
          self2.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
          onCaptureInterval();
        };
        MouseHandler2.prototype.cancelContextMenu = function() {
          var stop = (function(e) {
            if (e && e.domEvent && e.domEvent.type != "contextmenu")
              return;
            this.editor.off("nativecontextmenu", stop);
            if (e && e.domEvent)
              event.stopEvent(e.domEvent);
          }).bind(this);
          setTimeout(stop, 10);
          this.editor.on("nativecontextmenu", stop);
        };
        MouseHandler2.prototype.destroy = function() {
          if (this.releaseMouse)
            this.releaseMouse();
        };
        return MouseHandler2;
      }()
    );
    MouseHandler.prototype.releaseMouse = null;
    config.defineOptions(MouseHandler.prototype, "mouseHandler", {
      scrollSpeed: { initialValue: 2 },
      dragDelay: { initialValue: useragent.isMac ? 150 : 0 },
      dragEnabled: { initialValue: true },
      focusTimeout: { initialValue: 0 },
      tooltipFollowsMouse: { initialValue: true }
    });
    exports2.MouseHandler = MouseHandler;
  });
  ace.define("ace/mouse/fold_handler", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
    var dom = require2("../lib/dom");
    var FoldHandler = (
      /** @class */
      /* @__PURE__ */ function() {
        function FoldHandler2(editor2) {
          editor2.on("click", function(e) {
            var position = e.getDocumentPosition();
            var session = editor2.session;
            var fold = session.getFoldAt(position.row, position.column, 1);
            if (fold) {
              if (e.getAccelKey())
                session.removeFold(fold);
              else
                session.expandFold(fold);
              e.stop();
            }
            var target = e.domEvent && e.domEvent.target;
            if (target && dom.hasCssClass(target, "ace_inline_button")) {
              if (dom.hasCssClass(target, "ace_toggle_wrap")) {
                session.setOption("wrap", !session.getUseWrapMode());
                editor2.renderer.scrollCursorIntoView();
              }
            }
          });
          editor2.on("gutterclick", function(e) {
            var gutterRegion = editor2.renderer.$gutterLayer.getRegion(e);
            if (gutterRegion == "foldWidgets") {
              var row = e.getDocumentPosition().row;
              var session = editor2.session;
              if (session.foldWidgets && session.foldWidgets[row])
                editor2.session.onFoldWidgetClick(row, e);
              if (!editor2.isFocused())
                editor2.focus();
              e.stop();
            }
          });
          editor2.on("gutterdblclick", function(e) {
            var gutterRegion = editor2.renderer.$gutterLayer.getRegion(e);
            if (gutterRegion == "foldWidgets") {
              var row = e.getDocumentPosition().row;
              var session = editor2.session;
              var data = session.getParentFoldRangeData(row, true);
              var range = data.range || data.firstRange;
              if (range) {
                row = range.start.row;
                var fold = session.getFoldAt(row, session.getLine(row).length, 1);
                if (fold) {
                  session.removeFold(fold);
                } else {
                  session.addFold("...", range);
                  editor2.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });
                }
              }
              e.stop();
            }
          });
        }
        return FoldHandler2;
      }()
    );
    exports2.FoldHandler = FoldHandler;
  });
  ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function(require2, exports2, module2) {
    var keyUtil = require2("../lib/keys");
    var event = require2("../lib/event");
    var KeyBinding = (
      /** @class */
      function() {
        function KeyBinding2(editor2) {
          this.$editor = editor2;
          this.$data = { editor: editor2 };
          this.$handlers = [];
          this.setDefaultHandler(editor2.commands);
        }
        KeyBinding2.prototype.setDefaultHandler = function(kb) {
          this.removeKeyboardHandler(this.$defaultHandler);
          this.$defaultHandler = kb;
          this.addKeyboardHandler(kb, 0);
        };
        KeyBinding2.prototype.setKeyboardHandler = function(kb) {
          var h = this.$handlers;
          if (h[h.length - 1] == kb)
            return;
          while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
            this.removeKeyboardHandler(h[h.length - 1]);
          this.addKeyboardHandler(kb, 1);
        };
        KeyBinding2.prototype.addKeyboardHandler = function(kb, pos) {
          if (!kb)
            return;
          if (typeof kb == "function" && !kb.handleKeyboard)
            kb.handleKeyboard = kb;
          var i = this.$handlers.indexOf(kb);
          if (i != -1)
            this.$handlers.splice(i, 1);
          if (pos == void 0)
            this.$handlers.push(kb);
          else
            this.$handlers.splice(pos, 0, kb);
          if (i == -1 && kb.attach)
            kb.attach(this.$editor);
        };
        KeyBinding2.prototype.removeKeyboardHandler = function(kb) {
          var i = this.$handlers.indexOf(kb);
          if (i == -1)
            return false;
          this.$handlers.splice(i, 1);
          kb.detach && kb.detach(this.$editor);
          return true;
        };
        KeyBinding2.prototype.getKeyboardHandler = function() {
          return this.$handlers[this.$handlers.length - 1];
        };
        KeyBinding2.prototype.getStatusText = function() {
          var data = this.$data;
          var editor2 = data.editor;
          return this.$handlers.map(function(h) {
            return h.getStatusText && h.getStatusText(editor2, data) || "";
          }).filter(Boolean).join(" ");
        };
        KeyBinding2.prototype.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
          var toExecute;
          var success = false;
          var commands = this.$editor.commands;
          for (var i = this.$handlers.length; i--; ) {
            toExecute = this.$handlers[i].handleKeyboard(
              this.$data,
              hashId,
              keyString,
              keyCode,
              e
            );
            if (!toExecute || !toExecute.command)
              continue;
            if (toExecute.command == "null") {
              success = true;
            } else {
              success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
            }
            if (success && e && hashId != -1 && toExecute["passEvent"] != true && toExecute.command["passEvent"] != true) {
              event.stopEvent(e);
            }
            if (success)
              break;
          }
          if (!success && hashId == -1) {
            toExecute = { command: "insertstring" };
            success = commands.exec("insertstring", this.$editor, keyString);
          }
          if (success && this.$editor._signal)
            this.$editor._signal("keyboardActivity", toExecute);
          return success;
        };
        KeyBinding2.prototype.onCommandKey = function(e, hashId, keyCode) {
          var keyString = keyUtil.keyCodeToString(keyCode);
          return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
        };
        KeyBinding2.prototype.onTextInput = function(text) {
          return this.$callKeyboardHandlers(-1, text);
        };
        return KeyBinding2;
      }()
    );
    exports2.KeyBinding = KeyBinding;
  });
  ace.define("ace/lib/bidiutil", ["require", "exports", "module"], function(require2, exports2, module2) {
    var dir = 0, hiLevel = 0;
    var lastArabic = false, hasUBAT_B = false, hasUBAT_S = false;
    var impTab_LTR = [
      [0, 3, 0, 1, 0, 0, 0],
      [0, 3, 0, 1, 2, 2, 0],
      [0, 3, 0, 17, 2, 0, 1],
      [0, 3, 5, 5, 4, 1, 0],
      [0, 3, 21, 21, 4, 0, 1],
      [0, 3, 5, 5, 4, 2, 0]
    ];
    var impTab_RTL = [
      [2, 0, 1, 1, 0, 1, 0],
      [2, 0, 1, 1, 0, 2, 0],
      [2, 0, 2, 1, 3, 2, 0],
      [2, 0, 2, 33, 3, 1, 1]
    ];
    var LTR = 0, RTL = 1;
    var L = 0;
    var R = 1;
    var EN = 2;
    var AN = 3;
    var ON = 4;
    var B = 5;
    var S = 6;
    var AL = 7;
    var WS = 8;
    var CS = 9;
    var ES = 10;
    var ET = 11;
    var NSM = 12;
    var LRE = 13;
    var RLE = 14;
    var PDF = 15;
    var LRO = 16;
    var RLO = 17;
    var BN = 18;
    var UnicodeTBL00 = [
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      S,
      B,
      S,
      WS,
      B,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      B,
      B,
      B,
      S,
      WS,
      ON,
      ON,
      ET,
      ET,
      ET,
      ON,
      ON,
      ON,
      ON,
      ON,
      ES,
      CS,
      ES,
      CS,
      CS,
      EN,
      EN,
      EN,
      EN,
      EN,
      EN,
      EN,
      EN,
      EN,
      EN,
      CS,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      L,
      ON,
      ON,
      ON,
      ON,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      B,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      BN,
      CS,
      ON,
      ET,
      ET,
      ET,
      ET,
      ON,
      ON,
      ON,
      ON,
      L,
      ON,
      ON,
      BN,
      ON,
      ON,
      ET,
      ET,
      EN,
      EN,
      ON,
      L,
      ON,
      ON,
      ON,
      EN,
      L,
      ON,
      ON,
      ON,
      ON,
      ON
    ];
    var UnicodeTBL20 = [
      WS,
      WS,
      WS,
      WS,
      WS,
      WS,
      WS,
      WS,
      WS,
      WS,
      WS,
      BN,
      BN,
      BN,
      L,
      R,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      WS,
      B,
      LRE,
      RLE,
      PDF,
      LRO,
      RLO,
      CS,
      ET,
      ET,
      ET,
      ET,
      ET,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      CS,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      ON,
      WS
    ];
    function _computeLevels(chars, levels, len, charTypes) {
      var impTab = dir ? impTab_RTL : impTab_LTR, prevState = null, newClass = null, newLevel = null, newState = 0, action = null, cond = null, condPos = -1, i = null, ix = null, classes2 = [];
      if (!charTypes) {
        for (i = 0, charTypes = []; i < len; i++) {
          charTypes[i] = _getCharacterType(chars[i]);
        }
      }
      hiLevel = dir;
      lastArabic = false;
      hasUBAT_B = false;
      hasUBAT_S = false;
      for (ix = 0; ix < len; ix++) {
        prevState = newState;
        classes2[ix] = newClass = _getCharClass(chars, charTypes, classes2, ix);
        newState = impTab[prevState][newClass];
        action = newState & 240;
        newState &= 15;
        levels[ix] = newLevel = impTab[newState][5];
        if (action > 0) {
          if (action == 16) {
            for (i = condPos; i < ix; i++) {
              levels[i] = 1;
            }
            condPos = -1;
          } else {
            condPos = -1;
          }
        }
        cond = impTab[newState][6];
        if (cond) {
          if (condPos == -1) {
            condPos = ix;
          }
        } else {
          if (condPos > -1) {
            for (i = condPos; i < ix; i++) {
              levels[i] = newLevel;
            }
            condPos = -1;
          }
        }
        if (charTypes[ix] == B) {
          levels[ix] = 0;
        }
        hiLevel |= newLevel;
      }
      if (hasUBAT_S) {
        for (i = 0; i < len; i++) {
          if (charTypes[i] == S) {
            levels[i] = dir;
            for (var j = i - 1; j >= 0; j--) {
              if (charTypes[j] == WS) {
                levels[j] = dir;
              } else {
                break;
              }
            }
          }
        }
      }
    }
    function _invertLevel(lev, levels, _array) {
      if (hiLevel < lev) {
        return;
      }
      if (lev == 1 && dir == RTL && !hasUBAT_B) {
        _array.reverse();
        return;
      }
      var len = _array.length, start = 0, end, lo, hi, tmp;
      while (start < len) {
        if (levels[start] >= lev) {
          end = start + 1;
          while (end < len && levels[end] >= lev) {
            end++;
          }
          for (lo = start, hi = end - 1; lo < hi; lo++, hi--) {
            tmp = _array[lo];
            _array[lo] = _array[hi];
            _array[hi] = tmp;
          }
          start = end;
        }
        start++;
      }
    }
    function _getCharClass(chars, types, classes2, ix) {
      var cType = types[ix], wType, nType, len, i;
      switch (cType) {
        case L:
        case R:
          lastArabic = false;
        case ON:
        case AN:
          return cType;
        case EN:
          return lastArabic ? AN : EN;
        case AL:
          lastArabic = true;
          return R;
        case WS:
          return ON;
        case CS:
          if (ix < 1 || ix + 1 >= types.length || (wType = classes2[ix - 1]) != EN && wType != AN || (nType = types[ix + 1]) != EN && nType != AN) {
            return ON;
          }
          if (lastArabic) {
            nType = AN;
          }
          return nType == wType ? nType : ON;
        case ES:
          wType = ix > 0 ? classes2[ix - 1] : B;
          if (wType == EN && ix + 1 < types.length && types[ix + 1] == EN) {
            return EN;
          }
          return ON;
        case ET:
          if (ix > 0 && classes2[ix - 1] == EN) {
            return EN;
          }
          if (lastArabic) {
            return ON;
          }
          i = ix + 1;
          len = types.length;
          while (i < len && types[i] == ET) {
            i++;
          }
          if (i < len && types[i] == EN) {
            return EN;
          }
          return ON;
        case NSM:
          len = types.length;
          i = ix + 1;
          while (i < len && types[i] == NSM) {
            i++;
          }
          if (i < len) {
            var c = chars[ix], rtlCandidate = c >= 1425 && c <= 2303 || c == 64286;
            wType = types[i];
            if (rtlCandidate && (wType == R || wType == AL)) {
              return R;
            }
          }
          if (ix < 1 || (wType = types[ix - 1]) == B) {
            return ON;
          }
          return classes2[ix - 1];
        case B:
          lastArabic = false;
          hasUBAT_B = true;
          return dir;
        case S:
          hasUBAT_S = true;
          return ON;
        case LRE:
        case RLE:
        case LRO:
        case RLO:
        case PDF:
          lastArabic = false;
        case BN:
          return ON;
      }
    }
    function _getCharacterType(ch) {
      var uc = ch.charCodeAt(0), hi = uc >> 8;
      if (hi == 0) {
        return uc > 191 ? L : UnicodeTBL00[uc];
      } else if (hi == 5) {
        return /[\u0591-\u05f4]/.test(ch) ? R : L;
      } else if (hi == 6) {
        if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
          return NSM;
        else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
          return AN;
        else if (uc == 1642)
          return ET;
        else if (/[\u06f0-\u06f9]/.test(ch))
          return EN;
        else
          return AL;
      } else if (hi == 32 && uc <= 8287) {
        return UnicodeTBL20[uc & 255];
      } else if (hi == 254) {
        return uc >= 65136 ? AL : ON;
      }
      return ON;
    }
    exports2.L = L;
    exports2.R = R;
    exports2.EN = EN;
    exports2.ON_R = 3;
    exports2.AN = 4;
    exports2.R_H = 5;
    exports2.B = 6;
    exports2.RLE = 7;
    exports2.DOT = "·";
    exports2.doBidiReorder = function(text, textCharTypes, isRtl) {
      if (text.length < 2)
        return {};
      var chars = text.split(""), logicalFromVisual = new Array(chars.length), bidiLevels = new Array(chars.length), levels = [];
      dir = isRtl ? RTL : LTR;
      _computeLevels(chars, levels, chars.length, textCharTypes);
      for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++)
        ;
      _invertLevel(2, levels, logicalFromVisual);
      _invertLevel(1, levels, logicalFromVisual);
      for (var i = 0; i < logicalFromVisual.length - 1; i++) {
        if (textCharTypes[i] === AN) {
          levels[i] = exports2.AN;
        } else if (levels[i] === R && (textCharTypes[i] > AL && textCharTypes[i] < LRE || textCharTypes[i] === ON || textCharTypes[i] === BN)) {
          levels[i] = exports2.ON_R;
        } else if (i > 0 && chars[i - 1] === "ل" && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
          levels[i - 1] = levels[i] = exports2.R_H;
          i++;
        }
      }
      if (chars[chars.length - 1] === exports2.DOT)
        levels[chars.length - 1] = exports2.B;
      if (chars[0] === "‫")
        levels[0] = exports2.RLE;
      for (var i = 0; i < logicalFromVisual.length; i++) {
        bidiLevels[i] = levels[logicalFromVisual[i]];
      }
      return { "logicalFromVisual": logicalFromVisual, "bidiLevels": bidiLevels };
    };
    exports2.hasBidiCharacters = function(text, textCharTypes) {
      var ret = false;
      for (var i = 0; i < text.length; i++) {
        textCharTypes[i] = _getCharacterType(text.charAt(i));
        if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN))
          ret = true;
      }
      return ret;
    };
    exports2.getVisualFromLogicalIdx = function(logIdx, rowMap) {
      for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
        if (rowMap.logicalFromVisual[i] == logIdx)
          return i;
      }
      return 0;
    };
  });
  ace.define("ace/bidihandler", ["require", "exports", "module", "ace/lib/bidiutil", "ace/lib/lang"], function(require2, exports2, module2) {
    var bidiUtil = require2("./lib/bidiutil");
    var lang = require2("./lib/lang");
    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;
    var BidiHandler = (
      /** @class */
      function() {
        function BidiHandler2(session) {
          this.session = session;
          this.bidiMap = {};
          this.currentRow = null;
          this.bidiUtil = bidiUtil;
          this.charWidths = [];
          this.EOL = "¬";
          this.showInvisibles = true;
          this.isRtlDir = false;
          this.$isRtl = false;
          this.line = "";
          this.wrapIndent = 0;
          this.EOF = "¶";
          this.RLE = "‫";
          this.contentWidth = 0;
          this.fontMetrics = null;
          this.rtlLineOffset = 0;
          this.wrapOffset = 0;
          this.isMoveLeftOperation = false;
          this.seenBidi = bidiRE.test(session.getValue());
        }
        BidiHandler2.prototype.isBidiRow = function(screenRow, docRow, splitIndex) {
          if (!this.seenBidi)
            return false;
          if (screenRow !== this.currentRow) {
            this.currentRow = screenRow;
            this.updateRowLine(docRow, splitIndex);
            this.updateBidiMap();
          }
          return this.bidiMap.bidiLevels;
        };
        BidiHandler2.prototype.onChange = function(delta) {
          if (!this.seenBidi) {
            if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
              this.seenBidi = true;
              this.currentRow = null;
            }
          } else {
            this.currentRow = null;
          }
        };
        BidiHandler2.prototype.getDocumentRow = function() {
          var docRow = 0;
          var rowCache = this.session.$screenRowCache;
          if (rowCache.length) {
            var index2 = this.session.$getRowCacheIndex(rowCache, this.currentRow);
            if (index2 >= 0)
              docRow = this.session.$docRowCache[index2];
          }
          return docRow;
        };
        BidiHandler2.prototype.getSplitIndex = function() {
          var splitIndex = 0;
          var rowCache = this.session.$screenRowCache;
          if (rowCache.length) {
            var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
            while (this.currentRow - splitIndex > 0) {
              currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
              if (currentIndex !== prevIndex)
                break;
              prevIndex = currentIndex;
              splitIndex++;
            }
          } else {
            splitIndex = this.currentRow;
          }
          return splitIndex;
        };
        BidiHandler2.prototype.updateRowLine = function(docRow, splitIndex) {
          if (docRow === void 0)
            docRow = this.getDocumentRow();
          var isLastRow = docRow === this.session.getLength() - 1, endOfLine = isLastRow ? this.EOF : this.EOL;
          this.wrapIndent = 0;
          this.line = this.session.getLine(docRow);
          this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
          if (this.session.$useWrapMode) {
            var splits = this.session.$wrapData[docRow];
            if (splits) {
              if (splitIndex === void 0)
                splitIndex = this.getSplitIndex();
              if (splitIndex > 0 && splits.length) {
                this.wrapIndent = splits.indent;
                this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
                this.line = splitIndex < splits.length ? this.line.substring(splits[splitIndex - 1], splits[splitIndex]) : this.line.substring(splits[splits.length - 1]);
              } else {
                this.line = this.line.substring(0, splits[splitIndex]);
              }
              if (splitIndex == splits.length) {
                this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
              }
            }
          } else {
            this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
          }
          var session = this.session, shift = 0, size;
          this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch, i) {
            if (ch === "	" || session.isFullWidth(ch.charCodeAt(0))) {
              size = ch === "	" ? session.getScreenTabSize(i + shift) : 2;
              shift += size - 1;
              return lang.stringRepeat(bidiUtil.DOT, size);
            }
            return ch;
          });
          if (this.isRtlDir) {
            this.fontMetrics.$main.textContent = this.line.charAt(this.line.length - 1) == bidiUtil.DOT ? this.line.substr(0, this.line.length - 1) : this.line;
            this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
          }
        };
        BidiHandler2.prototype.updateBidiMap = function() {
          var textCharTypes = [];
          if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {
            this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
          } else {
            this.bidiMap = {};
          }
        };
        BidiHandler2.prototype.markAsDirty = function() {
          this.currentRow = null;
        };
        BidiHandler2.prototype.updateCharacterWidths = function(fontMetrics) {
          if (this.characterWidth === fontMetrics.$characterSize.width)
            return;
          this.fontMetrics = fontMetrics;
          var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
          var bidiCharWidth = fontMetrics.$measureCharWidth("ה");
          this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
          this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
          this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
          this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;
          this.currentRow = null;
        };
        BidiHandler2.prototype.setShowInvisibles = function(showInvisibles) {
          this.showInvisibles = showInvisibles;
          this.currentRow = null;
        };
        BidiHandler2.prototype.setEolChar = function(eolChar) {
          this.EOL = eolChar;
        };
        BidiHandler2.prototype.setContentWidth = function(width) {
          this.contentWidth = width;
        };
        BidiHandler2.prototype.isRtlLine = function(row) {
          if (this.$isRtl)
            return true;
          if (row != void 0)
            return this.session.getLine(row).charAt(0) == this.RLE;
          else
            return this.isRtlDir;
        };
        BidiHandler2.prototype.setRtlDirection = function(editor2, isRtlDir) {
          var cursor = editor2.getCursorPosition();
          for (var row = editor2.selection.getSelectionAnchor().row; row <= cursor.row; row++) {
            if (!isRtlDir && editor2.session.getLine(row).charAt(0) === editor2.session.$bidiHandler.RLE)
              editor2.session.doc.removeInLine(row, 0, 1);
            else if (isRtlDir && editor2.session.getLine(row).charAt(0) !== editor2.session.$bidiHandler.RLE)
              editor2.session.doc.insert({ column: 0, row }, editor2.session.$bidiHandler.RLE);
          }
        };
        BidiHandler2.prototype.getPosLeft = function(col) {
          col -= this.wrapIndent;
          var leftBoundary = this.line.charAt(0) === this.RLE ? 1 : 0;
          var logicalIdx = col > leftBoundary ? this.session.getOverwrite() ? col : col - 1 : leftBoundary;
          var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap), levels = this.bidiMap.bidiLevels, left = 0;
          if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)
            visualIdx++;
          for (var i = 0; i < visualIdx; i++) {
            left += this.charWidths[levels[i]];
          }
          if (!this.session.getOverwrite() && col > leftBoundary && levels[visualIdx] % 2 === 0)
            left += this.charWidths[levels[visualIdx]];
          if (this.wrapIndent)
            left += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
          if (this.isRtlDir)
            left += this.rtlLineOffset;
          return left;
        };
        BidiHandler2.prototype.getSelections = function(startCol, endCol) {
          var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0, selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent, isSelected = false, isSelectedPrev = false, selectionStart = 0;
          if (this.wrapIndent)
            offset += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
          for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
            logIdx = map.logicalFromVisual[visIdx];
            level = levels[visIdx];
            isSelected = logIdx >= selColMin && logIdx < selColMax;
            if (isSelected && !isSelectedPrev) {
              selectionStart = offset;
            } else if (!isSelected && isSelectedPrev) {
              selections.push({ left: selectionStart, width: offset - selectionStart });
            }
            offset += this.charWidths[level];
            isSelectedPrev = isSelected;
          }
          if (isSelected && visIdx === levels.length) {
            selections.push({ left: selectionStart, width: offset - selectionStart });
          }
          if (this.isRtlDir) {
            for (var i = 0; i < selections.length; i++) {
              selections[i].left += this.rtlLineOffset;
            }
          }
          return selections;
        };
        BidiHandler2.prototype.offsetToCol = function(posX) {
          if (this.isRtlDir)
            posX -= this.rtlLineOffset;
          var logicalIdx = 0, posX = Math.max(posX, 0), offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels, charWidth = this.charWidths[levels[visualIdx]];
          if (this.wrapIndent)
            posX -= this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
          while (posX > offset + charWidth / 2) {
            offset += charWidth;
            if (visualIdx === levels.length - 1) {
              charWidth = 0;
              break;
            }
            charWidth = this.charWidths[levels[++visualIdx]];
          }
          if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && levels[visualIdx] % 2 === 0) {
            if (posX < offset)
              visualIdx--;
            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
          } else if (visualIdx > 0 && levels[visualIdx - 1] % 2 === 0 && levels[visualIdx] % 2 !== 0) {
            logicalIdx = 1 + (posX > offset ? this.bidiMap.logicalFromVisual[visualIdx] : this.bidiMap.logicalFromVisual[visualIdx - 1]);
          } else if (this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && levels[visualIdx - 1] % 2 === 0 || !this.isRtlDir && visualIdx === 0 && levels[visualIdx] % 2 !== 0) {
            logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
          } else {
            if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && charWidth !== 0)
              visualIdx--;
            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
          }
          if (logicalIdx === 0 && this.isRtlDir)
            logicalIdx++;
          return logicalIdx + this.wrapIndent;
        };
        return BidiHandler2;
      }()
    );
    exports2.BidiHandler = BidiHandler;
  });
  ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function(require2, exports2, module2) {
    var oop = require2("./lib/oop");
    var lang = require2("./lib/lang");
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var Range = require2("./range").Range;
    var Selection = (
      /** @class */
      function() {
        function Selection2(session) {
          this.session = session;
          this.doc = session.getDocument();
          this.clearSelection();
          this.cursor = this.lead = this.doc.createAnchor(0, 0);
          this.anchor = this.doc.createAnchor(0, 0);
          this.$silent = false;
          var self2 = this;
          this.cursor.on("change", function(e) {
            self2.$cursorChanged = true;
            if (!self2.$silent)
              self2._emit("changeCursor");
            if (!self2.$isEmpty && !self2.$silent)
              self2._emit("changeSelection");
            if (!self2.$keepDesiredColumnOnChange && e.old.column != e.value.column)
              self2.$desiredColumn = null;
          });
          this.anchor.on("change", function() {
            self2.$anchorChanged = true;
            if (!self2.$isEmpty && !self2.$silent)
              self2._emit("changeSelection");
          });
        }
        Selection2.prototype.isEmpty = function() {
          return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
        };
        Selection2.prototype.isMultiLine = function() {
          return !this.$isEmpty && this.anchor.row != this.cursor.row;
        };
        Selection2.prototype.getCursor = function() {
          return this.lead.getPosition();
        };
        Selection2.prototype.setAnchor = function(row, column) {
          this.$isEmpty = false;
          this.anchor.setPosition(row, column);
        };
        Selection2.prototype.getAnchor = function() {
          if (this.$isEmpty)
            return this.getSelectionLead();
          return this.anchor.getPosition();
        };
        Selection2.prototype.getSelectionLead = function() {
          return this.lead.getPosition();
        };
        Selection2.prototype.isBackwards = function() {
          var anchor = this.anchor;
          var lead = this.lead;
          return anchor.row > lead.row || anchor.row == lead.row && anchor.column > lead.column;
        };
        Selection2.prototype.getRange = function() {
          var anchor = this.anchor;
          var lead = this.lead;
          if (this.$isEmpty)
            return Range.fromPoints(lead, lead);
          return this.isBackwards() ? Range.fromPoints(lead, anchor) : Range.fromPoints(anchor, lead);
        };
        Selection2.prototype.clearSelection = function() {
          if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit("changeSelection");
          }
        };
        Selection2.prototype.selectAll = function() {
          this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
        };
        Selection2.prototype.setRange = function(range, reverse) {
          var start = reverse ? range.end : range.start;
          var end = reverse ? range.start : range.end;
          this.$setSelection(start.row, start.column, end.row, end.column);
        };
        Selection2.prototype.$setSelection = function(anchorRow, anchorColumn, cursorRow, cursorColumn) {
          if (this.$silent)
            return;
          var wasEmpty = this.$isEmpty;
          var wasMultiselect = this.inMultiSelectMode;
          this.$silent = true;
          this.$cursorChanged = this.$anchorChanged = false;
          this.anchor.setPosition(anchorRow, anchorColumn);
          this.cursor.setPosition(cursorRow, cursorColumn);
          this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);
          this.$silent = false;
          if (this.$cursorChanged)
            this._emit("changeCursor");
          if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)
            this._emit("changeSelection");
        };
        Selection2.prototype.$moveSelection = function(mover) {
          var lead = this.lead;
          if (this.$isEmpty)
            this.setSelectionAnchor(lead.row, lead.column);
          mover.call(this);
        };
        Selection2.prototype.selectTo = function(row, column) {
          this.$moveSelection(function() {
            this.moveCursorTo(row, column);
          });
        };
        Selection2.prototype.selectToPosition = function(pos) {
          this.$moveSelection(function() {
            this.moveCursorToPosition(pos);
          });
        };
        Selection2.prototype.moveTo = function(row, column) {
          this.clearSelection();
          this.moveCursorTo(row, column);
        };
        Selection2.prototype.moveToPosition = function(pos) {
          this.clearSelection();
          this.moveCursorToPosition(pos);
        };
        Selection2.prototype.selectUp = function() {
          this.$moveSelection(this.moveCursorUp);
        };
        Selection2.prototype.selectDown = function() {
          this.$moveSelection(this.moveCursorDown);
        };
        Selection2.prototype.selectRight = function() {
          this.$moveSelection(this.moveCursorRight);
        };
        Selection2.prototype.selectLeft = function() {
          this.$moveSelection(this.moveCursorLeft);
        };
        Selection2.prototype.selectLineStart = function() {
          this.$moveSelection(this.moveCursorLineStart);
        };
        Selection2.prototype.selectLineEnd = function() {
          this.$moveSelection(this.moveCursorLineEnd);
        };
        Selection2.prototype.selectFileEnd = function() {
          this.$moveSelection(this.moveCursorFileEnd);
        };
        Selection2.prototype.selectFileStart = function() {
          this.$moveSelection(this.moveCursorFileStart);
        };
        Selection2.prototype.selectWordRight = function() {
          this.$moveSelection(this.moveCursorWordRight);
        };
        Selection2.prototype.selectWordLeft = function() {
          this.$moveSelection(this.moveCursorWordLeft);
        };
        Selection2.prototype.getWordRange = function(row, column) {
          if (typeof column == "undefined") {
            var cursor = row || this.lead;
            row = cursor.row;
            column = cursor.column;
          }
          return this.session.getWordRange(row, column);
        };
        Selection2.prototype.selectWord = function() {
          this.setSelectionRange(this.getWordRange());
        };
        Selection2.prototype.selectAWord = function() {
          var cursor = this.getCursor();
          var range = this.session.getAWordRange(cursor.row, cursor.column);
          this.setSelectionRange(range);
        };
        Selection2.prototype.getLineRange = function(row, excludeLastChar) {
          var rowStart = typeof row == "number" ? row : this.lead.row;
          var rowEnd;
          var foldLine = this.session.getFoldLine(rowStart);
          if (foldLine) {
            rowStart = foldLine.start.row;
            rowEnd = foldLine.end.row;
          } else {
            rowEnd = rowStart;
          }
          if (excludeLastChar === true)
            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
          else
            return new Range(rowStart, 0, rowEnd + 1, 0);
        };
        Selection2.prototype.selectLine = function() {
          this.setSelectionRange(this.getLineRange());
        };
        Selection2.prototype.moveCursorUp = function() {
          this.moveCursorBy(-1, 0);
        };
        Selection2.prototype.moveCursorDown = function() {
          this.moveCursorBy(1, 0);
        };
        Selection2.prototype.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {
          var start = cursor.column;
          var end = cursor.column + tabSize;
          if (direction < 0) {
            start = cursor.column - tabSize;
            end = cursor.column;
          }
          return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length - 1 == tabSize;
        };
        Selection2.prototype.moveCursorLeft = function() {
          var cursor = this.lead.getPosition(), fold;
          if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
          } else if (cursor.column === 0) {
            if (cursor.row > 0) {
              this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            }
          } else {
            var tabSize = this.session.getTabSize();
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
              this.moveCursorBy(0, -tabSize);
            } else {
              this.moveCursorBy(0, -1);
            }
          }
        };
        Selection2.prototype.moveCursorRight = function() {
          var cursor = this.lead.getPosition(), fold;
          if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
            this.moveCursorTo(fold.end.row, fold.end.column);
          } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
            if (this.lead.row < this.doc.getLength() - 1) {
              this.moveCursorTo(this.lead.row + 1, 0);
            }
          } else {
            var tabSize = this.session.getTabSize();
            var cursor = this.lead;
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
              this.moveCursorBy(0, tabSize);
            } else {
              this.moveCursorBy(0, 1);
            }
          }
        };
        Selection2.prototype.moveCursorLineStart = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var screenRow = this.session.documentToScreenRow(row, column);
          var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
          var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
          var leadingSpace = beforeCursor.match(/^\s*/);
          if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
            firstColumnPosition.column += leadingSpace[0].length;
          this.moveCursorToPosition(firstColumnPosition);
        };
        Selection2.prototype.moveCursorLineEnd = function() {
          var lead = this.lead;
          var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
          if (this.lead.column == lineEnd.column) {
            var line = this.session.getLine(lineEnd.row);
            if (lineEnd.column == line.length) {
              var textEnd = line.search(/\s+$/);
              if (textEnd > 0)
                lineEnd.column = textEnd;
            }
          }
          this.moveCursorTo(lineEnd.row, lineEnd.column);
        };
        Selection2.prototype.moveCursorFileEnd = function() {
          var row = this.doc.getLength() - 1;
          var column = this.doc.getLine(row).length;
          this.moveCursorTo(row, column);
        };
        Selection2.prototype.moveCursorFileStart = function() {
          this.moveCursorTo(0, 0);
        };
        Selection2.prototype.moveCursorLongWordRight = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var line = this.doc.getLine(row);
          var rightOfCursor = line.substring(column);
          this.session.nonTokenRe.lastIndex = 0;
          this.session.tokenRe.lastIndex = 0;
          var fold = this.session.getFoldAt(row, column, 1);
          if (fold) {
            this.moveCursorTo(fold.end.row, fold.end.column);
            return;
          }
          if (this.session.nonTokenRe.exec(rightOfCursor)) {
            column += this.session.nonTokenRe.lastIndex;
            this.session.nonTokenRe.lastIndex = 0;
            rightOfCursor = line.substring(column);
          }
          if (column >= line.length) {
            this.moveCursorTo(row, line.length);
            this.moveCursorRight();
            if (row < this.doc.getLength() - 1)
              this.moveCursorWordRight();
            return;
          }
          if (this.session.tokenRe.exec(rightOfCursor)) {
            column += this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
          }
          this.moveCursorTo(row, column);
        };
        Selection2.prototype.moveCursorLongWordLeft = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var fold;
          if (fold = this.session.getFoldAt(row, column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
            return;
          }
          var str = this.session.getFoldStringAt(row, column, -1);
          if (str == null) {
            str = this.doc.getLine(row).substring(0, column);
          }
          var leftOfCursor = lang.stringReverse(str);
          this.session.nonTokenRe.lastIndex = 0;
          this.session.tokenRe.lastIndex = 0;
          if (this.session.nonTokenRe.exec(leftOfCursor)) {
            column -= this.session.nonTokenRe.lastIndex;
            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
            this.session.nonTokenRe.lastIndex = 0;
          }
          if (column <= 0) {
            this.moveCursorTo(row, 0);
            this.moveCursorLeft();
            if (row > 0)
              this.moveCursorWordLeft();
            return;
          }
          if (this.session.tokenRe.exec(leftOfCursor)) {
            column -= this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
          }
          this.moveCursorTo(row, column);
        };
        Selection2.prototype.$shortWordEndIndex = function(rightOfCursor) {
          var index2 = 0, ch;
          var whitespaceRe = /\s/;
          var tokenRe = this.session.tokenRe;
          tokenRe.lastIndex = 0;
          if (this.session.tokenRe.exec(rightOfCursor)) {
            index2 = this.session.tokenRe.lastIndex;
          } else {
            while ((ch = rightOfCursor[index2]) && whitespaceRe.test(ch))
              index2++;
            if (index2 < 1) {
              tokenRe.lastIndex = 0;
              while ((ch = rightOfCursor[index2]) && !tokenRe.test(ch)) {
                tokenRe.lastIndex = 0;
                index2++;
                if (whitespaceRe.test(ch)) {
                  if (index2 > 2) {
                    index2--;
                    break;
                  } else {
                    while ((ch = rightOfCursor[index2]) && whitespaceRe.test(ch))
                      index2++;
                    if (index2 > 2)
                      break;
                  }
                }
              }
            }
          }
          tokenRe.lastIndex = 0;
          return index2;
        };
        Selection2.prototype.moveCursorShortWordRight = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var line = this.doc.getLine(row);
          var rightOfCursor = line.substring(column);
          var fold = this.session.getFoldAt(row, column, 1);
          if (fold)
            return this.moveCursorTo(fold.end.row, fold.end.column);
          if (column == line.length) {
            var l = this.doc.getLength();
            do {
              row++;
              rightOfCursor = this.doc.getLine(row);
            } while (row < l && /^\s*$/.test(rightOfCursor));
            if (!/^\s+/.test(rightOfCursor))
              rightOfCursor = "";
            column = 0;
          }
          var index2 = this.$shortWordEndIndex(rightOfCursor);
          this.moveCursorTo(row, column + index2);
        };
        Selection2.prototype.moveCursorShortWordLeft = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var fold;
          if (fold = this.session.getFoldAt(row, column, -1))
            return this.moveCursorTo(fold.start.row, fold.start.column);
          var line = this.session.getLine(row).substring(0, column);
          if (column === 0) {
            do {
              row--;
              line = this.doc.getLine(row);
            } while (row > 0 && /^\s*$/.test(line));
            column = line.length;
            if (!/\s+$/.test(line))
              line = "";
          }
          var leftOfCursor = lang.stringReverse(line);
          var index2 = this.$shortWordEndIndex(leftOfCursor);
          return this.moveCursorTo(row, column - index2);
        };
        Selection2.prototype.moveCursorWordRight = function() {
          if (this.session.$selectLongWords)
            this.moveCursorLongWordRight();
          else
            this.moveCursorShortWordRight();
        };
        Selection2.prototype.moveCursorWordLeft = function() {
          if (this.session.$selectLongWords)
            this.moveCursorLongWordLeft();
          else
            this.moveCursorShortWordLeft();
        };
        Selection2.prototype.moveCursorBy = function(rows, chars) {
          var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
          var offsetX;
          if (chars === 0) {
            if (rows !== 0) {
              if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
              } else {
                offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
              }
            }
            if (this.$desiredColumn)
              screenPos.column = this.$desiredColumn;
            else
              this.$desiredColumn = screenPos.column;
          }
          if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
            var widget = this.session.lineWidgets[this.lead.row];
            if (rows < 0)
              rows -= widget.rowsAbove || 0;
            else if (rows > 0)
              rows += widget.rowCount - (widget.rowsAbove || 0);
          }
          var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
          if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) ;
          this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
        };
        Selection2.prototype.moveCursorToPosition = function(position) {
          this.moveCursorTo(position.row, position.column);
        };
        Selection2.prototype.moveCursorTo = function(row, column, keepDesiredColumn) {
          var fold = this.session.getFoldAt(row, column, 1);
          if (fold) {
            row = fold.start.row;
            column = fold.start.column;
          }
          this.$keepDesiredColumnOnChange = true;
          var line = this.session.getLine(row);
          if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
            if (this.lead.row == row && this.lead.column == column + 1)
              column = column - 1;
            else
              column = column + 1;
          }
          this.lead.setPosition(row, column);
          this.$keepDesiredColumnOnChange = false;
          if (!keepDesiredColumn)
            this.$desiredColumn = null;
        };
        Selection2.prototype.moveCursorToScreen = function(row, column, keepDesiredColumn) {
          var pos = this.session.screenToDocumentPosition(row, column);
          this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
        };
        Selection2.prototype.detach = function() {
          this.lead.detach();
          this.anchor.detach();
        };
        Selection2.prototype.fromOrientedRange = function(range) {
          this.setSelectionRange(range, range.cursor == range.start);
          this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
        };
        Selection2.prototype.toOrientedRange = function(range) {
          var r = this.getRange();
          if (range) {
            range.start.column = r.start.column;
            range.start.row = r.start.row;
            range.end.column = r.end.column;
            range.end.row = r.end.row;
          } else {
            range = r;
          }
          range.cursor = this.isBackwards() ? range.start : range.end;
          range.desiredColumn = this.$desiredColumn;
          return range;
        };
        Selection2.prototype.getRangeOfMovements = function(func) {
          var start = this.getCursor();
          try {
            func(this);
            var end = this.getCursor();
            return Range.fromPoints(start, end);
          } catch (e) {
            return Range.fromPoints(start, start);
          } finally {
            this.moveCursorToPosition(start);
          }
        };
        Selection2.prototype.toJSON = function() {
          if (this.rangeCount) {
            var data = this.ranges.map(function(r) {
              var r1 = r.clone();
              r1.isBackwards = r.cursor == r.start;
              return r1;
            });
          } else {
            var data = this.getRange();
            data.isBackwards = this.isBackwards();
          }
          return data;
        };
        Selection2.prototype.fromJSON = function(data) {
          if (data.start == void 0) {
            if (this.rangeList && data.length > 1) {
              this.toSingleRange(data[0]);
              for (var i = data.length; i--; ) {
                var r = Range.fromPoints(data[i].start, data[i].end);
                if (data[i].isBackwards)
                  r.cursor = r.start;
                this.addRange(r, true);
              }
              return;
            } else {
              data = data[0];
            }
          }
          if (this.rangeList)
            this.toSingleRange(data);
          this.setSelectionRange(data, data.isBackwards);
        };
        Selection2.prototype.isEqual = function(data) {
          if ((data.length || this.rangeCount) && data.length != this.rangeCount)
            return false;
          if (!data.length || !this.ranges)
            return this.getRange().isEqual(data);
          for (var i = this.ranges.length; i--; ) {
            if (!this.ranges[i].isEqual(data[i]))
              return false;
          }
          return true;
        };
        return Selection2;
      }()
    );
    Selection.prototype.setSelectionAnchor = Selection.prototype.setAnchor;
    Selection.prototype.getSelectionAnchor = Selection.prototype.getAnchor;
    Selection.prototype.setSelectionRange = Selection.prototype.setRange;
    oop.implement(Selection.prototype, EventEmitter);
    exports2.Selection = Selection;
  });
  ace.define("ace/tokenizer", ["require", "exports", "module", "ace/lib/report_error"], function(require2, exports2, module2) {
    var reportError2 = require2("./lib/report_error").reportError;
    var MAX_TOKEN_COUNT = 2e3;
    var Tokenizer = (
      /** @class */
      function() {
        function Tokenizer2(rules) {
          this.splitRegex;
          this.states = rules;
          this.regExps = {};
          this.matchMappings = {};
          for (var key in this.states) {
            var state = this.states[key];
            var ruleRegExps = [];
            var matchTotal = 0;
            var mapping = this.matchMappings[key] = { defaultToken: "text" };
            var flag = "g";
            var splitterRurles = [];
            for (var i = 0; i < state.length; i++) {
              var rule = state[i];
              if (rule.defaultToken)
                mapping.defaultToken = rule.defaultToken;
              if (rule.caseInsensitive && flag.indexOf("i") === -1)
                flag += "i";
              if (rule.unicode && flag.indexOf("u") === -1)
                flag += "u";
              if (rule.regex == null)
                continue;
              if (rule.regex instanceof RegExp)
                rule.regex = rule.regex.toString().slice(1, -1);
              var adjustedregex = rule.regex;
              var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
              if (Array.isArray(rule.token)) {
                if (rule.token.length == 1 || matchcount == 1) {
                  rule.token = rule.token[0];
                } else if (matchcount - 1 != rule.token.length) {
                  this.reportError("number of classes and regexp groups doesn't match", {
                    rule,
                    groupCount: matchcount - 1
                  });
                  rule.token = rule.token[0];
                } else {
                  rule.tokenArray = rule.token;
                  rule.token = null;
                  rule.onMatch = this.$arrayTokens;
                }
              } else if (typeof rule.token == "function" && !rule.onMatch) {
                if (matchcount > 1)
                  rule.onMatch = this.$applyToken;
                else
                  rule.onMatch = rule.token;
              }
              if (matchcount > 1) {
                if (/\\\d/.test(rule.regex)) {
                  adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                    return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                  });
                } else {
                  matchcount = 1;
                  adjustedregex = this.removeCapturingGroups(rule.regex);
                }
                if (!rule.splitRegex && typeof rule.token != "string")
                  splitterRurles.push(rule);
              }
              mapping[matchTotal] = i;
              matchTotal += matchcount;
              ruleRegExps.push(adjustedregex);
              if (!rule.onMatch)
                rule.onMatch = null;
            }
            if (!ruleRegExps.length) {
              mapping[0] = 0;
              ruleRegExps.push("$");
            }
            splitterRurles.forEach(function(rule2) {
              rule2.splitRegex = this.createSplitterRegexp(rule2.regex, flag);
            }, this);
            this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
          }
        }
        Tokenizer2.prototype.$setMaxTokenCount = function(m) {
          MAX_TOKEN_COUNT = m | 0;
        };
        Tokenizer2.prototype.$applyToken = function(str) {
          var values = this.splitRegex.exec(str).slice(1);
          var types = this.token.apply(this, values);
          if (typeof types === "string")
            return [{ type: types, value: str }];
          var tokens = [];
          for (var i = 0, l = types.length; i < l; i++) {
            if (values[i])
              tokens[tokens.length] = {
                type: types[i],
                value: values[i]
              };
          }
          return tokens;
        };
        Tokenizer2.prototype.$arrayTokens = function(str) {
          if (!str)
            return [];
          var values = this.splitRegex.exec(str);
          if (!values)
            return "text";
          var tokens = [];
          var types = this.tokenArray;
          for (var i = 0, l = types.length; i < l; i++) {
            if (values[i + 1])
              tokens[tokens.length] = {
                type: types[i],
                value: values[i + 1]
              };
          }
          return tokens;
        };
        Tokenizer2.prototype.removeCapturingGroups = function(src) {
          var r = src.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!<]|(\()/g, function(x, y) {
            return y ? "(?:" : x;
          });
          return r;
        };
        Tokenizer2.prototype.createSplitterRegexp = function(src, flag) {
          if (src.indexOf("(?=") != -1) {
            var stack = 0;
            var inChClass = false;
            var lastCapture = {};
            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(m, esc, parenOpen, parenClose, square, index2) {
              if (inChClass) {
                inChClass = square != "]";
              } else if (square) {
                inChClass = true;
              } else if (parenClose) {
                if (stack == lastCapture.stack) {
                  lastCapture.end = index2 + 1;
                  lastCapture.stack = -1;
                }
                stack--;
              } else if (parenOpen) {
                stack++;
                if (parenOpen.length != 1) {
                  lastCapture.stack = stack;
                  lastCapture.start = index2;
                }
              }
              return m;
            });
            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
              src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
          }
          if (src.charAt(0) != "^")
            src = "^" + src;
          if (src.charAt(src.length - 1) != "$")
            src += "$";
          return new RegExp(src, (flag || "").replace("g", ""));
        };
        Tokenizer2.prototype.getLineTokens = function(line, startState) {
          if (startState && typeof startState != "string") {
            var stack = startState.slice(0);
            startState = stack[0];
            if (startState === "#tmp") {
              stack.shift();
              startState = stack.shift();
            }
          } else
            var stack = [];
          var currentState = (
            /**@type{string}*/
            startState || "start"
          );
          var state = this.states[currentState];
          if (!state) {
            currentState = "start";
            state = this.states[currentState];
          }
          var mapping = this.matchMappings[currentState];
          var re = this.regExps[currentState];
          re.lastIndex = 0;
          var match, tokens = [];
          var lastIndex = 0;
          var matchAttempts = 0;
          var token = { type: null, value: "" };
          while (match = re.exec(line)) {
            var type = mapping.defaultToken;
            var rule = null;
            var value = match[0];
            var index2 = re.lastIndex;
            if (index2 - value.length > lastIndex) {
              var skipped = line.substring(lastIndex, index2 - value.length);
              if (token.type == type) {
                token.value += skipped;
              } else {
                if (token.type)
                  tokens.push(token);
                token = { type, value: skipped };
              }
            }
            for (var i = 0; i < match.length - 2; i++) {
              if (match[i + 1] === void 0)
                continue;
              rule = state[mapping[i]];
              if (rule.onMatch)
                type = rule.onMatch(value, currentState, stack, line);
              else
                type = rule.token;
              if (rule.next) {
                if (typeof rule.next == "string") {
                  currentState = rule.next;
                } else {
                  currentState = rule.next(currentState, stack);
                }
                state = this.states[currentState];
                if (!state) {
                  this.reportError("state doesn't exist", currentState);
                  currentState = "start";
                  state = this.states[currentState];
                }
                mapping = this.matchMappings[currentState];
                lastIndex = index2;
                re = this.regExps[currentState];
                re.lastIndex = index2;
              }
              if (rule.consumeLineEnd)
                lastIndex = index2;
              break;
            }
            if (value) {
              if (typeof type === "string") {
                if ((!rule || rule.merge !== false) && token.type === type) {
                  token.value += value;
                } else {
                  if (token.type)
                    tokens.push(token);
                  token = { type, value };
                }
              } else if (type) {
                if (token.type)
                  tokens.push(token);
                token = { type: null, value: "" };
                for (var i = 0; i < type.length; i++)
                  tokens.push(type[i]);
              }
            }
            if (lastIndex == line.length)
              break;
            lastIndex = index2;
            if (matchAttempts++ > MAX_TOKEN_COUNT) {
              if (matchAttempts > 2 * line.length) {
                this.reportError("infinite loop with in ace tokenizer", {
                  startState,
                  line
                });
              }
              while (lastIndex < line.length) {
                if (token.type)
                  tokens.push(token);
                token = {
                  value: line.substring(lastIndex, lastIndex += 500),
                  type: "overflow"
                };
              }
              currentState = "start";
              stack = [];
              break;
            }
          }
          if (token.type)
            tokens.push(token);
          if (stack.length > 1) {
            if (stack[0] !== currentState)
              stack.unshift("#tmp", currentState);
          }
          return {
            tokens,
            state: stack.length ? stack : currentState
          };
        };
        return Tokenizer2;
      }()
    );
    Tokenizer.prototype.reportError = reportError2;
    exports2.Tokenizer = Tokenizer;
  });
  ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/deep_copy"], function(require2, exports2, module2) {
    var deepCopy = require2("../lib/deep_copy").deepCopy;
    var TextHighlightRules;
    TextHighlightRules = function() {
      this.$rules = {
        "start": [{
          token: "empty_line",
          regex: "^$"
        }, {
          defaultToken: "text"
        }]
      };
    };
    (function() {
      this.addRules = function(rules, prefix2) {
        if (!prefix2) {
          for (var key in rules)
            this.$rules[key] = rules[key];
          return;
        }
        for (var key in rules) {
          var state = rules[key];
          for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            if (rule.next || rule.onMatch) {
              if (typeof rule.next == "string") {
                if (rule.next.indexOf(prefix2) !== 0)
                  rule.next = prefix2 + rule.next;
              }
              if (rule.nextState && rule.nextState.indexOf(prefix2) !== 0)
                rule.nextState = prefix2 + rule.nextState;
            }
          }
          this.$rules[prefix2 + key] = state;
        }
      };
      this.getRules = function() {
        return this.$rules;
      };
      this.embedRules = function(HighlightRules, prefix2, escapeRules, states, append) {
        var embedRules = typeof HighlightRules == "function" ? new HighlightRules().getRules() : HighlightRules;
        if (states) {
          for (var i = 0; i < states.length; i++)
            states[i] = prefix2 + states[i];
        } else {
          states = [];
          for (var key in embedRules)
            states.push(prefix2 + key);
        }
        this.addRules(embedRules, prefix2);
        if (escapeRules) {
          var addRules = Array.prototype[append ? "push" : "unshift"];
          for (var i = 0; i < states.length; i++)
            addRules.apply(this.$rules[states[i]], deepCopy(escapeRules));
        }
        if (!this.$embeds)
          this.$embeds = [];
        this.$embeds.push(prefix2);
      };
      this.getEmbeds = function() {
        return this.$embeds;
      };
      var pushState = function(currentState, stack) {
        if (currentState != "start" || stack.length)
          stack.unshift(this.nextState, currentState);
        return this.nextState;
      };
      var popState = function(currentState, stack) {
        stack.shift();
        return stack.shift() || "start";
      };
      this.normalizeRules = function() {
        var id2 = 0;
        var rules = this.$rules;
        function processState(key) {
          var state = rules[key];
          state["processed"] = true;
          for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            var toInsert = null;
            if (Array.isArray(rule)) {
              toInsert = rule;
              rule = {};
            }
            if (!rule.regex && rule.start) {
              rule.regex = rule.start;
              if (!rule.next)
                rule.next = [];
              rule.next.push({
                defaultToken: rule.token
              }, {
                token: rule.token + ".end",
                regex: rule.end || rule.start,
                next: "pop"
              });
              rule.token = rule.token + ".start";
              rule.push = true;
            }
            var next = rule.next || rule.push;
            if (next && Array.isArray(next)) {
              var stateName = rule.stateName;
              if (!stateName) {
                stateName = rule.token;
                if (typeof stateName != "string")
                  stateName = stateName[0] || "";
                if (rules[stateName])
                  stateName += id2++;
              }
              rules[stateName] = next;
              rule.next = stateName;
              processState(stateName);
            } else if (next == "pop") {
              rule.next = popState;
            }
            if (rule.push) {
              rule.nextState = rule.next || rule.push;
              rule.next = pushState;
              delete rule.push;
            }
            if (rule.rules) {
              for (var r in rule.rules) {
                if (rules[r]) {
                  if (rules[r].push)
                    rules[r].push.apply(rules[r], rule.rules[r]);
                } else {
                  rules[r] = rule.rules[r];
                }
              }
            }
            var includeName = typeof rule == "string" ? rule : rule.include;
            if (includeName) {
              if (includeName === "$self")
                includeName = "start";
              if (Array.isArray(includeName))
                toInsert = includeName.map(function(x) {
                  return rules[x];
                });
              else
                toInsert = rules[includeName];
            }
            if (toInsert) {
              var args = [i, 1].concat(toInsert);
              if (rule.noEscape)
                args = args.filter(function(x) {
                  return !x.next;
                });
              state.splice.apply(state, args);
              i--;
            }
            if (rule.keywordMap) {
              rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
              delete rule.defaultToken;
            }
          }
        }
        Object.keys(rules).forEach(processState, this);
      };
      this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
        var keywords = /* @__PURE__ */ Object.create(null);
        this.$keywordList = [];
        Object.keys(map).forEach(function(className) {
          var a = map[className];
          var list2 = a.split(splitChar || "|");
          for (var i = list2.length; i--; ) {
            var word = list2[i];
            this.$keywordList.push(word);
            if (ignoreCase)
              word = word.toLowerCase();
            keywords[word] = className;
          }
        }, this);
        map = null;
        return ignoreCase ? function(value) {
          return keywords[value.toLowerCase()] || defaultToken;
        } : function(value) {
          return keywords[value] || defaultToken;
        };
      };
      this.getKeywords = function() {
        return this.$keywords;
      };
    }).call(TextHighlightRules.prototype);
    exports2.TextHighlightRules = TextHighlightRules;
  });
  ace.define("ace/mode/behaviour", ["require", "exports", "module"], function(require2, exports2, module2) {
    var Behaviour;
    Behaviour = function() {
      this.$behaviours = {};
    };
    (function() {
      this.add = function(name, action, callback) {
        switch (void 0) {
          case this.$behaviours:
            this.$behaviours = {};
          case this.$behaviours[name]:
            this.$behaviours[name] = {};
        }
        this.$behaviours[name][action] = callback;
      };
      this.addBehaviours = function(behaviours) {
        for (var key in behaviours) {
          for (var action in behaviours[key]) {
            this.add(key, action, behaviours[key][action]);
          }
        }
      };
      this.remove = function(name) {
        if (this.$behaviours && this.$behaviours[name]) {
          delete this.$behaviours[name];
        }
      };
      this.inherit = function(mode, filter) {
        if (typeof mode === "function") {
          var behaviours = new mode().getBehaviours(filter);
        } else {
          var behaviours = mode.getBehaviours(filter);
        }
        this.addBehaviours(behaviours);
      };
      this.getBehaviours = function(filter) {
        if (!filter) {
          return this.$behaviours;
        } else {
          var ret = {};
          for (var i = 0; i < filter.length; i++) {
            if (this.$behaviours[filter[i]]) {
              ret[filter[i]] = this.$behaviours[filter[i]];
            }
          }
          return ret;
        }
      };
    }).call(Behaviour.prototype);
    exports2.Behaviour = Behaviour;
  });
  ace.define("ace/token_iterator", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
    var Range = require2("./range").Range;
    var TokenIterator = (
      /** @class */
      function() {
        function TokenIterator2(session, initialRow, initialColumn) {
          this.$session = session;
          this.$row = initialRow;
          this.$rowTokens = session.getTokens(initialRow);
          var token = session.getTokenAt(initialRow, initialColumn);
          this.$tokenIndex = token ? token.index : -1;
        }
        TokenIterator2.prototype.stepBackward = function() {
          this.$tokenIndex -= 1;
          while (this.$tokenIndex < 0) {
            this.$row -= 1;
            if (this.$row < 0) {
              this.$row = 0;
              return null;
            }
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = this.$rowTokens.length - 1;
          }
          return this.$rowTokens[this.$tokenIndex];
        };
        TokenIterator2.prototype.stepForward = function() {
          this.$tokenIndex += 1;
          var rowCount;
          while (this.$tokenIndex >= this.$rowTokens.length) {
            this.$row += 1;
            if (!rowCount)
              rowCount = this.$session.getLength();
            if (this.$row >= rowCount) {
              this.$row = rowCount - 1;
              return null;
            }
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = 0;
          }
          return this.$rowTokens[this.$tokenIndex];
        };
        TokenIterator2.prototype.getCurrentToken = function() {
          return this.$rowTokens[this.$tokenIndex];
        };
        TokenIterator2.prototype.getCurrentTokenRow = function() {
          return this.$row;
        };
        TokenIterator2.prototype.getCurrentTokenColumn = function() {
          var rowTokens = this.$rowTokens;
          var tokenIndex = this.$tokenIndex;
          var column = rowTokens[tokenIndex].start;
          if (column !== void 0)
            return column;
          column = 0;
          while (tokenIndex > 0) {
            tokenIndex -= 1;
            column += rowTokens[tokenIndex].value.length;
          }
          return column;
        };
        TokenIterator2.prototype.getCurrentTokenPosition = function() {
          return { row: this.$row, column: this.getCurrentTokenColumn() };
        };
        TokenIterator2.prototype.getCurrentTokenRange = function() {
          var token = this.$rowTokens[this.$tokenIndex];
          var column = this.getCurrentTokenColumn();
          return new Range(this.$row, column, this.$row, column + token.value.length);
        };
        return TokenIterator2;
      }()
    );
    exports2.TokenIterator = TokenIterator;
  });
  ace.define("ace/mode/behaviour/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function(require2, exports2, module2) {
    var oop = require2("../../lib/oop");
    var Behaviour = require2("../behaviour").Behaviour;
    var TokenIterator = require2("../../token_iterator").TokenIterator;
    var lang = require2("../../lib/lang");
    var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator"];
    var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator", "comment"];
    var context;
    var contextCache = {};
    var defaultQuotes = { '"': '"', "'": "'" };
    var initContext = function(editor2) {
      var id2 = -1;
      if (editor2.multiSelect) {
        id2 = editor2.selection.index;
        if (contextCache.rangeCount != editor2.multiSelect.rangeCount)
          contextCache = { rangeCount: editor2.multiSelect.rangeCount };
      }
      if (contextCache[id2])
        return context = contextCache[id2];
      context = contextCache[id2] = {
        autoInsertedBrackets: 0,
        autoInsertedRow: -1,
        autoInsertedLineEnd: "",
        maybeInsertedBrackets: 0,
        maybeInsertedRow: -1,
        maybeInsertedLineStart: "",
        maybeInsertedLineEnd: ""
      };
    };
    var getWrapped = function(selection, selected, opening, closing) {
      var rowDiff = selection.end.row - selection.start.row;
      return {
        text: opening + selected + closing,
        selection: [
          0,
          selection.start.column + 1,
          rowDiff,
          selection.end.column + (rowDiff ? 0 : 1)
        ]
      };
    };
    var CstyleBehaviour;
    CstyleBehaviour = function(options) {
      options = options || {};
      this.add("braces", "insertion", function(state, action, editor2, session, text) {
        var cursor = editor2.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (text == "{") {
          initContext(editor2);
          var selection = editor2.getSelectionRange();
          var selected = session.doc.getTextRange(selection);
          var token = session.getTokenAt(cursor.row, cursor.column);
          if (selected !== "" && selected !== "{" && editor2.getWrapBehavioursEnabled()) {
            return getWrapped(selection, selected, "{", "}");
          } else if (token && /(?:string)\.quasi|\.xml/.test(token.type)) {
            var excludeTokens = [
              /tag\-(?:open|name)/,
              /attribute\-name/
            ];
            if (excludeTokens.some(function(el) {
              return el.test(token.type);
            }) || /(string)\.quasi/.test(token.type) && token.value[cursor.column - token.start - 1] !== "$")
              return;
            CstyleBehaviour.recordAutoInsert(editor2, session, "}");
            return {
              text: "{}",
              selection: [1, 1]
            };
          } else if (CstyleBehaviour.isSaneInsertion(editor2, session)) {
            if (/[\]\}\)]/.test(line[cursor.column]) || editor2.inMultiSelectMode || options.braces) {
              CstyleBehaviour.recordAutoInsert(editor2, session, "}");
              return {
                text: "{}",
                selection: [1, 1]
              };
            } else {
              CstyleBehaviour.recordMaybeInsert(editor2, session, "{");
              return {
                text: "{",
                selection: [1, 1]
              };
            }
          }
        } else if (text == "}") {
          initContext(editor2);
          var rightChar = line.substring(cursor.column, cursor.column + 1);
          if (rightChar == "}") {
            var matching = session.$findOpeningBracket("}", { column: cursor.column + 1, row: cursor.row });
            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
              CstyleBehaviour.popAutoInsertedClosing();
              return {
                text: "",
                selection: [1, 1]
              };
            }
          }
        } else if (text == "\n" || text == "\r\n") {
          initContext(editor2);
          var closing = "";
          if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
            closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
            CstyleBehaviour.clearMaybeInsertedClosing();
          }
          var rightChar = line.substring(cursor.column, cursor.column + 1);
          if (rightChar === "}") {
            var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, "}");
            if (!openBracePos)
              return null;
            var next_indent = this.$getIndent(session.getLine(openBracePos.row));
          } else if (closing) {
            var next_indent = this.$getIndent(line);
          } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
            return;
          }
          var indent = next_indent + session.getTabString();
          return {
            text: "\n" + indent + "\n" + next_indent + closing,
            selection: [1, indent.length, 1, indent.length]
          };
        } else {
          CstyleBehaviour.clearMaybeInsertedClosing();
        }
      });
      this.add("braces", "deletion", function(state, action, editor2, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == "{") {
          initContext(editor2);
          var line = session.doc.getLine(range.start.row);
          var rightChar = line.substring(range.end.column, range.end.column + 1);
          if (rightChar == "}") {
            range.end.column++;
            return range;
          } else {
            context.maybeInsertedBrackets--;
          }
        }
      });
      this.add("parens", "insertion", function(state, action, editor2, session, text) {
        if (text == "(") {
          initContext(editor2);
          var selection = editor2.getSelectionRange();
          var selected = session.doc.getTextRange(selection);
          if (selected !== "" && editor2.getWrapBehavioursEnabled()) {
            return getWrapped(selection, selected, "(", ")");
          } else if (CstyleBehaviour.isSaneInsertion(editor2, session)) {
            CstyleBehaviour.recordAutoInsert(editor2, session, ")");
            return {
              text: "()",
              selection: [1, 1]
            };
          }
        } else if (text == ")") {
          initContext(editor2);
          var cursor = editor2.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          var rightChar = line.substring(cursor.column, cursor.column + 1);
          if (rightChar == ")") {
            var matching = session.$findOpeningBracket(")", { column: cursor.column + 1, row: cursor.row });
            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
              CstyleBehaviour.popAutoInsertedClosing();
              return {
                text: "",
                selection: [1, 1]
              };
            }
          }
        }
      });
      this.add("parens", "deletion", function(state, action, editor2, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == "(") {
          initContext(editor2);
          var line = session.doc.getLine(range.start.row);
          var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
          if (rightChar == ")") {
            range.end.column++;
            return range;
          }
        }
      });
      this.add("brackets", "insertion", function(state, action, editor2, session, text) {
        if (text == "[") {
          initContext(editor2);
          var selection = editor2.getSelectionRange();
          var selected = session.doc.getTextRange(selection);
          if (selected !== "" && editor2.getWrapBehavioursEnabled()) {
            return getWrapped(selection, selected, "[", "]");
          } else if (CstyleBehaviour.isSaneInsertion(editor2, session)) {
            CstyleBehaviour.recordAutoInsert(editor2, session, "]");
            return {
              text: "[]",
              selection: [1, 1]
            };
          }
        } else if (text == "]") {
          initContext(editor2);
          var cursor = editor2.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          var rightChar = line.substring(cursor.column, cursor.column + 1);
          if (rightChar == "]") {
            var matching = session.$findOpeningBracket("]", { column: cursor.column + 1, row: cursor.row });
            if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
              CstyleBehaviour.popAutoInsertedClosing();
              return {
                text: "",
                selection: [1, 1]
              };
            }
          }
        }
      });
      this.add("brackets", "deletion", function(state, action, editor2, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == "[") {
          initContext(editor2);
          var line = session.doc.getLine(range.start.row);
          var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
          if (rightChar == "]") {
            range.end.column++;
            return range;
          }
        }
      });
      this.add("string_dquotes", "insertion", function(state, action, editor2, session, text) {
        var quotes = session.$mode.$quotes || defaultQuotes;
        if (text.length == 1 && quotes[text]) {
          if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)
            return;
          initContext(editor2);
          var quote = text;
          var selection = editor2.getSelectionRange();
          var selected = session.doc.getTextRange(selection);
          if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor2.getWrapBehavioursEnabled()) {
            return getWrapped(selection, selected, quote, quote);
          } else if (!selected) {
            var cursor = editor2.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var leftChar = line.substring(cursor.column - 1, cursor.column);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            var token = session.getTokenAt(cursor.row, cursor.column);
            var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
            if (leftChar == "\\" && token && /escape/.test(token.type))
              return null;
            var stringBefore = token && /string|escape/.test(token.type);
            var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
            var pair;
            if (rightChar == quote) {
              pair = stringBefore !== stringAfter;
              if (pair && /string\.end/.test(rightToken.type))
                pair = false;
            } else {
              if (stringBefore && !stringAfter)
                return null;
              if (stringBefore && stringAfter)
                return null;
              var wordRe = session.$mode.tokenRe;
              wordRe.lastIndex = 0;
              var isWordBefore = wordRe.test(leftChar);
              wordRe.lastIndex = 0;
              var isWordAfter = wordRe.test(rightChar);
              var pairQuotesAfter = session.$mode.$pairQuotesAfter;
              var shouldPairQuotes = pairQuotesAfter && pairQuotesAfter[quote] && pairQuotesAfter[quote].test(leftChar);
              if (!shouldPairQuotes && isWordBefore || isWordAfter)
                return null;
              if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                return null;
              var charBefore = line[cursor.column - 2];
              if (leftChar == quote && (charBefore == quote || wordRe.test(charBefore)))
                return null;
              pair = true;
            }
            return {
              text: pair ? quote + quote : "",
              selection: [1, 1]
            };
          }
        }
      });
      this.add("string_dquotes", "deletion", function(state, action, editor2, session, range) {
        var quotes = session.$mode.$quotes || defaultQuotes;
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {
          initContext(editor2);
          var line = session.doc.getLine(range.start.row);
          var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
          if (rightChar == selected) {
            range.end.column++;
            return range;
          }
        }
      });
      if (options.closeDocComment !== false) {
        this.add("doc comment end", "insertion", function(state, action, editor2, session, text) {
          if (state === "doc-start" && (text === "\n" || text === "\r\n") && editor2.selection.isEmpty()) {
            var cursor = editor2.getCursorPosition();
            if (cursor.column === 0) {
              return;
            }
            var line = session.doc.getLine(cursor.row);
            var nextLine = session.doc.getLine(cursor.row + 1);
            var tokens = session.getTokens(cursor.row);
            var index2 = 0;
            for (var i = 0; i < tokens.length; i++) {
              index2 += tokens[i].value.length;
              var currentToken = tokens[i];
              if (index2 >= cursor.column) {
                if (index2 === cursor.column) {
                  if (!/\.doc/.test(currentToken.type)) {
                    return;
                  }
                  if (/\*\//.test(currentToken.value)) {
                    var nextToken = tokens[i + 1];
                    if (!nextToken || !/\.doc/.test(nextToken.type)) {
                      return;
                    }
                  }
                }
                var cursorPosInToken = cursor.column - (index2 - currentToken.value.length);
                var closeDocPos = currentToken.value.indexOf("*/");
                var openDocPos = currentToken.value.indexOf("/**", closeDocPos > -1 ? closeDocPos + 2 : 0);
                if (openDocPos !== -1 && cursorPosInToken > openDocPos && cursorPosInToken < openDocPos + 3) {
                  return;
                }
                if (closeDocPos !== -1 && openDocPos !== -1 && cursorPosInToken >= closeDocPos && cursorPosInToken <= openDocPos || !/\.doc/.test(currentToken.type)) {
                  return;
                }
                break;
              }
            }
            var indent = this.$getIndent(line);
            if (/\s*\*/.test(nextLine)) {
              if (/^\s*\*/.test(line)) {
                return {
                  text: text + indent + "* ",
                  selection: [1, 2 + indent.length, 1, 2 + indent.length]
                };
              } else {
                return {
                  text: text + indent + " * ",
                  selection: [1, 3 + indent.length, 1, 3 + indent.length]
                };
              }
            }
            if (/\/\*\*/.test(line.substring(0, cursor.column))) {
              return {
                text: text + indent + " * " + text + " " + indent + "*/",
                selection: [1, 4 + indent.length, 1, 4 + indent.length]
              };
            }
          }
        });
      }
    };
    CstyleBehaviour.isSaneInsertion = function(editor2, session) {
      var cursor = editor2.getCursorPosition();
      var iterator = new TokenIterator(session, cursor.row, cursor.column);
      if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
        if (/[)}\]]/.test(editor2.session.getLine(cursor.row)[cursor.column]))
          return true;
        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
          return false;
      }
      iterator.stepForward();
      return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
    };
    CstyleBehaviour["$matchTokenType"] = function(token, types) {
      return types.indexOf(token.type || token) > -1;
    };
    CstyleBehaviour["recordAutoInsert"] = function(editor2, session, bracket) {
      var cursor = editor2.getCursorPosition();
      var line = session.doc.getLine(cursor.row);
      if (!this["isAutoInsertedClosing"](cursor, line, context.autoInsertedLineEnd[0]))
        context.autoInsertedBrackets = 0;
      context.autoInsertedRow = cursor.row;
      context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
      context.autoInsertedBrackets++;
    };
    CstyleBehaviour["recordMaybeInsert"] = function(editor2, session, bracket) {
      var cursor = editor2.getCursorPosition();
      var line = session.doc.getLine(cursor.row);
      if (!this["isMaybeInsertedClosing"](cursor, line))
        context.maybeInsertedBrackets = 0;
      context.maybeInsertedRow = cursor.row;
      context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
      context.maybeInsertedLineEnd = line.substr(cursor.column);
      context.maybeInsertedBrackets++;
    };
    CstyleBehaviour["isAutoInsertedClosing"] = function(cursor, line, bracket) {
      return context.autoInsertedBrackets > 0 && cursor.row === context.autoInsertedRow && bracket === context.autoInsertedLineEnd[0] && line.substr(cursor.column) === context.autoInsertedLineEnd;
    };
    CstyleBehaviour["isMaybeInsertedClosing"] = function(cursor, line) {
      return context.maybeInsertedBrackets > 0 && cursor.row === context.maybeInsertedRow && line.substr(cursor.column) === context.maybeInsertedLineEnd && line.substr(0, cursor.column) == context.maybeInsertedLineStart;
    };
    CstyleBehaviour["popAutoInsertedClosing"] = function() {
      context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
      context.autoInsertedBrackets--;
    };
    CstyleBehaviour["clearMaybeInsertedClosing"] = function() {
      if (context) {
        context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = -1;
      }
    };
    oop.inherits(CstyleBehaviour, Behaviour);
    exports2.CstyleBehaviour = CstyleBehaviour;
  });
  ace.define("ace/unicode", ["require", "exports", "module"], function(require2, exports2, module2) {
    var wordChars = [48, 9, 8, 25, 5, 0, 2, 25, 48, 0, 11, 0, 5, 0, 6, 22, 2, 30, 2, 457, 5, 11, 15, 4, 8, 0, 2, 0, 18, 116, 2, 1, 3, 3, 9, 0, 2, 2, 2, 0, 2, 19, 2, 82, 2, 138, 2, 4, 3, 155, 12, 37, 3, 0, 8, 38, 10, 44, 2, 0, 2, 1, 2, 1, 2, 0, 9, 26, 6, 2, 30, 10, 7, 61, 2, 9, 5, 101, 2, 7, 3, 9, 2, 18, 3, 0, 17, 58, 3, 100, 15, 53, 5, 0, 6, 45, 211, 57, 3, 18, 2, 5, 3, 11, 3, 9, 2, 1, 7, 6, 2, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 0, 4, 3, 3, 8, 3, 1, 3, 3, 9, 0, 5, 1, 2, 4, 3, 11, 16, 2, 2, 5, 5, 1, 3, 21, 2, 6, 2, 1, 2, 1, 2, 1, 3, 0, 2, 4, 5, 1, 3, 2, 4, 0, 8, 3, 2, 0, 8, 15, 12, 2, 2, 8, 2, 2, 2, 21, 2, 6, 2, 1, 2, 4, 3, 9, 2, 2, 2, 2, 3, 0, 16, 3, 3, 9, 18, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 3, 8, 3, 1, 3, 2, 9, 1, 5, 1, 2, 4, 3, 9, 2, 0, 17, 1, 2, 5, 4, 2, 2, 3, 4, 1, 2, 0, 2, 1, 4, 1, 4, 2, 4, 11, 5, 4, 4, 2, 2, 3, 3, 0, 7, 0, 15, 9, 18, 2, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 4, 7, 2, 2, 2, 3, 8, 1, 2, 1, 7, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 3, 8, 2, 2, 2, 3, 8, 1, 8, 0, 2, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 15, 4, 7, 2, 2, 2, 3, 10, 0, 9, 3, 3, 9, 11, 5, 3, 1, 2, 17, 4, 23, 2, 8, 2, 0, 3, 6, 4, 0, 5, 5, 2, 0, 2, 7, 19, 1, 14, 57, 6, 14, 2, 9, 40, 1, 2, 0, 3, 1, 2, 0, 3, 0, 7, 3, 2, 6, 2, 2, 2, 0, 2, 0, 3, 1, 2, 12, 2, 2, 3, 4, 2, 0, 2, 5, 3, 9, 3, 1, 35, 0, 24, 1, 7, 9, 12, 0, 2, 0, 2, 0, 5, 9, 2, 35, 5, 19, 2, 5, 5, 7, 2, 35, 10, 0, 58, 73, 7, 77, 3, 37, 11, 42, 2, 0, 4, 328, 2, 3, 3, 6, 2, 0, 2, 3, 3, 40, 2, 3, 3, 32, 2, 3, 3, 6, 2, 0, 2, 3, 3, 14, 2, 56, 2, 3, 3, 66, 5, 0, 33, 15, 17, 84, 13, 619, 3, 16, 2, 25, 6, 74, 22, 12, 2, 6, 12, 20, 12, 19, 13, 12, 2, 2, 2, 1, 13, 51, 3, 29, 4, 0, 5, 1, 3, 9, 34, 2, 3, 9, 7, 87, 9, 42, 6, 69, 11, 28, 4, 11, 5, 11, 11, 39, 3, 4, 12, 43, 5, 25, 7, 10, 38, 27, 5, 62, 2, 28, 3, 10, 7, 9, 14, 0, 89, 75, 5, 9, 18, 8, 13, 42, 4, 11, 71, 55, 9, 9, 4, 48, 83, 2, 2, 30, 14, 230, 23, 280, 3, 5, 3, 37, 3, 5, 3, 7, 2, 0, 2, 0, 2, 0, 2, 30, 3, 52, 2, 6, 2, 0, 4, 2, 2, 6, 4, 3, 3, 5, 5, 12, 6, 2, 2, 6, 67, 1, 20, 0, 29, 0, 14, 0, 17, 4, 60, 12, 5, 0, 4, 11, 18, 0, 5, 0, 3, 9, 2, 0, 4, 4, 7, 0, 2, 0, 2, 0, 2, 3, 2, 10, 3, 3, 6, 4, 5, 0, 53, 1, 2684, 46, 2, 46, 2, 132, 7, 6, 15, 37, 11, 53, 10, 0, 17, 22, 10, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 31, 48, 0, 470, 1, 36, 5, 2, 4, 6, 1, 5, 85, 3, 1, 3, 2, 2, 89, 2, 3, 6, 40, 4, 93, 18, 23, 57, 15, 513, 6581, 75, 20939, 53, 1164, 68, 45, 3, 268, 4, 27, 21, 31, 3, 13, 13, 1, 2, 24, 9, 69, 11, 1, 38, 8, 3, 102, 3, 1, 111, 44, 25, 51, 13, 68, 12, 9, 7, 23, 4, 0, 5, 45, 3, 35, 13, 28, 4, 64, 15, 10, 39, 54, 10, 13, 3, 9, 7, 22, 4, 1, 5, 66, 25, 2, 227, 42, 2, 1, 3, 9, 7, 11171, 13, 22, 5, 48, 8453, 301, 3, 61, 3, 105, 39, 6, 13, 4, 6, 11, 2, 12, 2, 4, 2, 0, 2, 1, 2, 1, 2, 107, 34, 362, 19, 63, 3, 53, 41, 11, 5, 15, 17, 6, 13, 1, 25, 2, 33, 4, 2, 134, 20, 9, 8, 25, 5, 0, 2, 25, 12, 88, 4, 5, 3, 5, 3, 5, 3, 2];
    var code = 0;
    var str = [];
    for (var i = 0; i < wordChars.length; i += 2) {
      str.push(code += wordChars[i]);
      if (wordChars[i + 1])
        str.push(45, code += wordChars[i + 1]);
    }
    exports2.wordChars = String.fromCharCode.apply(null, str);
  });
  ace.define("ace/mode/text", ["require", "exports", "module", "ace/config", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour/cstyle", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function(require2, exports2, module2) {
    var config = require2("../config");
    var Tokenizer = require2("../tokenizer").Tokenizer;
    var TextHighlightRules = require2("./text_highlight_rules").TextHighlightRules;
    var CstyleBehaviour = require2("./behaviour/cstyle").CstyleBehaviour;
    var unicode = require2("../unicode");
    var lang = require2("../lib/lang");
    var TokenIterator = require2("../token_iterator").TokenIterator;
    var Range = require2("../range").Range;
    var Mode;
    Mode = function() {
      this.HighlightRules = TextHighlightRules;
    };
    (function() {
      this.$defaultBehaviour = new CstyleBehaviour();
      this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");
      this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");
      this.getTokenizer = function() {
        if (!this.$tokenizer) {
          this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
          this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
        }
        return this.$tokenizer;
      };
      this.lineCommentStart = "";
      this.blockComment = "";
      this.toggleCommentLines = function(state, session, startRow, endRow) {
        var doc = session.doc;
        var ignoreBlankLines = true;
        var shouldRemove = true;
        var minIndent = Infinity;
        var tabSize = session.getTabSize();
        var insertAtTabStop = false;
        if (!this.lineCommentStart) {
          if (!this.blockComment)
            return false;
          var lineCommentStart = this.blockComment.start;
          var lineCommentEnd = this.blockComment.end;
          var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
          var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
          var comment = function(line, i) {
            if (testRemove(line, i))
              return;
            if (!ignoreBlankLines || /\S/.test(line)) {
              doc.insertInLine({ row: i, column: line.length }, lineCommentEnd);
              doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
            }
          };
          var uncomment = function(line, i) {
            var m;
            if (m = line.match(regexpEnd))
              doc.removeInLine(i, line.length - m[0].length, line.length);
            if (m = line.match(regexpStart))
              doc.removeInLine(i, m[1].length, m[0].length);
          };
          var testRemove = function(line, row) {
            if (regexpStart.test(line))
              return true;
            var tokens = session.getTokens(row);
            for (var i = 0; i < tokens.length; i++) {
              if (tokens[i].type === "comment")
                return true;
            }
          };
        } else {
          if (Array.isArray(this.lineCommentStart)) {
            var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
            var lineCommentStart = this.lineCommentStart[0];
          } else {
            var regexpStart = lang.escapeRegExp(this.lineCommentStart);
            var lineCommentStart = this.lineCommentStart;
          }
          regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
          insertAtTabStop = session.getUseSoftTabs();
          var uncomment = function(line, i) {
            var m = line.match(regexpStart);
            if (!m)
              return;
            var start = m[1].length, end = m[0].length;
            if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
              end--;
            doc.removeInLine(i, start, end);
          };
          var commentWithSpace = lineCommentStart + " ";
          var comment = function(line, i) {
            if (!ignoreBlankLines || /\S/.test(line)) {
              if (shouldInsertSpace(line, minIndent, minIndent))
                doc.insertInLine({ row: i, column: minIndent }, commentWithSpace);
              else
                doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
            }
          };
          var testRemove = function(line, i) {
            return regexpStart.test(line);
          };
          var shouldInsertSpace = function(line, before, after) {
            var spaces = 0;
            while (before-- && line.charAt(before) == " ")
              spaces++;
            if (spaces % tabSize != 0)
              return false;
            var spaces = 0;
            while (line.charAt(after++) == " ")
              spaces++;
            if (tabSize > 2)
              return spaces % tabSize != tabSize - 1;
            else
              return spaces % tabSize == 0;
          };
        }
        function iter(fun) {
          for (var i = startRow; i <= endRow; i++)
            fun(doc.getLine(i), i);
        }
        var minEmptyLength = Infinity;
        iter(function(line, i) {
          var indent = line.search(/\S/);
          if (indent !== -1) {
            if (indent < minIndent)
              minIndent = indent;
            if (shouldRemove && !testRemove(line, i))
              shouldRemove = false;
          } else if (minEmptyLength > line.length) {
            minEmptyLength = line.length;
          }
        });
        if (minIndent == Infinity) {
          minIndent = minEmptyLength;
          ignoreBlankLines = false;
          shouldRemove = false;
        }
        if (insertAtTabStop && minIndent % tabSize != 0)
          minIndent = Math.floor(minIndent / tabSize) * tabSize;
        iter(shouldRemove ? uncomment : comment);
      };
      this.toggleBlockComment = function(state, session, range, cursor) {
        var comment = this.blockComment;
        if (!comment)
          return;
        if (!comment.start && comment[0])
          comment = comment[0];
        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        var token = iterator.getCurrentToken();
        session.selection;
        var initialRange = session.selection.toOrientedRange();
        var startRow, colDiff;
        if (token && /comment/.test(token.type)) {
          var startRange, endRange;
          while (token && /comment/.test(token.type)) {
            var i = token.value.indexOf(comment.start);
            if (i != -1) {
              var row = iterator.getCurrentTokenRow();
              var column = iterator.getCurrentTokenColumn() + i;
              startRange = new Range(row, column, row, column + comment.start.length);
              break;
            }
            token = iterator.stepBackward();
          }
          var iterator = new TokenIterator(session, cursor.row, cursor.column);
          var token = iterator.getCurrentToken();
          while (token && /comment/.test(token.type)) {
            var i = token.value.indexOf(comment.end);
            if (i != -1) {
              var row = iterator.getCurrentTokenRow();
              var column = iterator.getCurrentTokenColumn() + i;
              endRange = new Range(row, column, row, column + comment.end.length);
              break;
            }
            token = iterator.stepForward();
          }
          if (endRange)
            session.remove(endRange);
          if (startRange) {
            session.remove(startRange);
            startRow = startRange.start.row;
            colDiff = -comment.start.length;
          }
        } else {
          colDiff = comment.start.length;
          startRow = range.start.row;
          session.insert(range.end, comment.end);
          session.insert(range.start, comment.start);
        }
        if (initialRange.start.row == startRow)
          initialRange.start.column += colDiff;
        if (initialRange.end.row == startRow)
          initialRange.end.column += colDiff;
        session.selection.fromOrientedRange(initialRange);
      };
      this.getNextLineIndent = function(state, line, tab2) {
        return this.$getIndent(line);
      };
      this.checkOutdent = function(state, line, input) {
        return false;
      };
      this.autoOutdent = function(state, doc, row) {
      };
      this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
      };
      this.createWorker = function(session) {
        return null;
      };
      this.createModeDelegates = function(mapping) {
        this.$embeds = [];
        this.$modes = {};
        for (var i in mapping) {
          if (mapping[i]) {
            var Mode2 = mapping[i];
            var id2 = Mode2.prototype.$id;
            var mode = config.$modes[id2];
            if (!mode)
              config.$modes[id2] = mode = new Mode2();
            if (!config.$modes[i])
              config.$modes[i] = mode;
            this.$embeds.push(i);
            this.$modes[i] = mode;
          }
        }
        var delegations = [
          "toggleBlockComment",
          "toggleCommentLines",
          "getNextLineIndent",
          "checkOutdent",
          "autoOutdent",
          "transformAction",
          "getCompletions"
        ];
        var _loop_1 = function(i2) {
          (function(scope) {
            var functionName = delegations[i2];
            var defaultHandler = scope[functionName];
            scope[delegations[i2]] = function() {
              return this.$delegator(functionName, arguments, defaultHandler);
            };
          })(this_1);
        };
        var this_1 = this;
        for (var i = 0; i < delegations.length; i++) {
          _loop_1(i);
        }
      };
      this.$delegator = function(method, args, defaultHandler) {
        var state = args[0] || "start";
        if (typeof state != "string") {
          if (Array.isArray(state[2])) {
            var language = state[2][state[2].length - 1];
            var mode = this.$modes[language];
            if (mode)
              return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));
          }
          state = state[0] || "start";
        }
        for (var i = 0; i < this.$embeds.length; i++) {
          if (!this.$modes[this.$embeds[i]])
            continue;
          var split = state.split(this.$embeds[i]);
          if (!split[0] && split[1]) {
            args[0] = split[1];
            var mode = this.$modes[this.$embeds[i]];
            return mode[method].apply(mode, args);
          }
        }
        var ret = defaultHandler.apply(this, args);
        return defaultHandler ? ret : void 0;
      };
      this.transformAction = function(state, action, editor2, session, param) {
        if (this.$behaviour) {
          var behaviours = this.$behaviour.getBehaviours();
          for (var key in behaviours) {
            if (behaviours[key][action]) {
              var ret = behaviours[key][action].apply(this, arguments);
              if (ret) {
                return ret;
              }
            }
          }
        }
      };
      this.getKeywords = function(append) {
        if (!this.completionKeywords) {
          var rules = this.$tokenizer["rules"];
          var completionKeywords = [];
          for (var rule in rules) {
            var ruleItr = rules[rule];
            for (var r = 0, l = ruleItr.length; r < l; r++) {
              if (typeof ruleItr[r].token === "string") {
                if (/keyword|support|storage/.test(ruleItr[r].token))
                  completionKeywords.push(ruleItr[r].regex);
              } else if (typeof ruleItr[r].token === "object") {
                for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                  if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                    var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                    completionKeywords.push(rule.substr(1, rule.length - 2));
                  }
                }
              }
            }
          }
          this.completionKeywords = completionKeywords;
        }
        if (!append)
          return this.$keywordList;
        return completionKeywords.concat(this.$keywordList || []);
      };
      this.$createKeywordList = function() {
        if (!this.$highlightRules)
          this.getTokenizer();
        return this.$keywordList = this.$highlightRules.$keywordList || [];
      };
      this.getCompletions = function(state, session, pos, prefix2) {
        var keywords = this.$keywordList || this.$createKeywordList();
        return keywords.map(function(word) {
          return {
            name: word,
            value: word,
            score: 0,
            meta: "keyword"
          };
        });
      };
      this.$id = "ace/mode/text";
    }).call(Mode.prototype);
    exports2.Mode = Mode;
  });
  ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
    var dom = require2("./lib/dom");
    var LineWidgets = (
      /** @class */
      function() {
        function LineWidgets2(session) {
          this.session = session;
          this.session.widgetManager = this;
          this.session.getRowLength = this.getRowLength;
          this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
          this.updateOnChange = this.updateOnChange.bind(this);
          this.renderWidgets = this.renderWidgets.bind(this);
          this.measureWidgets = this.measureWidgets.bind(this);
          this.session._changedWidgets = [];
          this.$onChangeEditor = this.$onChangeEditor.bind(this);
          this.session.on("change", this.updateOnChange);
          this.session.on("changeFold", this.updateOnFold);
          this.session.on("changeEditor", this.$onChangeEditor);
        }
        LineWidgets2.prototype.getRowLength = function(row) {
          var h;
          if (this.lineWidgets)
            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
          else
            h = 0;
          if (!this["$useWrapMode"] || !this["$wrapData"][row]) {
            return 1 + h;
          } else {
            return this["$wrapData"][row].length + 1 + h;
          }
        };
        LineWidgets2.prototype.$getWidgetScreenLength = function() {
          var screenRows = 0;
          this.lineWidgets.forEach(function(w) {
            if (w && w.rowCount && !w.hidden)
              screenRows += w.rowCount;
          });
          return screenRows;
        };
        LineWidgets2.prototype.$onChangeEditor = function(e) {
          this.attach(e.editor);
        };
        LineWidgets2.prototype.attach = function(editor2) {
          if (editor2 && editor2.widgetManager && editor2.widgetManager != this)
            editor2.widgetManager.detach();
          if (this.editor == editor2)
            return;
          this.detach();
          this.editor = editor2;
          if (editor2) {
            editor2.widgetManager = this;
            editor2.renderer.on("beforeRender", this.measureWidgets);
            editor2.renderer.on("afterRender", this.renderWidgets);
          }
        };
        LineWidgets2.prototype.detach = function(e) {
          var editor2 = this.editor;
          if (!editor2)
            return;
          this.editor = null;
          editor2.widgetManager = null;
          editor2.renderer.off("beforeRender", this.measureWidgets);
          editor2.renderer.off("afterRender", this.renderWidgets);
          var lineWidgets = this.session.lineWidgets;
          lineWidgets && lineWidgets.forEach(function(w) {
            if (w && w.el && w.el.parentNode) {
              w._inDocument = false;
              w.el.parentNode.removeChild(w.el);
            }
          });
        };
        LineWidgets2.prototype.updateOnFold = function(e, session) {
          var lineWidgets = session.lineWidgets;
          if (!lineWidgets || !e.action)
            return;
          var fold = e.data;
          var start = fold.start.row;
          var end = fold.end.row;
          var hide = e.action == "add";
          for (var i = start + 1; i < end; i++) {
            if (lineWidgets[i])
              lineWidgets[i].hidden = hide;
          }
          if (lineWidgets[end]) {
            if (hide) {
              if (!lineWidgets[start])
                lineWidgets[start] = lineWidgets[end];
              else
                lineWidgets[end].hidden = hide;
            } else {
              if (lineWidgets[start] == lineWidgets[end])
                lineWidgets[start] = void 0;
              lineWidgets[end].hidden = hide;
            }
          }
        };
        LineWidgets2.prototype.updateOnChange = function(delta) {
          var lineWidgets = this.session.lineWidgets;
          if (!lineWidgets)
            return;
          var startRow = delta.start.row;
          var len = delta.end.row - startRow;
          if (len === 0) ;
          else if (delta.action == "remove") {
            var removed = lineWidgets.splice(startRow + 1, len);
            if (!lineWidgets[startRow] && removed[removed.length - 1]) {
              lineWidgets[startRow] = removed.pop();
            }
            removed.forEach(function(w) {
              w && this.removeLineWidget(w);
            }, this);
            this.$updateRows();
          } else {
            var args = new Array(len);
            if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {
              if (delta.start.column > lineWidgets[startRow].column)
                startRow++;
            }
            args.unshift(startRow, 0);
            lineWidgets.splice.apply(lineWidgets, args);
            this.$updateRows();
          }
        };
        LineWidgets2.prototype.$updateRows = function() {
          var lineWidgets = this.session.lineWidgets;
          if (!lineWidgets)
            return;
          var noWidgets = true;
          lineWidgets.forEach(function(w, i) {
            if (w) {
              noWidgets = false;
              w.row = i;
              while (w.$oldWidget) {
                w.$oldWidget.row = i;
                w = w.$oldWidget;
              }
            }
          });
          if (noWidgets)
            this.session.lineWidgets = null;
        };
        LineWidgets2.prototype.$registerLineWidget = function(w) {
          if (!this.session.lineWidgets)
            this.session.lineWidgets = new Array(this.session.getLength());
          var old = this.session.lineWidgets[w.row];
          if (old) {
            w.$oldWidget = old;
            if (old.el && old.el.parentNode) {
              old.el.parentNode.removeChild(old.el);
              old._inDocument = false;
            }
          }
          this.session.lineWidgets[w.row] = w;
          return w;
        };
        LineWidgets2.prototype.addLineWidget = function(w) {
          this.$registerLineWidget(w);
          w.session = this.session;
          if (!this.editor)
            return w;
          var renderer = this.editor.renderer;
          if (w.html && !w.el) {
            w.el = dom.createElement("div");
            w.el.innerHTML = w.html;
          }
          if (w.text && !w.el) {
            w.el = dom.createElement("div");
            w.el.textContent = w.text;
          }
          if (w.el) {
            dom.addCssClass(w.el, "ace_lineWidgetContainer");
            if (w.className) {
              dom.addCssClass(w.el, w.className);
            }
            w.el.style.position = "absolute";
            w.el.style.zIndex = "5";
            renderer.container.appendChild(w.el);
            w._inDocument = true;
            if (!w.coverGutter) {
              w.el.style.zIndex = "3";
            }
            if (w.pixelHeight == null) {
              w.pixelHeight = w.el.offsetHeight;
            }
          }
          if (w.rowCount == null) {
            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
          }
          var fold = this.session.getFoldAt(w.row, 0);
          w.$fold = fold;
          if (fold) {
            var lineWidgets = this.session.lineWidgets;
            if (w.row == fold.end.row && !lineWidgets[fold.start.row])
              lineWidgets[fold.start.row] = w;
            else
              w.hidden = true;
          }
          this.session._emit("changeFold", { data: { start: { row: w.row } } });
          this.$updateRows();
          this.renderWidgets(null, renderer);
          this.onWidgetChanged(w);
          return w;
        };
        LineWidgets2.prototype.removeLineWidget = function(w) {
          w._inDocument = false;
          w.session = null;
          if (w.el && w.el.parentNode)
            w.el.parentNode.removeChild(w.el);
          if (w.editor && w.editor.destroy)
            try {
              w.editor.destroy();
            } catch (e) {
            }
          if (this.session.lineWidgets) {
            var w1 = this.session.lineWidgets[w.row];
            if (w1 == w) {
              this.session.lineWidgets[w.row] = w.$oldWidget;
              if (w.$oldWidget)
                this.onWidgetChanged(w.$oldWidget);
            } else {
              while (w1) {
                if (w1.$oldWidget == w) {
                  w1.$oldWidget = w.$oldWidget;
                  break;
                }
                w1 = w1.$oldWidget;
              }
            }
          }
          this.session._emit("changeFold", { data: { start: { row: w.row } } });
          this.$updateRows();
        };
        LineWidgets2.prototype.getWidgetsAtRow = function(row) {
          var lineWidgets = this.session.lineWidgets;
          var w = lineWidgets && lineWidgets[row];
          var list2 = [];
          while (w) {
            list2.push(w);
            w = w.$oldWidget;
          }
          return list2;
        };
        LineWidgets2.prototype.onWidgetChanged = function(w) {
          this.session._changedWidgets.push(w);
          this.editor && this.editor.renderer.updateFull();
        };
        LineWidgets2.prototype.measureWidgets = function(e, renderer) {
          var changedWidgets = this.session._changedWidgets;
          var config = renderer.layerConfig;
          if (!changedWidgets || !changedWidgets.length)
            return;
          var min = Infinity;
          for (var i = 0; i < changedWidgets.length; i++) {
            var w = changedWidgets[i];
            if (!w || !w.el)
              continue;
            if (w.session != this.session)
              continue;
            if (!w._inDocument) {
              if (this.session.lineWidgets[w.row] != w)
                continue;
              w._inDocument = true;
              renderer.container.appendChild(w.el);
            }
            w.h = w.el.offsetHeight;
            if (!w.fixedWidth) {
              w.w = w.el.offsetWidth;
              w.screenWidth = Math.ceil(w.w / config.characterWidth);
            }
            var rowCount = w.h / config.lineHeight;
            if (w.coverLine) {
              rowCount -= this.session.getRowLineCount(w.row);
              if (rowCount < 0)
                rowCount = 0;
            }
            if (w.rowCount != rowCount) {
              w.rowCount = rowCount;
              if (w.row < min)
                min = w.row;
            }
          }
          if (min != Infinity) {
            this.session._emit("changeFold", { data: { start: { row: min } } });
            this.session.lineWidgetWidth = null;
          }
          this.session._changedWidgets = [];
        };
        LineWidgets2.prototype.renderWidgets = function(e, renderer) {
          var config = renderer.layerConfig;
          var lineWidgets = this.session.lineWidgets;
          if (!lineWidgets)
            return;
          var first = Math.min(this.firstRow, config.firstRow);
          var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
          while (first > 0 && !lineWidgets[first])
            first--;
          this.firstRow = config.firstRow;
          this.lastRow = config.lastRow;
          renderer.$cursorLayer.config = config;
          for (var i = first; i <= last; i++) {
            var w = lineWidgets[i];
            if (!w || !w.el)
              continue;
            if (w.hidden) {
              w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
              continue;
            }
            if (!w._inDocument) {
              w._inDocument = true;
              renderer.container.appendChild(w.el);
            }
            var top = renderer.$cursorLayer.getPixelPosition({ row: i, column: 0 }, true).top;
            if (!w.coverLine)
              top += config.lineHeight * this.session.getRowLineCount(w.row);
            w.el.style.top = top - config.offset + "px";
            var left = w.coverGutter ? 0 : renderer.gutterWidth;
            if (!w.fixedWidth)
              left -= renderer.scrollLeft;
            w.el.style.left = left + "px";
            if (w.fullWidth && w.screenWidth) {
              w.el.style.minWidth = config.width + 2 * config.padding + "px";
            }
            if (w.fixedWidth) {
              w.el.style.right = renderer.scrollBar.getWidth() + "px";
            } else {
              w.el.style.right = "";
            }
          }
        };
        return LineWidgets2;
      }()
    );
    exports2.LineWidgets = LineWidgets;
  });
  ace.define("ace/apply_delta", ["require", "exports", "module"], function(require2, exports2, module2) {
    exports2.applyDelta = function(docLines, delta, doNotValidate) {
      var row = delta.start.row;
      var startColumn = delta.start.column;
      var line = docLines[row] || "";
      switch (delta.action) {
        case "insert":
          var lines = delta.lines;
          if (lines.length === 1) {
            docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
          } else {
            var args = [row, 1].concat(delta.lines);
            docLines.splice.apply(docLines, args);
            docLines[row] = line.substring(0, startColumn) + docLines[row];
            docLines[row + delta.lines.length - 1] += line.substring(startColumn);
          }
          break;
        case "remove":
          var endColumn = delta.end.column;
          var endRow = delta.end.row;
          if (row === endRow) {
            docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
          } else {
            docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
          }
          break;
      }
    };
  });
  ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports2, module2) {
    var oop = require2("./lib/oop");
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var Anchor = (
      /** @class */
      function() {
        function Anchor2(doc, row, column) {
          this.$onChange = this.onChange.bind(this);
          this.attach(doc);
          if (typeof row != "number")
            this.setPosition(row.row, row.column);
          else
            this.setPosition(row, column);
        }
        Anchor2.prototype.getPosition = function() {
          return this.$clipPositionToDocument(this.row, this.column);
        };
        Anchor2.prototype.getDocument = function() {
          return this.document;
        };
        Anchor2.prototype.onChange = function(delta) {
          if (delta.start.row == delta.end.row && delta.start.row != this.row)
            return;
          if (delta.start.row > this.row)
            return;
          var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
          this.setPosition(point.row, point.column, true);
        };
        Anchor2.prototype.setPosition = function(row, column, noClip) {
          var pos;
          if (noClip) {
            pos = {
              row,
              column
            };
          } else {
            pos = this.$clipPositionToDocument(row, column);
          }
          if (this.row == pos.row && this.column == pos.column)
            return;
          var old = {
            row: this.row,
            column: this.column
          };
          this.row = pos.row;
          this.column = pos.column;
          this._signal("change", {
            old,
            value: pos
          });
        };
        Anchor2.prototype.detach = function() {
          this.document.off("change", this.$onChange);
        };
        Anchor2.prototype.attach = function(doc) {
          this.document = doc || this.document;
          this.document.on("change", this.$onChange);
        };
        Anchor2.prototype.$clipPositionToDocument = function(row, column) {
          var pos = {};
          if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
          } else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
          } else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
          }
          if (column < 0)
            pos.column = 0;
          return pos;
        };
        return Anchor2;
      }()
    );
    Anchor.prototype.$insertRight = false;
    oop.implement(Anchor.prototype, EventEmitter);
    function $pointsInOrder(point1, point2, equalPointsInOrder) {
      var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
      return point1.row < point2.row || point1.row == point2.row && bColIsAfter;
    }
    function $getTransformedPoint(delta, point, moveIfEqual) {
      var deltaIsInsert = delta.action == "insert";
      var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
      var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
      var deltaStart = delta.start;
      var deltaEnd = deltaIsInsert ? deltaStart : delta.end;
      if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
        return {
          row: point.row,
          column: point.column
        };
      }
      if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
        return {
          row: point.row + deltaRowShift,
          column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
        };
      }
      return {
        row: deltaStart.row,
        column: deltaStart.column
      };
    }
    exports2.Anchor = Anchor;
  });
  ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function(require2, exports2, module2) {
    var oop = require2("./lib/oop");
    var applyDelta = require2("./apply_delta").applyDelta;
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var Range = require2("./range").Range;
    var Anchor = require2("./anchor").Anchor;
    var Document = (
      /** @class */
      function() {
        function Document2(textOrLines) {
          this.$lines = [""];
          if (textOrLines.length === 0) {
            this.$lines = [""];
          } else if (Array.isArray(textOrLines)) {
            this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
          } else {
            this.insert({ row: 0, column: 0 }, textOrLines);
          }
        }
        Document2.prototype.setValue = function(text) {
          var len = this.getLength() - 1;
          this.remove(new Range(0, 0, len, this.getLine(len).length));
          this.insert({ row: 0, column: 0 }, text || "");
        };
        Document2.prototype.getValue = function() {
          return this.getAllLines().join(this.getNewLineCharacter());
        };
        Document2.prototype.createAnchor = function(row, column) {
          return new Anchor(this, row, column);
        };
        Document2.prototype.$detectNewLine = function(text) {
          var match = text.match(/^.*?(\r\n|\r|\n)/m);
          this.$autoNewLine = match ? match[1] : "\n";
          this._signal("changeNewLineMode");
        };
        Document2.prototype.getNewLineCharacter = function() {
          switch (this.$newLineMode) {
            case "windows":
              return "\r\n";
            case "unix":
              return "\n";
            default:
              return this.$autoNewLine || "\n";
          }
        };
        Document2.prototype.setNewLineMode = function(newLineMode) {
          if (this.$newLineMode === newLineMode)
            return;
          this.$newLineMode = newLineMode;
          this._signal("changeNewLineMode");
        };
        Document2.prototype.getNewLineMode = function() {
          return this.$newLineMode;
        };
        Document2.prototype.isNewLine = function(text) {
          return text == "\r\n" || text == "\r" || text == "\n";
        };
        Document2.prototype.getLine = function(row) {
          return this.$lines[row] || "";
        };
        Document2.prototype.getLines = function(firstRow, lastRow) {
          return this.$lines.slice(firstRow, lastRow + 1);
        };
        Document2.prototype.getAllLines = function() {
          return this.getLines(0, this.getLength());
        };
        Document2.prototype.getLength = function() {
          return this.$lines.length;
        };
        Document2.prototype.getTextRange = function(range) {
          return this.getLinesForRange(range).join(this.getNewLineCharacter());
        };
        Document2.prototype.getLinesForRange = function(range) {
          var lines;
          if (range.start.row === range.end.row) {
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
          } else {
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || "").substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l)
              lines[l] = lines[l].substring(0, range.end.column);
          }
          return lines;
        };
        Document2.prototype.insertLines = function(row, lines) {
          console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
          return this.insertFullLines(row, lines);
        };
        Document2.prototype.removeLines = function(firstRow, lastRow) {
          console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
          return this.removeFullLines(firstRow, lastRow);
        };
        Document2.prototype.insertNewLine = function(position) {
          console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
          return this.insertMergedLines(position, ["", ""]);
        };
        Document2.prototype.insert = function(position, text) {
          if (this.getLength() <= 1)
            this.$detectNewLine(text);
          return this.insertMergedLines(position, this.$split(text));
        };
        Document2.prototype.insertInLine = function(position, text) {
          var start = this.clippedPos(position.row, position.column);
          var end = this.pos(position.row, position.column + text.length);
          this.applyDelta({
            start,
            end,
            action: "insert",
            lines: [text]
          }, true);
          return this.clonePos(end);
        };
        Document2.prototype.clippedPos = function(row, column) {
          var length = this.getLength();
          if (row === void 0) {
            row = length;
          } else if (row < 0) {
            row = 0;
          } else if (row >= length) {
            row = length - 1;
            column = void 0;
          }
          var line = this.getLine(row);
          if (column == void 0)
            column = line.length;
          column = Math.min(Math.max(column, 0), line.length);
          return { row, column };
        };
        Document2.prototype.clonePos = function(pos) {
          return { row: pos.row, column: pos.column };
        };
        Document2.prototype.pos = function(row, column) {
          return { row, column };
        };
        Document2.prototype.$clipPosition = function(position) {
          var length = this.getLength();
          if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
          } else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
          }
          return position;
        };
        Document2.prototype.insertFullLines = function(row, lines) {
          row = Math.min(Math.max(row, 0), this.getLength());
          var column = 0;
          if (row < this.getLength()) {
            lines = lines.concat([""]);
            column = 0;
          } else {
            lines = [""].concat(lines);
            row--;
            column = this.$lines[row].length;
          }
          this.insertMergedLines({ row, column }, lines);
        };
        Document2.prototype.insertMergedLines = function(position, lines) {
          var start = this.clippedPos(position.row, position.column);
          var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
          };
          this.applyDelta({
            start,
            end,
            action: "insert",
            lines
          });
          return this.clonePos(end);
        };
        Document2.prototype.remove = function(range) {
          var start = this.clippedPos(range.start.row, range.start.column);
          var end = this.clippedPos(range.end.row, range.end.column);
          this.applyDelta({
            start,
            end,
            action: "remove",
            lines: this.getLinesForRange({ start, end })
          });
          return this.clonePos(start);
        };
        Document2.prototype.removeInLine = function(row, startColumn, endColumn) {
          var start = this.clippedPos(row, startColumn);
          var end = this.clippedPos(row, endColumn);
          this.applyDelta({
            start,
            end,
            action: "remove",
            lines: this.getLinesForRange({ start, end })
          }, true);
          return this.clonePos(start);
        };
        Document2.prototype.removeFullLines = function(firstRow, lastRow) {
          firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
          lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
          var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
          var deleteLastNewLine = lastRow < this.getLength() - 1;
          var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;
          var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;
          var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;
          var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;
          var range = new Range(startRow, startCol, endRow, endCol);
          var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
          this.applyDelta({
            start: range.start,
            end: range.end,
            action: "remove",
            lines: this.getLinesForRange(range)
          });
          return deletedLines;
        };
        Document2.prototype.removeNewLine = function(row) {
          if (row < this.getLength() - 1 && row >= 0) {
            this.applyDelta({
              start: this.pos(row, this.getLine(row).length),
              end: this.pos(row + 1, 0),
              action: "remove",
              lines: ["", ""]
            });
          }
        };
        Document2.prototype.replace = function(range, text) {
          if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
          if (text.length === 0 && range.isEmpty())
            return range.start;
          if (text == this.getTextRange(range))
            return range.end;
          this.remove(range);
          var end;
          if (text) {
            end = this.insert(range.start, text);
          } else {
            end = range.start;
          }
          return end;
        };
        Document2.prototype.applyDeltas = function(deltas) {
          for (var i = 0; i < deltas.length; i++) {
            this.applyDelta(deltas[i]);
          }
        };
        Document2.prototype.revertDeltas = function(deltas) {
          for (var i = deltas.length - 1; i >= 0; i--) {
            this.revertDelta(deltas[i]);
          }
        };
        Document2.prototype.applyDelta = function(delta, doNotValidate) {
          var isInsert = delta.action == "insert";
          if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {
            return;
          }
          if (isInsert && delta.lines.length > 2e4) {
            this.$splitAndapplyLargeDelta(delta, 2e4);
          } else {
            applyDelta(this.$lines, delta, doNotValidate);
            this._signal("change", delta);
          }
        };
        Document2.prototype.$safeApplyDelta = function(delta) {
          var docLength = this.$lines.length;
          if (delta.action == "remove" && delta.start.row < docLength && delta.end.row < docLength || delta.action == "insert" && delta.start.row <= docLength) {
            this.applyDelta(delta);
          }
        };
        Document2.prototype.$splitAndapplyLargeDelta = function(delta, MAX) {
          var lines = delta.lines;
          var l = lines.length - MAX + 1;
          var row = delta.start.row;
          var column = delta.start.column;
          for (var from = 0, to = 0; from < l; from = to) {
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            chunk.push("");
            this.applyDelta({
              start: this.pos(row + from, column),
              end: this.pos(row + to, column = 0),
              action: delta.action,
              lines: chunk
            }, true);
          }
          delta.lines = lines.slice(from);
          delta.start.row = row + from;
          delta.start.column = column;
          this.applyDelta(delta, true);
        };
        Document2.prototype.revertDelta = function(delta) {
          this.$safeApplyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: delta.action == "insert" ? "remove" : "insert",
            lines: delta.lines.slice()
          });
        };
        Document2.prototype.indexToPosition = function(index2, startRow) {
          var lines = this.$lines || this.getAllLines();
          var newlineLength = this.getNewLineCharacter().length;
          for (var i = startRow || 0, l = lines.length; i < l; i++) {
            index2 -= lines[i].length + newlineLength;
            if (index2 < 0)
              return { row: i, column: index2 + lines[i].length + newlineLength };
          }
          return { row: l - 1, column: index2 + lines[l - 1].length + newlineLength };
        };
        Document2.prototype.positionToIndex = function(pos, startRow) {
          var lines = this.$lines || this.getAllLines();
          var newlineLength = this.getNewLineCharacter().length;
          var index2 = 0;
          var row = Math.min(pos.row, lines.length);
          for (var i = startRow || 0; i < row; ++i)
            index2 += lines[i].length + newlineLength;
          return index2 + pos.column;
        };
        Document2.prototype.$split = function(text) {
          return text.split(/\r\n|\r|\n/);
        };
        return Document2;
      }()
    );
    Document.prototype.$autoNewLine = "";
    Document.prototype.$newLineMode = "auto";
    oop.implement(Document.prototype, EventEmitter);
    exports2.Document = Document;
  });
  ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports2, module2) {
    var oop = require2("./lib/oop");
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var BackgroundTokenizer = (
      /** @class */
      function() {
        function BackgroundTokenizer2(tokenizer, session) {
          this.running = false;
          this.lines = [];
          this.states = [];
          this.currentLine = 0;
          this.tokenizer = tokenizer;
          var self2 = this;
          this.$worker = function() {
            if (!self2.running) {
              return;
            }
            var workerStart = /* @__PURE__ */ new Date();
            var currentLine = self2.currentLine;
            var endLine = -1;
            var doc = self2.doc;
            var startLine = currentLine;
            while (self2.lines[currentLine])
              currentLine++;
            var len = doc.getLength();
            var processedLines = 0;
            self2.running = false;
            while (currentLine < len) {
              self2.$tokenizeRow(currentLine);
              endLine = currentLine;
              do {
                currentLine++;
              } while (self2.lines[currentLine]);
              processedLines++;
              if (processedLines % 5 === 0 && /* @__PURE__ */ new Date() - workerStart > 20) {
                self2.running = setTimeout(self2.$worker, 20);
                break;
              }
            }
            self2.currentLine = currentLine;
            if (endLine == -1)
              endLine = currentLine;
            if (startLine <= endLine)
              self2.fireUpdateEvent(startLine, endLine);
          };
        }
        BackgroundTokenizer2.prototype.setTokenizer = function(tokenizer) {
          this.tokenizer = tokenizer;
          this.lines = [];
          this.states = [];
          this.start(0);
        };
        BackgroundTokenizer2.prototype.setDocument = function(doc) {
          this.doc = doc;
          this.lines = [];
          this.states = [];
          this.stop();
        };
        BackgroundTokenizer2.prototype.fireUpdateEvent = function(firstRow, lastRow) {
          var data = {
            first: firstRow,
            last: lastRow
          };
          this._signal("update", { data });
        };
        BackgroundTokenizer2.prototype.start = function(startRow) {
          this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
          this.lines.splice(this.currentLine, this.lines.length);
          this.states.splice(this.currentLine, this.states.length);
          this.stop();
          this.running = setTimeout(this.$worker, 700);
        };
        BackgroundTokenizer2.prototype.scheduleStart = function() {
          if (!this.running)
            this.running = setTimeout(this.$worker, 700);
        };
        BackgroundTokenizer2.prototype.$updateOnChange = function(delta) {
          var startRow = delta.start.row;
          var len = delta.end.row - startRow;
          if (len === 0) {
            this.lines[startRow] = null;
          } else if (delta.action == "remove") {
            this.lines.splice(startRow, len + 1, null);
            this.states.splice(startRow, len + 1, null);
          } else {
            var args = Array(len + 1);
            args.unshift(startRow, 1);
            this.lines.splice.apply(this.lines, args);
            this.states.splice.apply(this.states, args);
          }
          this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
          this.stop();
        };
        BackgroundTokenizer2.prototype.stop = function() {
          if (this.running)
            clearTimeout(this.running);
          this.running = false;
        };
        BackgroundTokenizer2.prototype.getTokens = function(row) {
          return this.lines[row] || this.$tokenizeRow(row);
        };
        BackgroundTokenizer2.prototype.getState = function(row) {
          if (this.currentLine == row)
            this.$tokenizeRow(row);
          return this.states[row] || "start";
        };
        BackgroundTokenizer2.prototype.$tokenizeRow = function(row) {
          var line = this.doc.getLine(row);
          var state = this.states[row - 1];
          var data = this.tokenizer.getLineTokens(line, state, row);
          if (this.states[row] + "" !== data.state + "") {
            this.states[row] = data.state;
            this.lines[row + 1] = null;
            if (this.currentLine > row + 1)
              this.currentLine = row + 1;
          } else if (this.currentLine == row) {
            this.currentLine = row + 1;
          }
          return this.lines[row] = data.tokens;
        };
        BackgroundTokenizer2.prototype.cleanup = function() {
          this.running = false;
          this.lines = [];
          this.states = [];
          this.currentLine = 0;
          this.removeAllListeners();
        };
        return BackgroundTokenizer2;
      }()
    );
    oop.implement(BackgroundTokenizer.prototype, EventEmitter);
    exports2.BackgroundTokenizer = BackgroundTokenizer;
  });
  ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/range"], function(require2, exports2, module2) {
    var lang = require2("./lib/lang");
    var Range = require2("./range").Range;
    var SearchHighlight = (
      /** @class */
      function() {
        function SearchHighlight2(regExp, clazz, type) {
          if (type === void 0) {
            type = "text";
          }
          this.setRegexp(regExp);
          this.clazz = clazz;
          this.type = type;
          this.docLen = 0;
        }
        SearchHighlight2.prototype.setRegexp = function(regExp) {
          if (this.regExp + "" == regExp + "")
            return;
          this.regExp = regExp;
          this.cache = [];
        };
        SearchHighlight2.prototype.update = function(html, markerLayer, session, config) {
          if (!this.regExp)
            return;
          var start = config.firstRow;
          var end = config.lastRow;
          var renderedMarkerRanges = {};
          var _search = session.$editor && session.$editor.$search;
          var mtSearch = _search && _search.$isMultilineSearch(session.$editor.getLastSearchOptions());
          for (var i = start; i <= end; i++) {
            var ranges = this.cache[i];
            if (ranges == null || session.getValue().length != this.docLen) {
              if (mtSearch) {
                ranges = [];
                var match = _search.$multiLineForward(session, this.regExp, i, end);
                if (match) {
                  var end_row = match.endRow <= end ? match.endRow - 1 : end;
                  if (end_row > i)
                    i = end_row;
                  ranges.push(new Range(match.startRow, match.startCol, match.endRow, match.endCol));
                }
                if (ranges.length > this.MAX_RANGES)
                  ranges = ranges.slice(0, this.MAX_RANGES);
              } else {
                ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                if (ranges.length > this.MAX_RANGES)
                  ranges = ranges.slice(0, this.MAX_RANGES);
                ranges = ranges.map(function(match2) {
                  return new Range(i, match2.offset, i, match2.offset + match2.length);
                });
              }
              this.cache[i] = ranges.length ? ranges : "";
            }
            if (ranges.length === 0)
              continue;
            for (var j = ranges.length; j--; ) {
              var rangeToAddMarkerTo = ranges[j].toScreenRange(session);
              var rangeAsString = rangeToAddMarkerTo.toString();
              if (renderedMarkerRanges[rangeAsString])
                continue;
              renderedMarkerRanges[rangeAsString] = true;
              markerLayer.drawSingleLineMarker(html, rangeToAddMarkerTo, this.clazz, config);
            }
          }
          this.docLen = session.getValue().length;
        };
        return SearchHighlight2;
      }()
    );
    SearchHighlight.prototype.MAX_RANGES = 500;
    exports2.SearchHighlight = SearchHighlight;
  });
  ace.define("ace/undomanager", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
    var UndoManager = (
      /** @class */
      function() {
        function UndoManager2() {
          this.$keepRedoStack;
          this.$maxRev = 0;
          this.$fromUndo = false;
          this.$undoDepth = Infinity;
          this.reset();
        }
        UndoManager2.prototype.addSession = function(session) {
          this.$session = session;
        };
        UndoManager2.prototype.add = function(delta, allowMerge, session) {
          if (this.$fromUndo)
            return;
          if (delta == this.$lastDelta)
            return;
          if (!this.$keepRedoStack)
            this.$redoStack.length = 0;
          if (allowMerge === false || !this.lastDeltas) {
            this.lastDeltas = [];
            var undoStackLength = this.$undoStack.length;
            if (undoStackLength > this.$undoDepth - 1) {
              this.$undoStack.splice(0, undoStackLength - this.$undoDepth + 1);
            }
            this.$undoStack.push(this.lastDeltas);
            delta.id = this.$rev = ++this.$maxRev;
          }
          if (delta.action == "remove" || delta.action == "insert")
            this.$lastDelta = delta;
          this.lastDeltas.push(delta);
        };
        UndoManager2.prototype.addSelection = function(selection, rev) {
          this.selections.push({
            value: selection,
            rev: rev || this.$rev
          });
        };
        UndoManager2.prototype.startNewGroup = function() {
          this.lastDeltas = null;
          return this.$rev;
        };
        UndoManager2.prototype.markIgnored = function(from, to) {
          if (to == null)
            to = this.$rev + 1;
          var stack = this.$undoStack;
          for (var i = stack.length; i--; ) {
            var delta = stack[i][0];
            if (delta.id <= from)
              break;
            if (delta.id < to)
              delta.ignore = true;
          }
          this.lastDeltas = null;
        };
        UndoManager2.prototype.getSelection = function(rev, after) {
          var stack = this.selections;
          for (var i = stack.length; i--; ) {
            var selection = stack[i];
            if (selection.rev < rev) {
              if (after)
                selection = stack[i + 1];
              return selection;
            }
          }
        };
        UndoManager2.prototype.getRevision = function() {
          return this.$rev;
        };
        UndoManager2.prototype.getDeltas = function(from, to) {
          if (to == null)
            to = this.$rev + 1;
          var stack = this.$undoStack;
          var end = null, start = 0;
          for (var i = stack.length; i--; ) {
            var delta = stack[i][0];
            if (delta.id < to && !end)
              end = i + 1;
            if (delta.id <= from) {
              start = i + 1;
              break;
            }
          }
          return stack.slice(start, end);
        };
        UndoManager2.prototype.getChangedRanges = function(from, to) {
          if (to == null)
            to = this.$rev + 1;
        };
        UndoManager2.prototype.getChangedLines = function(from, to) {
          if (to == null)
            to = this.$rev + 1;
        };
        UndoManager2.prototype.undo = function(session, dontSelect) {
          this.lastDeltas = null;
          var stack = this.$undoStack;
          if (!rearrangeUndoStack(stack, stack.length))
            return;
          if (!session)
            session = this.$session;
          if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)
            this.$redoStack = [];
          this.$fromUndo = true;
          var deltaSet = stack.pop();
          var undoSelectionRange = null;
          if (deltaSet) {
            undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
            this.$redoStack.push(deltaSet);
            this.$syncRev();
          }
          this.$fromUndo = false;
          return undoSelectionRange;
        };
        UndoManager2.prototype.redo = function(session, dontSelect) {
          this.lastDeltas = null;
          if (!session)
            session = this.$session;
          this.$fromUndo = true;
          if (this.$redoStackBaseRev != this.$rev) {
            var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
            rebaseRedoStack(this.$redoStack, diff);
            this.$redoStackBaseRev = this.$rev;
            this.$redoStack.forEach(function(x) {
              x[0].id = ++this.$maxRev;
            }, this);
          }
          var deltaSet = this.$redoStack.pop();
          var redoSelectionRange = null;
          if (deltaSet) {
            redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
            this.$undoStack.push(deltaSet);
            this.$syncRev();
          }
          this.$fromUndo = false;
          return redoSelectionRange;
        };
        UndoManager2.prototype.$syncRev = function() {
          var stack = this.$undoStack;
          var nextDelta = stack[stack.length - 1];
          var id2 = nextDelta && nextDelta[0].id || 0;
          this.$redoStackBaseRev = id2;
          this.$rev = id2;
        };
        UndoManager2.prototype.reset = function() {
          this.lastDeltas = null;
          this.$lastDelta = null;
          this.$undoStack = [];
          this.$redoStack = [];
          this.$rev = 0;
          this.mark = 0;
          this.$redoStackBaseRev = this.$rev;
          this.selections = [];
        };
        UndoManager2.prototype.canUndo = function() {
          return this.$undoStack.length > 0;
        };
        UndoManager2.prototype.canRedo = function() {
          return this.$redoStack.length > 0;
        };
        UndoManager2.prototype.bookmark = function(rev) {
          if (rev == void 0)
            rev = this.$rev;
          this.mark = rev;
        };
        UndoManager2.prototype.isAtBookmark = function() {
          return this.$rev === this.mark;
        };
        UndoManager2.prototype.toJSON = function() {
          return {
            $redoStack: this.$redoStack,
            $undoStack: this.$undoStack
          };
        };
        UndoManager2.prototype.fromJSON = function(json) {
          this.reset();
          this.$undoStack = json.$undoStack;
          this.$redoStack = json.$redoStack;
        };
        UndoManager2.prototype.$prettyPrint = function(delta) {
          if (delta)
            return stringifyDelta(delta);
          return stringifyDelta(this.$undoStack) + "\n---\n" + stringifyDelta(this.$redoStack);
        };
        return UndoManager2;
      }()
    );
    UndoManager.prototype.hasUndo = UndoManager.prototype.canUndo;
    UndoManager.prototype.hasRedo = UndoManager.prototype.canRedo;
    UndoManager.prototype.isClean = UndoManager.prototype.isAtBookmark;
    UndoManager.prototype.markClean = UndoManager.prototype.bookmark;
    function rearrangeUndoStack(stack, pos) {
      for (var i = pos; i--; ) {
        var deltaSet = stack[i];
        if (deltaSet && !deltaSet[0].ignore) {
          while (i < pos - 1) {
            var swapped = swapGroups(stack[i], stack[i + 1]);
            stack[i] = swapped[0];
            stack[i + 1] = swapped[1];
            i++;
          }
          return true;
        }
      }
    }
    var Range = require2("./range").Range;
    var cmp = Range.comparePoints;
    Range.comparePoints;
    function clonePos(pos) {
      return { row: pos.row, column: pos.column };
    }
    function cloneDelta(d) {
      return {
        start: clonePos(d.start),
        end: clonePos(d.end),
        action: d.action,
        lines: d.lines.slice()
      };
    }
    function stringifyDelta(d) {
      d = d || this;
      if (Array.isArray(d)) {
        return d.map(stringifyDelta).join("\n");
      }
      var type = "";
      if (d.action) {
        type = d.action == "insert" ? "+" : "-";
        type += "[" + d.lines + "]";
      } else if (d.value) {
        if (Array.isArray(d.value)) {
          type = d.value.map(stringifyRange).join("\n");
        } else {
          type = stringifyRange(d.value);
        }
      }
      if (d.start) {
        type += stringifyRange(d);
      }
      if (d.id || d.rev) {
        type += "	(" + (d.id || d.rev) + ")";
      }
      return type;
    }
    function stringifyRange(r) {
      return r.start.row + ":" + r.start.column + "=>" + r.end.row + ":" + r.end.column;
    }
    function swap(d1, d2) {
      var i1 = d1.action == "insert";
      var i2 = d2.action == "insert";
      if (i1 && i2) {
        if (cmp(d2.start, d1.end) >= 0) {
          shift(d2, d1, -1);
        } else if (cmp(d2.start, d1.start) <= 0) {
          shift(d1, d2, 1);
        } else {
          return null;
        }
      } else if (i1 && !i2) {
        if (cmp(d2.start, d1.end) >= 0) {
          shift(d2, d1, -1);
        } else if (cmp(d2.end, d1.start) <= 0) {
          shift(d1, d2, -1);
        } else {
          return null;
        }
      } else if (!i1 && i2) {
        if (cmp(d2.start, d1.start) >= 0) {
          shift(d2, d1, 1);
        } else if (cmp(d2.start, d1.start) <= 0) {
          shift(d1, d2, 1);
        } else {
          return null;
        }
      } else if (!i1 && !i2) {
        if (cmp(d2.start, d1.start) >= 0) {
          shift(d2, d1, 1);
        } else if (cmp(d2.end, d1.start) <= 0) {
          shift(d1, d2, -1);
        } else {
          return null;
        }
      }
      return [d2, d1];
    }
    function swapGroups(ds1, ds2) {
      for (var i = ds1.length; i--; ) {
        for (var j = 0; j < ds2.length; j++) {
          if (!swap(ds1[i], ds2[j])) {
            while (i < ds1.length) {
              while (j--) {
                swap(ds2[j], ds1[i]);
              }
              j = ds2.length;
              i++;
            }
            return [ds1, ds2];
          }
        }
      }
      ds1.selectionBefore = ds2.selectionBefore = ds1.selectionAfter = ds2.selectionAfter = null;
      return [ds2, ds1];
    }
    function xform(d1, c1) {
      var i1 = d1.action == "insert";
      var i2 = c1.action == "insert";
      if (i1 && i2) {
        if (cmp(d1.start, c1.start) < 0) {
          shift(c1, d1, 1);
        } else {
          shift(d1, c1, 1);
        }
      } else if (i1 && !i2) {
        if (cmp(d1.start, c1.end) >= 0) {
          shift(d1, c1, -1);
        } else if (cmp(d1.start, c1.start) <= 0) {
          shift(c1, d1, 1);
        } else {
          shift(d1, Range.fromPoints(c1.start, d1.start), -1);
          shift(c1, d1, 1);
        }
      } else if (!i1 && i2) {
        if (cmp(c1.start, d1.end) >= 0) {
          shift(c1, d1, -1);
        } else if (cmp(c1.start, d1.start) <= 0) {
          shift(d1, c1, 1);
        } else {
          shift(c1, Range.fromPoints(d1.start, c1.start), -1);
          shift(d1, c1, 1);
        }
      } else if (!i1 && !i2) {
        if (cmp(c1.start, d1.end) >= 0) {
          shift(c1, d1, -1);
        } else if (cmp(c1.end, d1.start) <= 0) {
          shift(d1, c1, -1);
        } else {
          var before, after;
          if (cmp(d1.start, c1.start) < 0) {
            before = d1;
            d1 = splitDelta(d1, c1.start);
          }
          if (cmp(d1.end, c1.end) > 0) {
            after = splitDelta(d1, c1.end);
          }
          shiftPos(c1.end, d1.start, d1.end, -1);
          if (after && !before) {
            d1.lines = after.lines;
            d1.start = after.start;
            d1.end = after.end;
            after = d1;
          }
          return [c1, before, after].filter(Boolean);
        }
      }
      return [c1, d1];
    }
    function shift(d1, d2, dir) {
      shiftPos(d1.start, d2.start, d2.end, dir);
      shiftPos(d1.end, d2.start, d2.end, dir);
    }
    function shiftPos(pos, start, end, dir) {
      if (pos.row == (dir == 1 ? start : end).row) {
        pos.column += dir * (end.column - start.column);
      }
      pos.row += dir * (end.row - start.row);
    }
    function splitDelta(c, pos) {
      var lines = c.lines;
      var end = c.end;
      c.end = clonePos(pos);
      var rowsBefore = c.end.row - c.start.row;
      var otherLines = lines.splice(rowsBefore, lines.length);
      var col = rowsBefore ? pos.column : pos.column - c.start.column;
      lines.push(otherLines[0].substring(0, col));
      otherLines[0] = otherLines[0].substr(col);
      var rest = {
        start: clonePos(pos),
        end,
        lines: otherLines,
        action: c.action
      };
      return rest;
    }
    function moveDeltasByOne(redoStack, d) {
      d = cloneDelta(d);
      for (var j = redoStack.length; j--; ) {
        var deltaSet = redoStack[j];
        for (var i = 0; i < deltaSet.length; i++) {
          var x = deltaSet[i];
          var xformed = xform(x, d);
          d = xformed[0];
          if (xformed.length != 2) {
            if (xformed[2]) {
              deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);
              i++;
            } else if (!xformed[1]) {
              deltaSet.splice(i, 1);
              i--;
            }
          }
        }
        if (!deltaSet.length) {
          redoStack.splice(j, 1);
        }
      }
      return redoStack;
    }
    function rebaseRedoStack(redoStack, deltaSets) {
      for (var i = 0; i < deltaSets.length; i++) {
        var deltas = deltaSets[i];
        for (var j = 0; j < deltas.length; j++) {
          moveDeltasByOne(redoStack, deltas[j]);
        }
      }
    }
    exports2.UndoManager = UndoManager;
  });
  ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
    var Range = require2("../range").Range;
    var FoldLine = (
      /** @class */
      function() {
        function FoldLine2(foldData, folds) {
          this.foldData = foldData;
          if (Array.isArray(folds)) {
            this.folds = folds;
          } else {
            folds = this.folds = [folds];
          }
          var last = folds[folds.length - 1];
          this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
          this.start = this.range.start;
          this.end = this.range.end;
          this.folds.forEach(function(fold) {
            fold.setFoldLine(this);
          }, this);
        }
        FoldLine2.prototype.shiftRow = function(shift) {
          this.start.row += shift;
          this.end.row += shift;
          this.folds.forEach(function(fold) {
            fold.start.row += shift;
            fold.end.row += shift;
          });
        };
        FoldLine2.prototype.addFold = function(fold) {
          if (fold.sameRow) {
            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
              throw new Error("Can't add a fold to this FoldLine as it has no connection");
            }
            this.folds.push(fold);
            this.folds.sort(function(a, b) {
              return -a.range.compareEnd(b.start.row, b.start.column);
            });
            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
              this.end.row = fold.end.row;
              this.end.column = fold.end.column;
            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
              this.start.row = fold.start.row;
              this.start.column = fold.start.column;
            }
          } else if (fold.start.row == this.end.row) {
            this.folds.push(fold);
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
          } else if (fold.end.row == this.start.row) {
            this.folds.unshift(fold);
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
          } else {
            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
          }
          fold.foldLine = this;
        };
        FoldLine2.prototype.containsRow = function(row) {
          return row >= this.start.row && row <= this.end.row;
        };
        FoldLine2.prototype.walk = function(callback, endRow, endColumn) {
          var lastEnd = 0, folds = this.folds, fold, cmp, stop, isNewRow = true;
          if (endRow == null) {
            endRow = this.end.row;
            endColumn = this.end.column;
          }
          for (var i = 0; i < folds.length; i++) {
            fold = folds[i];
            cmp = fold.range.compareStart(endRow, endColumn);
            if (cmp == -1) {
              callback(null, endRow, endColumn, lastEnd, isNewRow);
              return;
            }
            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
            if (stop || cmp === 0) {
              return;
            }
            isNewRow = !fold.sameRow;
            lastEnd = fold.end.column;
          }
          callback(null, endRow, endColumn, lastEnd, isNewRow);
        };
        FoldLine2.prototype.getNextFoldTo = function(row, column) {
          var fold, cmp;
          for (var i = 0; i < this.folds.length; i++) {
            fold = this.folds[i];
            cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
              return {
                fold,
                kind: "after"
              };
            } else if (cmp === 0) {
              return {
                fold,
                kind: "inside"
              };
            }
          }
          return null;
        };
        FoldLine2.prototype.addRemoveChars = function(row, column, len) {
          var ret = this.getNextFoldTo(row, column), fold, folds;
          if (ret) {
            fold = ret.fold;
            if (ret.kind == "inside" && fold.start.column != column && fold.start.row != row) {
              window.console && window.console.log(row, column, fold);
            } else if (fold.start.row == row) {
              folds = this.folds;
              var i = folds.indexOf(fold);
              if (i === 0) {
                this.start.column += len;
              }
              for (i; i < folds.length; i++) {
                fold = folds[i];
                fold.start.column += len;
                if (!fold.sameRow) {
                  return;
                }
                fold.end.column += len;
              }
              this.end.column += len;
            }
          }
        };
        FoldLine2.prototype.split = function(row, column) {
          var pos = this.getNextFoldTo(row, column);
          if (!pos || pos.kind == "inside")
            return null;
          var fold = pos.fold;
          var folds = this.folds;
          var foldData = this.foldData;
          var i = folds.indexOf(fold);
          var foldBefore = folds[i - 1];
          this.end.row = foldBefore.end.row;
          this.end.column = foldBefore.end.column;
          folds = folds.splice(i, folds.length - i);
          var newFoldLine = new FoldLine2(foldData, folds);
          foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
          return newFoldLine;
        };
        FoldLine2.prototype.merge = function(foldLineNext) {
          var folds = foldLineNext.folds;
          for (var i = 0; i < folds.length; i++) {
            this.addFold(folds[i]);
          }
          var foldData = this.foldData;
          foldData.splice(foldData.indexOf(foldLineNext), 1);
        };
        FoldLine2.prototype.toString = function() {
          var ret = [this.range.toString() + ": ["];
          this.folds.forEach(function(fold) {
            ret.push("  " + fold.toString());
          });
          ret.push("]");
          return ret.join("\n");
        };
        FoldLine2.prototype.idxToPosition = function(idx) {
          var lastFoldEndColumn = 0;
          for (var i = 0; i < this.folds.length; i++) {
            var fold = this.folds[i];
            idx -= fold.start.column - lastFoldEndColumn;
            if (idx < 0) {
              return {
                row: fold.start.row,
                column: fold.start.column + idx
              };
            }
            idx -= fold.placeholder.length;
            if (idx < 0) {
              return fold.start;
            }
            lastFoldEndColumn = fold.end.column;
          }
          return {
            row: this.end.row,
            column: this.end.column + idx
          };
        };
        return FoldLine2;
      }()
    );
    exports2.FoldLine = FoldLine;
  });
  ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
    var Range = require2("./range").Range;
    var comparePoints = Range.comparePoints;
    var RangeList = (
      /** @class */
      function() {
        function RangeList2() {
          this.ranges = [];
          this.$bias = 1;
        }
        RangeList2.prototype.pointIndex = function(pos, excludeEdges, startIndex) {
          var list2 = this.ranges;
          for (var i = startIndex || 0; i < list2.length; i++) {
            var range = list2[i];
            var cmpEnd = comparePoints(pos, range.end);
            if (cmpEnd > 0)
              continue;
            var cmpStart = comparePoints(pos, range.start);
            if (cmpEnd === 0)
              return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
            if (cmpStart > 0 || cmpStart === 0 && !excludeEdges)
              return i;
            return -i - 1;
          }
          return -i - 1;
        };
        RangeList2.prototype.add = function(range) {
          var excludeEdges = !range.isEmpty();
          var startIndex = this.pointIndex(range.start, excludeEdges);
          if (startIndex < 0)
            startIndex = -startIndex - 1;
          var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
          if (endIndex < 0)
            endIndex = -endIndex - 1;
          else
            endIndex++;
          return this.ranges.splice(startIndex, endIndex - startIndex, range);
        };
        RangeList2.prototype.addList = function(list2) {
          var removed = [];
          for (var i = list2.length; i--; ) {
            removed.push.apply(removed, this.add(list2[i]));
          }
          return removed;
        };
        RangeList2.prototype.substractPoint = function(pos) {
          var i = this.pointIndex(pos);
          if (i >= 0)
            return this.ranges.splice(i, 1);
        };
        RangeList2.prototype.merge = function() {
          var removed = [];
          var list2 = this.ranges;
          list2 = list2.sort(function(a, b) {
            return comparePoints(a.start, b.start);
          });
          var next = list2[0], range;
          for (var i = 1; i < list2.length; i++) {
            range = next;
            next = list2[i];
            var cmp = comparePoints(range.end, next.start);
            if (cmp < 0)
              continue;
            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
              continue;
            if (comparePoints(range.end, next.end) < 0) {
              range.end.row = next.end.row;
              range.end.column = next.end.column;
            }
            list2.splice(i, 1);
            removed.push(next);
            next = range;
            i--;
          }
          this.ranges = list2;
          return removed;
        };
        RangeList2.prototype.contains = function(row, column) {
          return this.pointIndex({ row, column }) >= 0;
        };
        RangeList2.prototype.containsPoint = function(pos) {
          return this.pointIndex(pos) >= 0;
        };
        RangeList2.prototype.rangeAtPoint = function(pos) {
          var i = this.pointIndex(pos);
          if (i >= 0)
            return this.ranges[i];
        };
        RangeList2.prototype.clipRows = function(startRow, endRow) {
          var list2 = this.ranges;
          if (list2[0].start.row > endRow || list2[list2.length - 1].start.row < startRow)
            return [];
          var startIndex = this.pointIndex({ row: startRow, column: 0 });
          if (startIndex < 0)
            startIndex = -startIndex - 1;
          var endIndex = this.pointIndex({ row: endRow, column: 0 }, startIndex);
          if (endIndex < 0)
            endIndex = -endIndex - 1;
          var clipped = [];
          for (var i = startIndex; i < endIndex; i++) {
            clipped.push(list2[i]);
          }
          return clipped;
        };
        RangeList2.prototype.removeAll = function() {
          return this.ranges.splice(0, this.ranges.length);
        };
        RangeList2.prototype.attach = function(session) {
          if (this.session)
            this.detach();
          this.session = session;
          this.onChange = this.$onChange.bind(this);
          this.session.on("change", this.onChange);
        };
        RangeList2.prototype.detach = function() {
          if (!this.session)
            return;
          this.session.removeListener("change", this.onChange);
          this.session = null;
        };
        RangeList2.prototype.$onChange = function(delta) {
          var start = delta.start;
          var end = delta.end;
          var startRow = start.row;
          var endRow = end.row;
          var ranges = this.ranges;
          for (var i = 0, n = ranges.length; i < n; i++) {
            var r = ranges[i];
            if (r.end.row >= startRow)
              break;
          }
          if (delta.action == "insert") {
            var lineDif = endRow - startRow;
            var colDiff = -start.column + end.column;
            for (; i < n; i++) {
              var r = ranges[i];
              if (r.start.row > startRow)
                break;
              if (r.start.row == startRow && r.start.column >= start.column) {
                if (r.start.column == start.column && this.$bias <= 0) ;
                else {
                  r.start.column += colDiff;
                  r.start.row += lineDif;
                }
              }
              if (r.end.row == startRow && r.end.column >= start.column) {
                if (r.end.column == start.column && this.$bias < 0) {
                  continue;
                }
                if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                  if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column)
                    r.end.column -= colDiff;
                }
                r.end.column += colDiff;
                r.end.row += lineDif;
              }
            }
          } else {
            var lineDif = startRow - endRow;
            var colDiff = start.column - end.column;
            for (; i < n; i++) {
              var r = ranges[i];
              if (r.start.row > endRow)
                break;
              if (r.end.row < endRow && (startRow < r.end.row || startRow == r.end.row && start.column < r.end.column)) {
                r.end.row = startRow;
                r.end.column = start.column;
              } else if (r.end.row == endRow) {
                if (r.end.column <= end.column) {
                  if (lineDif || r.end.column > start.column) {
                    r.end.column = start.column;
                    r.end.row = start.row;
                  }
                } else {
                  r.end.column += colDiff;
                  r.end.row += lineDif;
                }
              } else if (r.end.row > endRow) {
                r.end.row += lineDif;
              }
              if (r.start.row < endRow && (startRow < r.start.row || startRow == r.start.row && start.column < r.start.column)) {
                r.start.row = startRow;
                r.start.column = start.column;
              } else if (r.start.row == endRow) {
                if (r.start.column <= end.column) {
                  if (lineDif || r.start.column > start.column) {
                    r.start.column = start.column;
                    r.start.row = start.row;
                  }
                } else {
                  r.start.column += colDiff;
                  r.start.row += lineDif;
                }
              } else if (r.start.row > endRow) {
                r.start.row += lineDif;
              }
            }
          }
          if (lineDif != 0 && i < n) {
            for (; i < n; i++) {
              var r = ranges[i];
              r.start.row += lineDif;
              r.end.row += lineDif;
            }
          }
        };
        return RangeList2;
      }()
    );
    RangeList.prototype.comparePoints = comparePoints;
    exports2.RangeList = RangeList;
  });
  ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range_list"], function(require2, exports2, module2) {
    var __extends = this && this.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var RangeList = require2("../range_list").RangeList;
    var Fold = (
      /** @class */
      function(_super) {
        __extends(Fold2, _super);
        function Fold2(range, placeholder) {
          var _this = _super.call(this) || this;
          _this.foldLine = null;
          _this.placeholder = placeholder;
          _this.range = range;
          _this.start = range.start;
          _this.end = range.end;
          _this.sameRow = range.start.row == range.end.row;
          _this.subFolds = _this.ranges = [];
          return _this;
        }
        Fold2.prototype.toString = function() {
          return '"' + this.placeholder + '" ' + this.range.toString();
        };
        Fold2.prototype.setFoldLine = function(foldLine) {
          this.foldLine = foldLine;
          this.subFolds.forEach(function(fold) {
            fold.setFoldLine(foldLine);
          });
        };
        Fold2.prototype.clone = function() {
          var range = this.range.clone();
          var fold = new Fold2(range, this.placeholder);
          this.subFolds.forEach(function(subFold) {
            fold.subFolds.push(subFold.clone());
          });
          fold.collapseChildren = this.collapseChildren;
          return fold;
        };
        Fold2.prototype.addSubFold = function(fold) {
          if (this.range.isEqual(fold))
            return;
          consumeRange(fold, this.start);
          var row = fold.start.row, column = fold.start.column;
          for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
            cmp = this.subFolds[i].range.compare(row, column);
            if (cmp != 1)
              break;
          }
          var afterStart = this.subFolds[i];
          var firstConsumed = 0;
          if (cmp == 0) {
            if (afterStart.range.containsRange(fold))
              return afterStart.addSubFold(fold);
            else
              firstConsumed = 1;
          }
          var row = fold.range.end.row, column = fold.range.end.column;
          for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
            cmp = this.subFolds[j].range.compare(row, column);
            if (cmp != 1)
              break;
          }
          if (cmp == 0)
            j++;
          var consumedFolds = this.subFolds.splice(i, j - i, fold);
          var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
          for (var k = firstConsumed; k < last; k++) {
            fold.addSubFold(consumedFolds[k]);
          }
          fold.setFoldLine(this.foldLine);
          return fold;
        };
        Fold2.prototype.restoreRange = function(range) {
          return restoreRange(range, this.start);
        };
        return Fold2;
      }(RangeList)
    );
    function consumePoint(point, anchor) {
      point.row -= anchor.row;
      if (point.row == 0)
        point.column -= anchor.column;
    }
    function consumeRange(range, anchor) {
      consumePoint(range.start, anchor);
      consumePoint(range.end, anchor);
    }
    function restorePoint(point, anchor) {
      if (point.row == 0)
        point.column += anchor.column;
      point.row += anchor.row;
    }
    function restoreRange(range, anchor) {
      restorePoint(range.start, anchor);
      restorePoint(range.end, anchor);
    }
    exports2.Fold = Fold;
  });
  ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator", "ace/mouse/mouse_event"], function(require2, exports2, module2) {
    var Range = require2("../range").Range;
    var FoldLine = require2("./fold_line").FoldLine;
    var Fold = require2("./fold").Fold;
    var TokenIterator = require2("../token_iterator").TokenIterator;
    var MouseEvent = require2("../mouse/mouse_event").MouseEvent;
    function Folding() {
      this.getFoldAt = function(row, column, side) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine)
          return null;
        var folds = foldLine.folds;
        for (var i = 0; i < folds.length; i++) {
          var range = folds[i].range;
          if (range.contains(row, column)) {
            if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {
              continue;
            } else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {
              continue;
            }
            return folds[i];
          }
        }
      };
      this.getFoldsInRange = function(range) {
        var start = range.start;
        var end = range.end;
        var foldLines = this.$foldData;
        var foundFolds = [];
        start.column += 1;
        end.column -= 1;
        for (var i = 0; i < foldLines.length; i++) {
          var cmp = foldLines[i].range.compareRange(range);
          if (cmp == 2) {
            continue;
          } else if (cmp == -2) {
            break;
          }
          var folds = foldLines[i].folds;
          for (var j = 0; j < folds.length; j++) {
            var fold = folds[j];
            cmp = fold.range.compareRange(range);
            if (cmp == -2) {
              break;
            } else if (cmp == 2) {
              continue;
            } else if (cmp == 42) {
              break;
            }
            foundFolds.push(fold);
          }
        }
        start.column -= 1;
        end.column += 1;
        return foundFolds;
      };
      this.getFoldsInRangeList = function(ranges) {
        if (Array.isArray(ranges)) {
          var folds = [];
          ranges.forEach(function(range) {
            folds = folds.concat(this.getFoldsInRange(range));
          }, this);
        } else {
          var folds = this.getFoldsInRange(ranges);
        }
        return folds;
      };
      this.getAllFolds = function() {
        var folds = [];
        var foldLines = this.$foldData;
        for (var i = 0; i < foldLines.length; i++)
          for (var j = 0; j < foldLines[i].folds.length; j++)
            folds.push(foldLines[i].folds[j]);
        return folds;
      };
      this.getFoldStringAt = function(row, column, trim, foldLine) {
        foldLine = foldLine || this.getFoldLine(row);
        if (!foldLine)
          return null;
        var lastFold = {
          end: { column: 0 }
        };
        var str, fold;
        for (var i = 0; i < foldLine.folds.length; i++) {
          fold = foldLine.folds[i];
          var cmp = fold.range.compareEnd(row, column);
          if (cmp == -1) {
            str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
            break;
          } else if (cmp === 0) {
            return null;
          }
          lastFold = fold;
        }
        if (!str)
          str = this.getLine(fold.start.row).substring(lastFold.end.column);
        if (trim == -1)
          return str.substring(0, column - lastFold.end.column);
        else if (trim == 1)
          return str.substring(column - lastFold.end.column);
        else
          return str;
      };
      this.getFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
          i = foldData.indexOf(startFoldLine);
        if (i == -1)
          i = 0;
        for (i; i < foldData.length; i++) {
          var foldLine = foldData[i];
          if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
            return foldLine;
          } else if (foldLine.end.row > docRow) {
            return null;
          }
        }
        return null;
      };
      this.getNextFoldLine = function(docRow, startFoldLine) {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
          i = foldData.indexOf(startFoldLine);
        if (i == -1)
          i = 0;
        for (i; i < foldData.length; i++) {
          var foldLine = foldData[i];
          if (foldLine.end.row >= docRow) {
            return foldLine;
          }
        }
        return null;
      };
      this.getFoldedRowCount = function(first, last) {
        var foldData = this.$foldData, rowCount = last - first + 1;
        for (var i = 0; i < foldData.length; i++) {
          var foldLine = foldData[i], end = foldLine.end.row, start = foldLine.start.row;
          if (end >= last) {
            if (start < last) {
              if (start >= first)
                rowCount -= last - start;
              else
                rowCount = 0;
            }
            break;
          } else if (end >= first) {
            if (start >= first)
              rowCount -= end - start;
            else
              rowCount -= end - first + 1;
          }
        }
        return rowCount;
      };
      this.$addFoldLine = function(foldLine) {
        this.$foldData.push(foldLine);
        this.$foldData.sort(function(a, b) {
          return a.start.row - b.start.row;
        });
        return foldLine;
      };
      this.addFold = function(placeholder, range) {
        var foldData = this.$foldData;
        var added = false;
        var fold;
        if (placeholder instanceof Fold)
          fold = placeholder;
        else {
          fold = new Fold(range, placeholder);
          fold.collapseChildren = range.collapseChildren;
        }
        this.$clipRangeToDocument(fold.range);
        var startRow = fold.start.row;
        var startColumn = fold.start.column;
        var endRow = fold.end.row;
        var endColumn = fold.end.column;
        var startFold = this.getFoldAt(startRow, startColumn, 1);
        var endFold = this.getFoldAt(endRow, endColumn, -1);
        if (startFold && endFold == startFold)
          return startFold.addSubFold(fold);
        if (startFold && !startFold.range.isStart(startRow, startColumn))
          this.removeFold(startFold);
        if (endFold && !endFold.range.isEnd(endRow, endColumn))
          this.removeFold(endFold);
        var folds = this.getFoldsInRange(fold.range);
        if (folds.length > 0) {
          this.removeFolds(folds);
          if (!fold.collapseChildren) {
            folds.forEach(function(subFold) {
              fold.addSubFold(subFold);
            });
          }
        }
        for (var i = 0; i < foldData.length; i++) {
          var foldLine = foldData[i];
          if (endRow == foldLine.start.row) {
            foldLine.addFold(fold);
            added = true;
            break;
          } else if (startRow == foldLine.end.row) {
            foldLine.addFold(fold);
            added = true;
            if (!fold.sameRow) {
              var foldLineNext = foldData[i + 1];
              if (foldLineNext && foldLineNext.start.row == endRow) {
                foldLine.merge(foldLineNext);
                break;
              }
            }
            break;
          } else if (endRow <= foldLine.start.row) {
            break;
          }
        }
        if (!added)
          foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
        if (this.$useWrapMode)
          this.$updateWrapData(foldLine.start.row, foldLine.start.row);
        else
          this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
        this.$modified = true;
        this._signal("changeFold", { data: fold, action: "add" });
        return fold;
      };
      this.addFolds = function(folds) {
        folds.forEach(function(fold) {
          this.addFold(fold);
        }, this);
      };
      this.removeFold = function(fold) {
        var foldLine = fold.foldLine;
        var startRow = foldLine.start.row;
        var endRow = foldLine.end.row;
        var foldLines = this.$foldData;
        var folds = foldLine.folds;
        if (folds.length == 1) {
          foldLines.splice(foldLines.indexOf(foldLine), 1);
        } else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
          folds.pop();
          foldLine.end.row = folds[folds.length - 1].end.row;
          foldLine.end.column = folds[folds.length - 1].end.column;
        } else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
          folds.shift();
          foldLine.start.row = folds[0].start.row;
          foldLine.start.column = folds[0].start.column;
        } else if (fold.sameRow) {
          folds.splice(folds.indexOf(fold), 1);
        } else {
          var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
          folds = newFoldLine.folds;
          folds.shift();
          newFoldLine.start.row = folds[0].start.row;
          newFoldLine.start.column = folds[0].start.column;
        }
        if (!this.$updating) {
          if (this.$useWrapMode)
            this.$updateWrapData(startRow, endRow);
          else
            this.$updateRowLengthCache(startRow, endRow);
        }
        this.$modified = true;
        this._signal("changeFold", { data: fold, action: "remove" });
      };
      this.removeFolds = function(folds) {
        var cloneFolds = [];
        for (var i = 0; i < folds.length; i++) {
          cloneFolds.push(folds[i]);
        }
        cloneFolds.forEach(function(fold) {
          this.removeFold(fold);
        }, this);
        this.$modified = true;
      };
      this.expandFold = function(fold) {
        this.removeFold(fold);
        fold.subFolds.forEach(function(subFold) {
          fold.restoreRange(subFold);
          this.addFold(subFold);
        }, this);
        if (fold.collapseChildren > 0) {
          this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
        }
        fold.subFolds = [];
      };
      this.expandFolds = function(folds) {
        folds.forEach(function(fold) {
          this.expandFold(fold);
        }, this);
      };
      this.unfold = function(location, expandInner) {
        var range, folds;
        if (location == null) {
          range = new Range(0, 0, this.getLength(), 0);
          if (expandInner == null)
            expandInner = true;
        } else if (typeof location == "number") {
          range = new Range(location, 0, location, this.getLine(location).length);
        } else if ("row" in location) {
          range = Range.fromPoints(location, location);
        } else if (Array.isArray(location)) {
          folds = [];
          location.forEach(function(range2) {
            folds = folds.concat(this.unfold(range2));
          }, this);
          return folds;
        } else {
          range = location;
        }
        folds = this.getFoldsInRangeList(range);
        var outermostFolds = folds;
        while (folds.length == 1 && Range.comparePoints(folds[0].start, range.start) < 0 && Range.comparePoints(folds[0].end, range.end) > 0) {
          this.expandFolds(folds);
          folds = this.getFoldsInRangeList(range);
        }
        if (expandInner != false) {
          this.removeFolds(folds);
        } else {
          this.expandFolds(folds);
        }
        if (outermostFolds.length)
          return outermostFolds;
      };
      this.isRowFolded = function(docRow, startFoldRow) {
        return !!this.getFoldLine(docRow, startFoldRow);
      };
      this.getRowFoldEnd = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.end.row : docRow;
      };
      this.getRowFoldStart = function(docRow, startFoldRow) {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.start.row : docRow;
      };
      this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
        if (startRow == null)
          startRow = foldLine.start.row;
        if (startColumn == null)
          startColumn = 0;
        if (endRow == null)
          endRow = foldLine.end.row;
        if (endColumn == null)
          endColumn = this.getLine(endRow).length;
        var doc = this.doc;
        var textLine = "";
        foldLine.walk(function(placeholder, row, column, lastColumn) {
          if (row < startRow)
            return;
          if (row == startRow) {
            if (column < startColumn)
              return;
            lastColumn = Math.max(startColumn, lastColumn);
          }
          if (placeholder != null) {
            textLine += placeholder;
          } else {
            textLine += doc.getLine(row).substring(lastColumn, column);
          }
        }, endRow, endColumn);
        return textLine;
      };
      this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
        var foldLine = this.getFoldLine(row);
        if (!foldLine) {
          var line;
          line = this.doc.getLine(row);
          return line.substring(startColumn || 0, endColumn || line.length);
        } else {
          return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
        }
      };
      this.$cloneFoldData = function() {
        var fd = [];
        fd = this.$foldData.map(function(foldLine) {
          var folds = foldLine.folds.map(function(fold) {
            return fold.clone();
          });
          return new FoldLine(fd, folds);
        });
        return fd;
      };
      this.toggleFold = function(tryToUnfold) {
        var selection = this.selection;
        var range = selection.getRange();
        var fold;
        var bracketPos;
        if (range.isEmpty()) {
          var cursor = range.start;
          fold = this.getFoldAt(cursor.row, cursor.column);
          if (fold) {
            this.expandFold(fold);
            return;
          } else if (tryToUnfold) {
            var foldLine = this.getFoldLine(cursor.row);
            if (foldLine)
              this.expandFolds(foldLine.folds);
            return;
          } else if (bracketPos = this.findMatchingBracket(cursor)) {
            if (range.comparePoint(bracketPos) == 1) {
              range.end = bracketPos;
            } else {
              range.start = bracketPos;
              range.start.column++;
              range.end.column--;
            }
          } else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {
            if (range.comparePoint(bracketPos) == 1)
              range.end = bracketPos;
            else
              range.start = bracketPos;
            range.start.column++;
          } else {
            range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
          }
        } else {
          var folds = this.getFoldsInRange(range);
          if (tryToUnfold && folds.length) {
            this.expandFolds(folds);
            return;
          } else if (folds.length == 1) {
            fold = folds[0];
          }
        }
        if (!fold)
          fold = this.getFoldAt(range.start.row, range.start.column);
        if (fold && fold.range.toString() == range.toString()) {
          this.expandFold(fold);
          return;
        }
        var placeholder = "...";
        if (!range.isMultiLine()) {
          placeholder = this.getTextRange(range);
          if (placeholder.length < 4)
            return;
          placeholder = placeholder.trim().substring(0, 2) + "..";
        }
        this.addFold(placeholder, range);
      };
      this.getCommentFoldRange = function(row, column, dir) {
        var iterator = new TokenIterator(this, row, column);
        var token = iterator.getCurrentToken();
        var type = token && token.type;
        if (token && /^comment|string/.test(type)) {
          type = type.match(/comment|string/)[0];
          if (type == "comment")
            type += "|doc-start|\\.doc";
          var re = new RegExp(type);
          var range = new Range();
          if (dir != 1) {
            do {
              token = iterator.stepBackward();
            } while (token && re.test(token.type));
            token = iterator.stepForward();
          }
          range.start.row = iterator.getCurrentTokenRow();
          range.start.column = iterator.getCurrentTokenColumn() + token.value.length;
          iterator = new TokenIterator(this, row, column);
          var initState = this.getState(iterator.$row);
          if (dir != -1) {
            var lastRow = -1;
            do {
              token = iterator.stepForward();
              if (lastRow == -1) {
                var state = this.getState(iterator.$row);
                if (initState.toString() !== state.toString())
                  lastRow = iterator.$row;
              } else if (iterator.$row > lastRow) {
                break;
              }
            } while (token && re.test(token.type));
            token = iterator.stepBackward();
          } else
            token = iterator.getCurrentToken();
          range.end.row = iterator.getCurrentTokenRow();
          range.end.column = iterator.getCurrentTokenColumn();
          if (range.start.row == range.end.row && range.start.column > range.end.column)
            return;
          return range;
        }
      };
      this.foldAll = function(startRow, endRow, depth, test) {
        if (depth == void 0)
          depth = 1e5;
        var foldWidgets = this.foldWidgets;
        if (!foldWidgets)
          return;
        endRow = endRow || this.getLength();
        startRow = startRow || 0;
        for (var row = startRow; row < endRow; row++) {
          if (foldWidgets[row] == null)
            foldWidgets[row] = this.getFoldWidget(row);
          if (foldWidgets[row] != "start")
            continue;
          if (test && !test(row))
            continue;
          var range = this.getFoldWidgetRange(row);
          if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
            row = range.end.row;
            range.collapseChildren = depth;
            this.addFold("...", range);
          }
        }
      };
      this.foldToLevel = function(level) {
        this.foldAll();
        while (level-- > 0)
          this.unfold(null, false);
      };
      this.foldAllComments = function() {
        var session = this;
        this.foldAll(null, null, null, function(row) {
          var tokens = session.getTokens(row);
          for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (token.type == "text" && /^\s+$/.test(token.value))
              continue;
            if (/comment/.test(token.type))
              return true;
            return false;
          }
        });
      };
      this.$foldStyles = {
        "manual": 1,
        "markbegin": 1,
        "markbeginend": 1
      };
      this.$foldStyle = "markbegin";
      this.setFoldStyle = function(style2) {
        if (!this.$foldStyles[style2])
          throw new Error("invalid fold style: " + style2 + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
        if (this.$foldStyle == style2)
          return;
        this.$foldStyle = style2;
        if (style2 == "manual")
          this.unfold();
        var mode = this.$foldMode;
        this.$setFolding(null);
        this.$setFolding(mode);
      };
      this.$setFolding = function(foldMode) {
        if (this.$foldMode == foldMode)
          return;
        this.$foldMode = foldMode;
        this.off("change", this.$updateFoldWidgets);
        this.off("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
        this._signal("changeAnnotation");
        if (!foldMode || this.$foldStyle == "manual") {
          this.foldWidgets = null;
          return;
        }
        this.foldWidgets = [];
        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
        this.on("change", this.$updateFoldWidgets);
        this.on("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
      };
      this.getParentFoldRangeData = function(row, ignoreCurrent) {
        var fw = this.foldWidgets;
        if (!fw || ignoreCurrent && fw[row])
          return {};
        var i = row - 1, firstRange;
        while (i >= 0) {
          var c = fw[i];
          if (c == null)
            c = fw[i] = this.getFoldWidget(i);
          if (c == "start") {
            var range = this.getFoldWidgetRange(i);
            if (!firstRange)
              firstRange = range;
            if (range && range.end.row >= row)
              break;
          }
          i--;
        }
        return {
          range: i !== -1 && range,
          firstRange
        };
      };
      this.onFoldWidgetClick = function(row, e) {
        if (e instanceof MouseEvent)
          e = e.domEvent;
        var options = {
          children: e.shiftKey,
          all: e.ctrlKey || e.metaKey,
          siblings: e.altKey
        };
        var range = this.$toggleFoldWidget(row, options);
        if (!range) {
          var el = e.target || e.srcElement;
          if (el && /ace_fold-widget/.test(el.className))
            el.className += " ace_invalid";
        }
      };
      this.$toggleFoldWidget = function(row, options) {
        if (!this.getFoldWidget)
          return;
        var type = this.getFoldWidget(row);
        var line = this.getLine(row);
        var dir = type === "end" ? -1 : 1;
        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
        if (fold) {
          if (options.children || options.all)
            this.removeFold(fold);
          else
            this.expandFold(fold);
          return fold;
        }
        var range = this.getFoldWidgetRange(row, true);
        if (range && !range.isMultiLine()) {
          fold = this.getFoldAt(range.start.row, range.start.column, 1);
          if (fold && range.isEqual(fold.range)) {
            this.removeFold(fold);
            return fold;
          }
        }
        if (options.siblings) {
          var data = this.getParentFoldRangeData(row);
          if (data.range) {
            var startRow = data.range.start.row + 1;
            var endRow = data.range.end.row;
          }
          this.foldAll(startRow, endRow, options.all ? 1e4 : 0);
        } else if (options.children) {
          endRow = range ? range.end.row : this.getLength();
          this.foldAll(row + 1, endRow, options.all ? 1e4 : 0);
        } else if (range) {
          if (options.all)
            range.collapseChildren = 1e4;
          this.addFold("...", range);
        }
        return range;
      };
      this.toggleFoldWidget = function(toggleParent) {
        var row = this.selection.getCursor().row;
        row = this.getRowFoldStart(row);
        var range = this.$toggleFoldWidget(row, {});
        if (range)
          return;
        var data = this.getParentFoldRangeData(row, true);
        range = data.range || data.firstRange;
        if (range) {
          row = range.start.row;
          var fold = this.getFoldAt(row, this.getLine(row).length, 1);
          if (fold) {
            this.removeFold(fold);
          } else {
            this.addFold("...", range);
          }
        }
      };
      this.updateFoldWidgets = function(delta) {
        var firstRow = delta.start.row;
        var len = delta.end.row - firstRow;
        if (len === 0) {
          this.foldWidgets[firstRow] = null;
        } else if (delta.action == "remove") {
          this.foldWidgets.splice(firstRow, len + 1, null);
        } else {
          var args = Array(len + 1);
          args.unshift(firstRow, 1);
          this.foldWidgets.splice.apply(this.foldWidgets, args);
        }
      };
      this.tokenizerUpdateFoldWidgets = function(e) {
        var rows = e.data;
        if (rows.first != rows.last) {
          if (this.foldWidgets.length > rows.first)
            this.foldWidgets.splice(rows.first, this.foldWidgets.length);
        }
      };
    }
    exports2.Folding = Folding;
  });
  ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function(require2, exports2, module2) {
    var TokenIterator = require2("../token_iterator").TokenIterator;
    var Range = require2("../range").Range;
    function BracketMatch() {
      this.findMatchingBracket = function(position, chr) {
        if (position.column == 0)
          return null;
        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
        if (charBeforeCursor == "")
          return null;
        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
        if (!match)
          return null;
        if (match[1])
          return this.$findClosingBracket(match[1], position);
        else
          return this.$findOpeningBracket(match[2], position);
      };
      this.getBracketRange = function(pos) {
        var line = this.getLine(pos.row);
        var before = true, range;
        var chr = line.charAt(pos.column - 1);
        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
        if (!match) {
          chr = line.charAt(pos.column);
          pos = { row: pos.row, column: pos.column + 1 };
          match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
          before = false;
        }
        if (!match)
          return null;
        if (match[1]) {
          var bracketPos = this.$findClosingBracket(match[1], pos);
          if (!bracketPos)
            return null;
          range = Range.fromPoints(pos, bracketPos);
          if (!before) {
            range.end.column++;
            range.start.column--;
          }
          range.cursor = range.end;
        } else {
          var bracketPos = this.$findOpeningBracket(match[2], pos);
          if (!bracketPos)
            return null;
          range = Range.fromPoints(bracketPos, pos);
          if (!before) {
            range.start.column++;
            range.end.column--;
          }
          range.cursor = range.start;
        }
        return range;
      };
      this.getMatchingBracketRanges = function(pos, isBackwards) {
        var line = this.getLine(pos.row);
        var bracketsRegExp = /([\(\[\{])|([\)\]\}])/;
        var chr = !isBackwards && line.charAt(pos.column - 1);
        var match = chr && chr.match(bracketsRegExp);
        if (!match) {
          chr = (isBackwards === void 0 || isBackwards) && line.charAt(pos.column);
          pos = {
            row: pos.row,
            column: pos.column + 1
          };
          match = chr && chr.match(bracketsRegExp);
        }
        if (!match)
          return null;
        var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);
        var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos) : this.$findOpeningBracket(match[2], pos);
        if (!bracketPos)
          return [startRange];
        var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);
        return [startRange, endRange];
      };
      this.$brackets = {
        ")": "(",
        "(": ")",
        "]": "[",
        "[": "]",
        "{": "}",
        "}": "{",
        "<": ">",
        ">": "<"
      };
      this.$findOpeningBracket = function(bracket, position, typeRe) {
        var openBracket = this.$brackets[bracket];
        var depth = 1;
        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
          token = iterator.stepForward();
        if (!token)
          return;
        if (!typeRe) {
          typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)").replace(/-close\b/, "-(close|open)") + ")+");
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
        var value = token.value;
        while (true) {
          while (valueIndex >= 0) {
            var chr = value.charAt(valueIndex);
            if (chr == openBracket) {
              depth -= 1;
              if (depth == 0) {
                return {
                  row: iterator.getCurrentTokenRow(),
                  column: valueIndex + iterator.getCurrentTokenColumn()
                };
              }
            } else if (chr == bracket) {
              depth += 1;
            }
            valueIndex -= 1;
          }
          do {
            token = iterator.stepBackward();
          } while (token && !typeRe.test(token.type));
          if (token == null)
            break;
          value = token.value;
          valueIndex = value.length - 1;
        }
        return null;
      };
      this.$findClosingBracket = function(bracket, position, typeRe) {
        var closingBracket = this.$brackets[bracket];
        var depth = 1;
        var iterator = new TokenIterator(this, position.row, position.column);
        var token = iterator.getCurrentToken();
        if (!token)
          token = iterator.stepForward();
        if (!token)
          return;
        if (!typeRe) {
          typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)").replace(/-open\b/, "-(close|open)") + ")+");
        }
        var valueIndex = position.column - iterator.getCurrentTokenColumn();
        while (true) {
          var value = token.value;
          var valueLength = value.length;
          while (valueIndex < valueLength) {
            var chr = value.charAt(valueIndex);
            if (chr == closingBracket) {
              depth -= 1;
              if (depth == 0) {
                return {
                  row: iterator.getCurrentTokenRow(),
                  column: valueIndex + iterator.getCurrentTokenColumn()
                };
              }
            } else if (chr == bracket) {
              depth += 1;
            }
            valueIndex += 1;
          }
          do {
            token = iterator.stepForward();
          } while (token && !typeRe.test(token.type));
          if (token == null)
            break;
          valueIndex = 0;
        }
        return null;
      };
      this.getMatchingTags = function(pos) {
        var iterator = new TokenIterator(this, pos.row, pos.column);
        var token = this.$findTagName(iterator);
        if (!token)
          return;
        var prevToken = iterator.stepBackward();
        if (prevToken.value === "<") {
          return this.$findClosingTag(iterator, token);
        } else {
          return this.$findOpeningTag(iterator, token);
        }
      };
      this.$findTagName = function(iterator) {
        var token = iterator.getCurrentToken();
        var found = false;
        var backward = false;
        if (token && token.type.indexOf("tag-name") === -1) {
          do {
            if (backward)
              token = iterator.stepBackward();
            else
              token = iterator.stepForward();
            if (token) {
              if (token.value === "/>") {
                backward = true;
              } else if (token.type.indexOf("tag-name") !== -1) {
                found = true;
              }
            }
          } while (token && !found);
        }
        return token;
      };
      this.$findClosingTag = function(iterator, token) {
        var prevToken;
        var currentTag = token.value;
        var tag = token.value;
        var depth = 0;
        var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
        token = iterator.stepForward();
        var openTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
        var foundOpenTagEnd = false;
        do {
          prevToken = token;
          if (prevToken.type.indexOf("tag-close") !== -1 && !foundOpenTagEnd) {
            var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
            foundOpenTagEnd = true;
          }
          token = iterator.stepForward();
          if (token) {
            if (token.value === ">" && !foundOpenTagEnd) {
              var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
              foundOpenTagEnd = true;
            }
            if (token.type.indexOf("tag-name") !== -1) {
              currentTag = token.value;
              if (tag === currentTag) {
                if (prevToken.value === "<") {
                  depth++;
                } else if (prevToken.value === "</") {
                  depth--;
                  if (depth < 0) {
                    iterator.stepBackward();
                    var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
                    token = iterator.stepForward();
                    var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
                    if (token.type.indexOf("tag-close") === -1) {
                      token = iterator.stepForward();
                    }
                    if (token && token.value === ">") {
                      var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                    } else {
                      return;
                    }
                  }
                }
              }
            } else if (tag === currentTag && token.value === "/>") {
              depth--;
              if (depth < 0) {
                var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
                var closeTagName = closeTagStart;
                var closeTagEnd = closeTagName;
                var openTagEnd = new Range(openTagName.end.row, openTagName.end.column, openTagName.end.row, openTagName.end.column + 1);
              }
            }
          }
        } while (token && depth >= 0);
        if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
          return {
            openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
            closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
            openTagName,
            closeTagName
          };
        }
      };
      this.$findOpeningTag = function(iterator, token) {
        var prevToken = iterator.getCurrentToken();
        var tag = token.value;
        var depth = 0;
        var startRow = iterator.getCurrentTokenRow();
        var startColumn = iterator.getCurrentTokenColumn();
        var endColumn = startColumn + 2;
        var closeTagStart = new Range(startRow, startColumn, startRow, endColumn);
        iterator.stepForward();
        var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
        if (token.type.indexOf("tag-close") === -1) {
          token = iterator.stepForward();
        }
        if (!token || token.value !== ">")
          return;
        var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
        iterator.stepBackward();
        iterator.stepBackward();
        do {
          token = prevToken;
          startRow = iterator.getCurrentTokenRow();
          startColumn = iterator.getCurrentTokenColumn();
          endColumn = startColumn + token.value.length;
          prevToken = iterator.stepBackward();
          if (token) {
            if (token.type.indexOf("tag-name") !== -1) {
              if (tag === token.value) {
                if (prevToken.value === "<") {
                  depth++;
                  if (depth > 0) {
                    var openTagName = new Range(startRow, startColumn, startRow, endColumn);
                    var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                    do {
                      token = iterator.stepForward();
                    } while (token && token.value !== ">");
                    var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                  }
                } else if (prevToken.value === "</") {
                  depth--;
                }
              }
            } else if (token.value === "/>") {
              var stepCount = 0;
              var tmpToken = prevToken;
              while (tmpToken) {
                if (tmpToken.type.indexOf("tag-name") !== -1 && tmpToken.value === tag) {
                  depth--;
                  break;
                } else if (tmpToken.value === "<") {
                  break;
                }
                tmpToken = iterator.stepBackward();
                stepCount++;
              }
              for (var i = 0; i < stepCount; i++) {
                iterator.stepForward();
              }
            }
          }
        } while (prevToken && depth <= 0);
        if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
          return {
            openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
            closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
            openTagName,
            closeTagName
          };
        }
      };
    }
    exports2.BracketMatch = BracketMatch;
  });
  ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/bidihandler", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/line_widgets", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/undomanager", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function(require2, exports2, module2) {
    var oop = require2("./lib/oop");
    var lang = require2("./lib/lang");
    var BidiHandler = require2("./bidihandler").BidiHandler;
    var config = require2("./config");
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var Selection = require2("./selection").Selection;
    var TextMode = require2("./mode/text").Mode;
    var Range = require2("./range").Range;
    var LineWidgets = require2("./line_widgets").LineWidgets;
    var Document = require2("./document").Document;
    var BackgroundTokenizer = require2("./background_tokenizer").BackgroundTokenizer;
    var SearchHighlight = require2("./search_highlight").SearchHighlight;
    var UndoManager = require2("./undomanager").UndoManager;
    var EditSession = (
      /** @class */
      function() {
        function EditSession2(text, mode) {
          this.doc;
          this.$breakpoints = [];
          this.$decorations = [];
          this.$frontMarkers = {};
          this.$backMarkers = {};
          this.$markerId = 1;
          this.$undoSelect = true;
          this.$editor = null;
          this.prevOp = {};
          this.$foldData = [];
          this.id = "session" + ++EditSession2.$uid;
          this.$foldData.toString = function() {
            return this.join("\n");
          };
          this.$gutterCustomWidgets = {};
          this.bgTokenizer = new BackgroundTokenizer(new TextMode().getTokenizer(), this);
          var _self = this;
          this.bgTokenizer.on("update", function(e) {
            _self._signal("tokenizerUpdate", e);
          });
          this.on("changeFold", this.onChangeFold.bind(this));
          this.$onChange = this.onChange.bind(this);
          if (typeof text != "object" || !text.getLine)
            text = new Document(
              /**@type{string}*/
              text
            );
          this.setDocument(text);
          this.selection = new Selection(this);
          this.$onSelectionChange = this.onSelectionChange.bind(this);
          this.selection.on("changeSelection", this.$onSelectionChange);
          this.selection.on("changeCursor", this.$onSelectionChange);
          this.$bidiHandler = new BidiHandler(this);
          config.resetOptions(this);
          this.setMode(mode);
          config._signal("session", this);
          this.destroyed = false;
          this.$initOperationListeners();
        }
        EditSession2.prototype.$initOperationListeners = function() {
          var _this = this;
          this.curOp = null;
          this.on("change", function() {
            if (!_this.curOp) {
              _this.startOperation();
              _this.curOp.selectionBefore = _this.$lastSel;
            }
            _this.curOp.docChanged = true;
          }, true);
          this.on("changeSelection", function() {
            if (!_this.curOp) {
              _this.startOperation();
              _this.curOp.selectionBefore = _this.$lastSel;
            }
            _this.curOp.selectionChanged = true;
          }, true);
          this.$operationResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
        };
        EditSession2.prototype.startOperation = function(commandEvent) {
          if (this.curOp) {
            if (!commandEvent || this.curOp.command) {
              return;
            }
            this.prevOp = this.curOp;
          }
          if (!commandEvent) {
            commandEvent = {};
          }
          this.$operationResetTimer.schedule();
          this.curOp = {
            command: commandEvent.command || {},
            args: commandEvent.args
          };
          this.curOp.selectionBefore = this.selection.toJSON();
          this._signal("startOperation", commandEvent);
        };
        EditSession2.prototype.endOperation = function(e) {
          if (this.curOp) {
            if (e && e.returnValue === false) {
              this.curOp = null;
              this._signal("endOperation", e);
              return;
            }
            if (e == true && this.curOp.command && this.curOp.command.name == "mouse") {
              return;
            }
            var currentSelection = this.selection.toJSON();
            this.curOp.selectionAfter = currentSelection;
            this.$lastSel = this.selection.toJSON();
            this.getUndoManager().addSelection(currentSelection);
            this._signal("beforeEndOperation");
            this.prevOp = this.curOp;
            this.curOp = null;
            this._signal("endOperation", e);
          }
        };
        EditSession2.prototype.setDocument = function(doc) {
          if (this.doc)
            this.doc.off("change", this.$onChange);
          this.doc = doc;
          doc.on("change", this.$onChange, true);
          this.bgTokenizer.setDocument(this.getDocument());
          this.resetCaches();
        };
        EditSession2.prototype.getDocument = function() {
          return this.doc;
        };
        Object.defineProperty(EditSession2.prototype, "widgetManager", {
          get: function() {
            var widgetManager = new LineWidgets(this);
            this.widgetManager = widgetManager;
            if (this.$editor)
              widgetManager.attach(this.$editor);
            return widgetManager;
          },
          set: function(value) {
            Object.defineProperty(this, "widgetManager", {
              writable: true,
              enumerable: true,
              configurable: true,
              value
            });
          },
          enumerable: false,
          configurable: true
        });
        EditSession2.prototype.$resetRowCache = function(docRow) {
          if (!docRow) {
            this.$docRowCache = [];
            this.$screenRowCache = [];
            return;
          }
          var l = this.$docRowCache.length;
          var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
          if (l > i) {
            this.$docRowCache.splice(i, l);
            this.$screenRowCache.splice(i, l);
          }
        };
        EditSession2.prototype.$getRowCacheIndex = function(cacheArray, val) {
          var low = 0;
          var hi = cacheArray.length - 1;
          while (low <= hi) {
            var mid = low + hi >> 1;
            var c = cacheArray[mid];
            if (val > c)
              low = mid + 1;
            else if (val < c)
              hi = mid - 1;
            else
              return mid;
          }
          return low - 1;
        };
        EditSession2.prototype.resetCaches = function() {
          this.$modified = true;
          this.$wrapData = [];
          this.$rowLengthCache = [];
          this.$resetRowCache(0);
          if (!this.destroyed)
            this.bgTokenizer.start(0);
        };
        EditSession2.prototype.onChangeFold = function(e) {
          var fold = e.data;
          this.$resetRowCache(fold.start.row);
        };
        EditSession2.prototype.onChange = function(delta) {
          this.$modified = true;
          this.$bidiHandler.onChange(delta);
          this.$resetRowCache(delta.start.row);
          var removedFolds = this.$updateInternalDataOnChange(delta);
          if (!this.$fromUndo && this.$undoManager) {
            if (removedFolds && removedFolds.length) {
              this.$undoManager.add({
                action: "removeFolds",
                folds: removedFolds
              }, this.mergeUndoDeltas);
              this.mergeUndoDeltas = true;
            }
            this.$undoManager.add(delta, this.mergeUndoDeltas);
            this.mergeUndoDeltas = true;
            this.$informUndoManager.schedule();
          }
          this.bgTokenizer.$updateOnChange(delta);
          this._signal("change", delta);
        };
        EditSession2.prototype.onSelectionChange = function() {
          this._signal("changeSelection");
        };
        EditSession2.prototype.setValue = function(text) {
          this.doc.setValue(text);
          this.selection.moveTo(0, 0);
          this.$resetRowCache(0);
          this.setUndoManager(this.$undoManager);
          this.getUndoManager().reset();
        };
        EditSession2.fromJSON = function(session) {
          if (typeof session == "string")
            session = JSON.parse(session);
          var undoManager = new UndoManager();
          undoManager.$undoStack = session.history.undo;
          undoManager.$redoStack = session.history.redo;
          undoManager.mark = session.history.mark;
          undoManager.$rev = session.history.rev;
          var editSession = new EditSession2(session.value);
          session.folds.forEach(function(fold) {
            editSession.addFold("...", Range.fromPoints(fold.start, fold.end));
          });
          editSession.setAnnotations(session.annotations);
          editSession.setBreakpoints(session.breakpoints);
          editSession.setMode(session.mode);
          editSession.setScrollLeft(session.scrollLeft);
          editSession.setScrollTop(session.scrollTop);
          editSession.setUndoManager(undoManager);
          editSession.selection.fromJSON(session.selection);
          return editSession;
        };
        EditSession2.prototype.toJSON = function() {
          return {
            annotations: this.$annotations,
            breakpoints: this.$breakpoints,
            folds: this.getAllFolds().map(function(fold) {
              return fold.range;
            }),
            history: this.getUndoManager(),
            mode: this.$mode.$id,
            scrollLeft: this.$scrollLeft,
            scrollTop: this.$scrollTop,
            selection: this.selection.toJSON(),
            value: this.doc.getValue()
          };
        };
        EditSession2.prototype.toString = function() {
          return this.doc.getValue();
        };
        EditSession2.prototype.getSelection = function() {
          return this.selection;
        };
        EditSession2.prototype.getState = function(row) {
          return this.bgTokenizer.getState(row);
        };
        EditSession2.prototype.getTokens = function(row) {
          return this.bgTokenizer.getTokens(row);
        };
        EditSession2.prototype.getTokenAt = function(row, column) {
          var tokens = this.bgTokenizer.getTokens(row);
          var token, c = 0;
          if (column == null) {
            var i = tokens.length - 1;
            c = this.getLine(row).length;
          } else {
            for (var i = 0; i < tokens.length; i++) {
              c += tokens[i].value.length;
              if (c >= column)
                break;
            }
          }
          token = tokens[i];
          if (!token)
            return null;
          token.index = i;
          token.start = c - token.value.length;
          return token;
        };
        EditSession2.prototype.setUndoManager = function(undoManager) {
          this.$undoManager = undoManager;
          if (this.$informUndoManager)
            this.$informUndoManager.cancel();
          if (undoManager) {
            var self2 = this;
            undoManager.addSession(this);
            this.$syncInformUndoManager = function() {
              self2.$informUndoManager.cancel();
              self2.mergeUndoDeltas = false;
            };
            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
          } else {
            this.$syncInformUndoManager = function() {
            };
          }
        };
        EditSession2.prototype.markUndoGroup = function() {
          if (this.$syncInformUndoManager)
            this.$syncInformUndoManager();
        };
        EditSession2.prototype.getUndoManager = function() {
          return this.$undoManager || this.$defaultUndoManager;
        };
        EditSession2.prototype.getTabString = function() {
          if (this.getUseSoftTabs()) {
            return lang.stringRepeat(" ", this.getTabSize());
          } else {
            return "	";
          }
        };
        EditSession2.prototype.setUseSoftTabs = function(val) {
          this.setOption("useSoftTabs", val);
        };
        EditSession2.prototype.getUseSoftTabs = function() {
          return this.$useSoftTabs && !this.$mode.$indentWithTabs;
        };
        EditSession2.prototype.setTabSize = function(tabSize) {
          this.setOption("tabSize", tabSize);
        };
        EditSession2.prototype.getTabSize = function() {
          return this.$tabSize;
        };
        EditSession2.prototype.isTabStop = function(position) {
          return this.$useSoftTabs && position.column % this.$tabSize === 0;
        };
        EditSession2.prototype.setNavigateWithinSoftTabs = function(navigateWithinSoftTabs) {
          this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
        };
        EditSession2.prototype.getNavigateWithinSoftTabs = function() {
          return this.$navigateWithinSoftTabs;
        };
        EditSession2.prototype.setOverwrite = function(overwrite) {
          this.setOption("overwrite", overwrite);
        };
        EditSession2.prototype.getOverwrite = function() {
          return this.$overwrite;
        };
        EditSession2.prototype.toggleOverwrite = function() {
          this.setOverwrite(!this.$overwrite);
        };
        EditSession2.prototype.addGutterDecoration = function(row, className) {
          if (!this.$decorations[row])
            this.$decorations[row] = "";
          this.$decorations[row] += " " + className;
          this._signal("changeBreakpoint", {});
        };
        EditSession2.prototype.removeGutterCustomWidget = function(row) {
          if (this.$editor) {
            this.$editor.renderer.$gutterLayer.$removeCustomWidget(row);
          }
        };
        EditSession2.prototype.addGutterCustomWidget = function(row, attributes) {
          if (this.$editor) {
            this.$editor.renderer.$gutterLayer.$addCustomWidget(row, attributes);
          }
        };
        EditSession2.prototype.removeGutterDecoration = function(row, className) {
          this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
          this._signal("changeBreakpoint", {});
        };
        EditSession2.prototype.getBreakpoints = function() {
          return this.$breakpoints;
        };
        EditSession2.prototype.setBreakpoints = function(rows) {
          this.$breakpoints = [];
          for (var i = 0; i < rows.length; i++) {
            this.$breakpoints[rows[i]] = "ace_breakpoint";
          }
          this._signal("changeBreakpoint", {});
        };
        EditSession2.prototype.clearBreakpoints = function() {
          this.$breakpoints = [];
          this._signal("changeBreakpoint", {});
        };
        EditSession2.prototype.setBreakpoint = function(row, className) {
          if (className === void 0)
            className = "ace_breakpoint";
          if (className)
            this.$breakpoints[row] = className;
          else
            delete this.$breakpoints[row];
          this._signal("changeBreakpoint", {});
        };
        EditSession2.prototype.clearBreakpoint = function(row) {
          delete this.$breakpoints[row];
          this._signal("changeBreakpoint", {});
        };
        EditSession2.prototype.addMarker = function(range, clazz, type, inFront) {
          var id2 = this.$markerId++;
          var marker = {
            range,
            type: type || "line",
            renderer: typeof type == "function" ? type : null,
            clazz,
            inFront: !!inFront,
            id: id2
          };
          if (inFront) {
            this.$frontMarkers[id2] = marker;
            this._signal("changeFrontMarker");
          } else {
            this.$backMarkers[id2] = marker;
            this._signal("changeBackMarker");
          }
          return id2;
        };
        EditSession2.prototype.addDynamicMarker = function(marker, inFront) {
          if (!marker.update)
            return;
          var id2 = this.$markerId++;
          marker.id = id2;
          marker.inFront = !!inFront;
          if (inFront) {
            this.$frontMarkers[id2] = marker;
            this._signal("changeFrontMarker");
          } else {
            this.$backMarkers[id2] = marker;
            this._signal("changeBackMarker");
          }
          return marker;
        };
        EditSession2.prototype.removeMarker = function(markerId) {
          var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
          if (!marker)
            return;
          var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
          delete markers[markerId];
          this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
        };
        EditSession2.prototype.getMarkers = function(inFront) {
          return inFront ? this.$frontMarkers : this.$backMarkers;
        };
        EditSession2.prototype.highlight = function(re) {
          if (!this.$searchHighlight) {
            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
            this.$searchHighlight = this.addDynamicMarker(highlight);
          }
          this.$searchHighlight.setRegexp(re);
        };
        EditSession2.prototype.highlightLines = function(startRow, endRow, clazz, inFront) {
          if (typeof endRow != "number") {
            clazz = endRow;
            endRow = startRow;
          }
          if (!clazz)
            clazz = "ace_step";
          var range = new Range(startRow, 0, endRow, Infinity);
          range.id = this.addMarker(range, clazz, "fullLine", inFront);
          return range;
        };
        EditSession2.prototype.setAnnotations = function(annotations) {
          this.$annotations = annotations;
          this._signal("changeAnnotation", {});
        };
        EditSession2.prototype.getAnnotations = function() {
          return this.$annotations || [];
        };
        EditSession2.prototype.clearAnnotations = function() {
          this.setAnnotations([]);
        };
        EditSession2.prototype.$detectNewLine = function(text) {
          var match = text.match(/^.*?(\r?\n)/m);
          if (match) {
            this.$autoNewLine = match[1];
          } else {
            this.$autoNewLine = "\n";
          }
        };
        EditSession2.prototype.getWordRange = function(row, column) {
          var line = this.getLine(row);
          var inToken = false;
          if (column > 0)
            inToken = !!line.charAt(column - 1).match(this.tokenRe);
          if (!inToken)
            inToken = !!line.charAt(column).match(this.tokenRe);
          if (inToken)
            var re = this.tokenRe;
          else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
            var re = /\s/;
          else
            var re = this.nonTokenRe;
          var start = column;
          if (start > 0) {
            do {
              start--;
            } while (start >= 0 && line.charAt(start).match(re));
            start++;
          }
          var end = column;
          while (end < line.length && line.charAt(end).match(re)) {
            end++;
          }
          return new Range(row, start, row, end);
        };
        EditSession2.prototype.getAWordRange = function(row, column) {
          var wordRange = this.getWordRange(row, column);
          var line = this.getLine(wordRange.end.row);
          while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
            wordRange.end.column += 1;
          }
          return wordRange;
        };
        EditSession2.prototype.setNewLineMode = function(newLineMode) {
          this.doc.setNewLineMode(newLineMode);
        };
        EditSession2.prototype.getNewLineMode = function() {
          return this.doc.getNewLineMode();
        };
        EditSession2.prototype.setUseWorker = function(useWorker) {
          this.setOption("useWorker", useWorker);
        };
        EditSession2.prototype.getUseWorker = function() {
          return this.$useWorker;
        };
        EditSession2.prototype.onReloadTokenizer = function(e) {
          var rows = e.data;
          this.bgTokenizer.start(rows.first);
          this._signal("tokenizerUpdate", e);
        };
        EditSession2.prototype.setMode = function(mode, cb) {
          if (mode && typeof mode === "object") {
            if (mode.getTokenizer)
              return this.$onChangeMode(mode);
            var options = mode;
            var path = options.path;
          } else {
            path = /**@type{string}*/
            mode || "ace/mode/text";
          }
          if (!this.$modes["ace/mode/text"])
            this.$modes["ace/mode/text"] = new TextMode();
          if (this.$modes[path] && !options) {
            this.$onChangeMode(this.$modes[path]);
            cb && cb();
            return;
          }
          this.$modeId = path;
          config.loadModule(["mode", path], (function(m) {
            if (this.destroyed) {
              return;
            }
            if (this.$modeId !== path)
              return cb && cb();
            if (this.$modes[path] && !options) {
              this.$onChangeMode(this.$modes[path]);
            } else if (m && m.Mode) {
              m = new m.Mode(options);
              if (!options) {
                this.$modes[path] = m;
                m.$id = path;
              }
              this.$onChangeMode(m);
            }
            cb && cb();
          }).bind(this));
          if (!this.$mode)
            this.$onChangeMode(this.$modes["ace/mode/text"], true);
        };
        EditSession2.prototype.$onChangeMode = function(mode, $isPlaceholder) {
          if (!$isPlaceholder)
            this.$modeId = mode.$id;
          if (this.$mode === mode)
            return;
          var oldMode = this.$mode;
          this.$mode = mode;
          this.$stopWorker();
          if (this.$useWorker)
            this.$startWorker();
          var tokenizer = mode.getTokenizer();
          if (tokenizer.on !== void 0) {
            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
            tokenizer.on("update", onReloadTokenizer);
          }
          this.bgTokenizer.setTokenizer(tokenizer);
          this.bgTokenizer.setDocument(this.getDocument());
          this.tokenRe = mode.tokenRe;
          this.nonTokenRe = mode.nonTokenRe;
          if (!$isPlaceholder) {
            if (mode.attachToSession)
              mode.attachToSession(this);
            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
            this.$setFolding(mode.foldingRules);
            this.bgTokenizer.start(0);
            this._emit("changeMode", { oldMode, mode });
          }
        };
        EditSession2.prototype.$stopWorker = function() {
          if (this.$worker) {
            this.$worker.terminate();
            this.$worker = null;
          }
        };
        EditSession2.prototype.$startWorker = function() {
          try {
            this.$worker = this.$mode.createWorker(this);
          } catch (e) {
            config.warn("Could not load worker", e);
            this.$worker = null;
          }
        };
        EditSession2.prototype.getMode = function() {
          return this.$mode;
        };
        EditSession2.prototype.setScrollTop = function(scrollTop) {
          if (this.$scrollTop === scrollTop || isNaN(scrollTop))
            return;
          this.$scrollTop = scrollTop;
          this._signal("changeScrollTop", scrollTop);
        };
        EditSession2.prototype.getScrollTop = function() {
          return this.$scrollTop;
        };
        EditSession2.prototype.setScrollLeft = function(scrollLeft) {
          if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
            return;
          this.$scrollLeft = scrollLeft;
          this._signal("changeScrollLeft", scrollLeft);
        };
        EditSession2.prototype.getScrollLeft = function() {
          return this.$scrollLeft;
        };
        EditSession2.prototype.getScreenWidth = function() {
          this.$computeWidth();
          if (this.lineWidgets)
            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
          return this.screenWidth;
        };
        EditSession2.prototype.getLineWidgetMaxWidth = function() {
          if (this.lineWidgetsWidth != null)
            return this.lineWidgetsWidth;
          var width = 0;
          this.lineWidgets.forEach(function(w) {
            if (w && w.screenWidth > width)
              width = w.screenWidth;
          });
          return this.lineWidgetWidth = width;
        };
        EditSession2.prototype.$computeWidth = function(force) {
          if (this.$modified || force) {
            this.$modified = false;
            if (this.$useWrapMode)
              return this.screenWidth = this.$wrapLimit;
            var lines = this.doc.getAllLines();
            var cache = this.$rowLengthCache;
            var longestScreenLine = 0;
            var foldIndex = 0;
            var foldLine = this.$foldData[foldIndex];
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            var len = lines.length;
            for (var i = 0; i < len; i++) {
              if (i > foldStart) {
                i = foldLine.end.row + 1;
                if (i >= len)
                  break;
                foldLine = this.$foldData[foldIndex++];
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (cache[i] == null)
                cache[i] = this.$getStringScreenWidth(lines[i])[0];
              if (cache[i] > longestScreenLine)
                longestScreenLine = cache[i];
            }
            this.screenWidth = longestScreenLine;
          }
        };
        EditSession2.prototype.getLine = function(row) {
          return this.doc.getLine(row);
        };
        EditSession2.prototype.getLines = function(firstRow, lastRow) {
          return this.doc.getLines(firstRow, lastRow);
        };
        EditSession2.prototype.getLength = function() {
          return this.doc.getLength();
        };
        EditSession2.prototype.getTextRange = function(range) {
          return this.doc.getTextRange(range || this.selection.getRange());
        };
        EditSession2.prototype.insert = function(position, text) {
          return this.doc.insert(position, text);
        };
        EditSession2.prototype.remove = function(range) {
          return this.doc.remove(range);
        };
        EditSession2.prototype.removeFullLines = function(firstRow, lastRow) {
          return this.doc.removeFullLines(firstRow, lastRow);
        };
        EditSession2.prototype.undoChanges = function(deltas, dontSelect) {
          if (!deltas.length)
            return;
          this.$fromUndo = true;
          for (var i = deltas.length - 1; i != -1; i--) {
            var delta = deltas[i];
            if (delta.action == "insert" || delta.action == "remove") {
              this.doc.revertDelta(delta);
            } else if (delta.folds) {
              this.addFolds(delta.folds);
            }
          }
          if (!dontSelect && this.$undoSelect) {
            if (deltas.selectionBefore)
              this.selection.fromJSON(deltas.selectionBefore);
            else
              this.selection.setRange(this.$getUndoSelection(deltas, true));
          }
          this.$fromUndo = false;
        };
        EditSession2.prototype.redoChanges = function(deltas, dontSelect) {
          if (!deltas.length)
            return;
          this.$fromUndo = true;
          for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (delta.action == "insert" || delta.action == "remove") {
              this.doc.$safeApplyDelta(delta);
            }
          }
          if (!dontSelect && this.$undoSelect) {
            if (deltas.selectionAfter)
              this.selection.fromJSON(deltas.selectionAfter);
            else
              this.selection.setRange(this.$getUndoSelection(deltas, false));
          }
          this.$fromUndo = false;
        };
        EditSession2.prototype.setUndoSelect = function(enable) {
          this.$undoSelect = enable;
        };
        EditSession2.prototype.$getUndoSelection = function(deltas, isUndo) {
          function isInsert(delta2) {
            return isUndo ? delta2.action !== "insert" : delta2.action === "insert";
          }
          var range, point;
          for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (!delta.start)
              continue;
            if (!range) {
              if (isInsert(delta)) {
                range = Range.fromPoints(delta.start, delta.end);
              } else {
                range = Range.fromPoints(delta.start, delta.start);
              }
              continue;
            }
            if (isInsert(delta)) {
              point = delta.start;
              if (range.compare(point.row, point.column) == -1) {
                range.setStart(point);
              }
              point = delta.end;
              if (range.compare(point.row, point.column) == 1) {
                range.setEnd(point);
              }
            } else {
              point = delta.start;
              if (range.compare(point.row, point.column) == -1) {
                range = Range.fromPoints(delta.start, delta.start);
              }
            }
          }
          return range;
        };
        EditSession2.prototype.replace = function(range, text) {
          return this.doc.replace(range, text);
        };
        EditSession2.prototype.moveText = function(fromRange, toPosition, copy) {
          var text = this.getTextRange(fromRange);
          var folds = this.getFoldsInRange(fromRange);
          var toRange = Range.fromPoints(toPosition, toPosition);
          if (!copy) {
            this.remove(fromRange);
            var rowDiff = fromRange.start.row - fromRange.end.row;
            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
            if (collDiff) {
              if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                toRange.start.column += collDiff;
              if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                toRange.end.column += collDiff;
            }
            if (rowDiff && toRange.start.row >= fromRange.end.row) {
              toRange.start.row += rowDiff;
              toRange.end.row += rowDiff;
            }
          }
          toRange.end = this.insert(toRange.start, text);
          if (folds.length) {
            var oldStart = fromRange.start;
            var newStart = toRange.start;
            var rowDiff = newStart.row - oldStart.row;
            var collDiff = newStart.column - oldStart.column;
            this.addFolds(folds.map(function(x) {
              x = x.clone();
              if (x.start.row == oldStart.row)
                x.start.column += collDiff;
              if (x.end.row == oldStart.row)
                x.end.column += collDiff;
              x.start.row += rowDiff;
              x.end.row += rowDiff;
              return x;
            }));
          }
          return toRange;
        };
        EditSession2.prototype.indentRows = function(startRow, endRow, indentString) {
          indentString = indentString.replace(/\t/g, this.getTabString());
          for (var row = startRow; row <= endRow; row++)
            this.doc.insertInLine({ row, column: 0 }, indentString);
        };
        EditSession2.prototype.outdentRows = function(range) {
          var rowRange = range.collapseRows();
          var deleteRange = new Range(0, 0, 0, 0);
          var size = this.getTabSize();
          for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
            var line = this.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            for (var j = 0; j < size; ++j)
              if (line.charAt(j) != " ")
                break;
            if (j < size && line.charAt(j) == "	") {
              deleteRange.start.column = j;
              deleteRange.end.column = j + 1;
            } else {
              deleteRange.start.column = 0;
              deleteRange.end.column = j;
            }
            this.remove(deleteRange);
          }
        };
        EditSession2.prototype.$moveLines = function(firstRow, lastRow, dir) {
          firstRow = this.getRowFoldStart(firstRow);
          lastRow = this.getRowFoldEnd(lastRow);
          if (dir < 0) {
            var row = this.getRowFoldStart(firstRow + dir);
            if (row < 0)
              return 0;
            var diff = row - firstRow;
          } else if (dir > 0) {
            var row = this.getRowFoldEnd(lastRow + dir);
            if (row > this.doc.getLength() - 1)
              return 0;
            var diff = row - lastRow;
          } else {
            firstRow = this.$clipRowToDocument(firstRow);
            lastRow = this.$clipRowToDocument(lastRow);
            var diff = lastRow - firstRow + 1;
          }
          var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
          var folds = this.getFoldsInRange(range).map(function(x) {
            x = x.clone();
            x.start.row += diff;
            x.end.row += diff;
            return x;
          });
          var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeFullLines(firstRow, lastRow);
          this.doc.insertFullLines(firstRow + diff, lines);
          folds.length && this.addFolds(folds);
          return diff;
        };
        EditSession2.prototype.moveLinesUp = function(firstRow, lastRow) {
          return this.$moveLines(firstRow, lastRow, -1);
        };
        EditSession2.prototype.moveLinesDown = function(firstRow, lastRow) {
          return this.$moveLines(firstRow, lastRow, 1);
        };
        EditSession2.prototype.duplicateLines = function(firstRow, lastRow) {
          return this.$moveLines(firstRow, lastRow, 0);
        };
        EditSession2.prototype.$clipRowToDocument = function(row) {
          return Math.max(0, Math.min(row, this.doc.getLength() - 1));
        };
        EditSession2.prototype.$clipColumnToRow = function(row, column) {
          if (column < 0)
            return 0;
          return Math.min(this.doc.getLine(row).length, column);
        };
        EditSession2.prototype.$clipPositionToDocument = function(row, column) {
          column = Math.max(0, column);
          if (row < 0) {
            row = 0;
            column = 0;
          } else {
            var len = this.doc.getLength();
            if (row >= len) {
              row = len - 1;
              column = this.doc.getLine(len - 1).length;
            } else {
              column = Math.min(this.doc.getLine(row).length, column);
            }
          }
          return {
            row,
            column
          };
        };
        EditSession2.prototype.$clipRangeToDocument = function(range) {
          if (range.start.row < 0) {
            range.start.row = 0;
            range.start.column = 0;
          } else {
            range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
          }
          var len = this.doc.getLength() - 1;
          if (range.end.row > len) {
            range.end.row = len;
            range.end.column = this.doc.getLine(len).length;
          } else {
            range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
          }
          return range;
        };
        EditSession2.prototype.setUseWrapMode = function(useWrapMode) {
          if (useWrapMode != this.$useWrapMode) {
            this.$useWrapMode = useWrapMode;
            this.$modified = true;
            this.$resetRowCache(0);
            if (useWrapMode) {
              var len = this.getLength();
              this.$wrapData = Array(len);
              this.$updateWrapData(0, len - 1);
            }
            this._signal("changeWrapMode");
          }
        };
        EditSession2.prototype.getUseWrapMode = function() {
          return this.$useWrapMode;
        };
        EditSession2.prototype.setWrapLimitRange = function(min, max) {
          if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
            this.$wrapLimitRange = { min, max };
            this.$modified = true;
            this.$bidiHandler.markAsDirty();
            if (this.$useWrapMode)
              this._signal("changeWrapMode");
          }
        };
        EditSession2.prototype.adjustWrapLimit = function(desiredLimit, $printMargin) {
          var limits = this.$wrapLimitRange;
          if (limits.max < 0)
            limits = { min: $printMargin, max: $printMargin };
          var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
          if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
            this.$wrapLimit = wrapLimit;
            this.$modified = true;
            if (this.$useWrapMode) {
              this.$updateWrapData(0, this.getLength() - 1);
              this.$resetRowCache(0);
              this._signal("changeWrapLimit");
            }
            return true;
          }
          return false;
        };
        EditSession2.prototype.$constrainWrapLimit = function(wrapLimit, min, max) {
          if (min)
            wrapLimit = Math.max(min, wrapLimit);
          if (max)
            wrapLimit = Math.min(max, wrapLimit);
          return wrapLimit;
        };
        EditSession2.prototype.getWrapLimit = function() {
          return this.$wrapLimit;
        };
        EditSession2.prototype.setWrapLimit = function(limit) {
          this.setWrapLimitRange(limit, limit);
        };
        EditSession2.prototype.getWrapLimitRange = function() {
          return {
            min: this.$wrapLimitRange.min,
            max: this.$wrapLimitRange.max
          };
        };
        EditSession2.prototype.$updateInternalDataOnChange = function(delta) {
          var useWrapMode = this.$useWrapMode;
          var action = delta.action;
          var start = delta.start;
          var end = delta.end;
          var firstRow = start.row;
          var lastRow = end.row;
          var len = lastRow - firstRow;
          var removedFolds = null;
          this.$updating = true;
          if (len != 0) {
            if (action === "remove") {
              this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
              var foldLines = this.$foldData;
              removedFolds = this.getFoldsInRange(delta);
              this.removeFolds(removedFolds);
              var foldLine = this.getFoldLine(end.row);
              var idx = 0;
              if (foldLine) {
                foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                foldLine.shiftRow(-len);
                var foldLineBefore = this.getFoldLine(firstRow);
                if (foldLineBefore && foldLineBefore !== foldLine) {
                  foldLineBefore.merge(foldLine);
                  foldLine = foldLineBefore;
                }
                idx = foldLines.indexOf(foldLine) + 1;
              }
              for (idx; idx < foldLines.length; idx++) {
                var foldLine = foldLines[idx];
                if (foldLine.start.row >= end.row) {
                  foldLine.shiftRow(-len);
                }
              }
              lastRow = firstRow;
            } else {
              var args = Array(len);
              args.unshift(firstRow, 0);
              var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
              arr.splice.apply(arr, args);
              var foldLines = this.$foldData;
              var foldLine = this.getFoldLine(firstRow);
              var idx = 0;
              if (foldLine) {
                var cmp = foldLine.range.compareInside(start.row, start.column);
                if (cmp == 0) {
                  foldLine = foldLine.split(start.row, start.column);
                  if (foldLine) {
                    foldLine.shiftRow(len);
                    foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                  }
                } else if (cmp == -1) {
                  foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                  foldLine.shiftRow(len);
                }
                idx = foldLines.indexOf(foldLine) + 1;
              }
              for (idx; idx < foldLines.length; idx++) {
                var foldLine = foldLines[idx];
                if (foldLine.start.row >= firstRow) {
                  foldLine.shiftRow(len);
                }
              }
            }
          } else {
            len = Math.abs(delta.start.column - delta.end.column);
            if (action === "remove") {
              removedFolds = this.getFoldsInRange(delta);
              this.removeFolds(removedFolds);
              len = -len;
            }
            var foldLine = this.getFoldLine(firstRow);
            if (foldLine) {
              foldLine.addRemoveChars(firstRow, start.column, len);
            }
          }
          if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
            console.error("doc.getLength() and $wrapData.length have to be the same!");
          }
          this.$updating = false;
          if (useWrapMode)
            this.$updateWrapData(firstRow, lastRow);
          else
            this.$updateRowLengthCache(firstRow, lastRow);
          return removedFolds;
        };
        EditSession2.prototype.$updateRowLengthCache = function(firstRow, lastRow) {
          this.$rowLengthCache[firstRow] = null;
          this.$rowLengthCache[lastRow] = null;
        };
        EditSession2.prototype.$updateWrapData = function(firstRow, lastRow) {
          var lines = this.doc.getAllLines();
          var tabSize = this.getTabSize();
          var wrapData = this.$wrapData;
          var wrapLimit = this.$wrapLimit;
          var tokens;
          var foldLine;
          var row = firstRow;
          lastRow = Math.min(lastRow, lines.length - 1);
          while (row <= lastRow) {
            foldLine = this.getFoldLine(row, foldLine);
            if (!foldLine) {
              tokens = this.$getDisplayTokens(lines[row]);
              wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
              row++;
            } else {
              tokens = [];
              foldLine.walk((function(placeholder, row2, column, lastColumn) {
                var walkTokens;
                if (placeholder != null) {
                  walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                  walkTokens[0] = PLACEHOLDER_START;
                  for (var i = 1; i < walkTokens.length; i++) {
                    walkTokens[i] = PLACEHOLDER_BODY;
                  }
                } else {
                  walkTokens = this.$getDisplayTokens(lines[row2].substring(lastColumn, column), tokens.length);
                }
                tokens = tokens.concat(walkTokens);
              }).bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
              wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
              row = foldLine.end.row + 1;
            }
          }
        };
        EditSession2.prototype.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
          if (tokens.length == 0) {
            return [];
          }
          var splits = [];
          var displayLength = tokens.length;
          var lastSplit = 0, lastDocSplit = 0;
          var isCode = this.$wrapAsCode;
          var indentedSoftWrap = this.$indentedSoftWrap;
          var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8) || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
          function getWrapIndent() {
            var indentation = 0;
            if (maxIndent === 0)
              return indentation;
            if (indentedSoftWrap) {
              for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if (token == SPACE)
                  indentation += 1;
                else if (token == TAB)
                  indentation += tabSize;
                else if (token == TAB_SPACE)
                  continue;
                else
                  break;
              }
            }
            if (isCode && indentedSoftWrap !== false)
              indentation += tabSize;
            return Math.min(indentation, maxIndent);
          }
          function addSplit(screenPos) {
            var len = screenPos - lastSplit;
            for (var i = lastSplit; i < screenPos; i++) {
              var ch = tokens[i];
              if (ch === 12 || ch === 2)
                len -= 1;
            }
            if (!splits.length) {
              indent = getWrapIndent();
              splits.indent = indent;
            }
            lastDocSplit += len;
            splits.push(lastDocSplit);
            lastSplit = screenPos;
          }
          var indent = 0;
          while (displayLength - lastSplit > wrapLimit - indent) {
            var split = lastSplit + wrapLimit - indent;
            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
              addSplit(split);
              continue;
            }
            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
              for (split; split != lastSplit - 1; split--) {
                if (tokens[split] == PLACEHOLDER_START) {
                  break;
                }
              }
              if (split > lastSplit) {
                addSplit(split);
                continue;
              }
              split = lastSplit + wrapLimit;
              for (split; split < tokens.length; split++) {
                if (tokens[split] != PLACEHOLDER_BODY) {
                  break;
                }
              }
              if (split == tokens.length) {
                break;
              }
              addSplit(split);
              continue;
            }
            var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
              split--;
            }
            if (isCode) {
              while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split--;
              }
              while (split > minSplit && tokens[split] == PUNCTUATION) {
                split--;
              }
            } else {
              while (split > minSplit && tokens[split] < SPACE) {
                split--;
              }
            }
            if (split > minSplit) {
              addSplit(++split);
              continue;
            }
            split = lastSplit + wrapLimit;
            if (tokens[split] == CHAR_EXT)
              split--;
            addSplit(split - indent);
          }
          return splits;
        };
        EditSession2.prototype.$getDisplayTokens = function(str, offset) {
          var arr = [];
          var tabSize;
          offset = offset || 0;
          for (var i = 0; i < str.length; i++) {
            var c = str.charCodeAt(i);
            if (c == 9) {
              tabSize = this.getScreenTabSize(arr.length + offset);
              arr.push(TAB);
              for (var n = 1; n < tabSize; n++) {
                arr.push(TAB_SPACE);
              }
            } else if (c == 32) {
              arr.push(SPACE);
            } else if (c > 39 && c < 48 || c > 57 && c < 64) {
              arr.push(PUNCTUATION);
            } else if (c >= 4352 && isFullWidth(c)) {
              arr.push(CHAR, CHAR_EXT);
            } else {
              arr.push(CHAR);
            }
          }
          return arr;
        };
        EditSession2.prototype.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
          if (maxScreenColumn == 0)
            return [0, 0];
          if (maxScreenColumn == null)
            maxScreenColumn = Infinity;
          screenColumn = screenColumn || 0;
          var c, column;
          for (column = 0; column < str.length; column++) {
            c = str.charCodeAt(column);
            if (c == 9) {
              screenColumn += this.getScreenTabSize(screenColumn);
            } else if (c >= 4352 && isFullWidth(c)) {
              screenColumn += 2;
            } else {
              screenColumn += 1;
            }
            if (screenColumn > maxScreenColumn) {
              break;
            }
          }
          return [screenColumn, column];
        };
        EditSession2.prototype.getRowLength = function(row) {
          var h = 1;
          if (this.lineWidgets)
            h += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
          if (!this.$useWrapMode || !this.$wrapData[row])
            return h;
          else
            return this.$wrapData[row].length + h;
        };
        EditSession2.prototype.getRowLineCount = function(row) {
          if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1;
          } else {
            return this.$wrapData[row].length + 1;
          }
        };
        EditSession2.prototype.getRowWrapIndent = function(screenRow) {
          if (this.$useWrapMode) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            var splits = this.$wrapData[pos.row];
            return splits.length && splits[0] < pos.column ? splits.indent : 0;
          } else {
            return 0;
          }
        };
        EditSession2.prototype.getScreenLastRowColumn = function(screenRow) {
          var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
          return this.documentToScreenColumn(pos.row, pos.column);
        };
        EditSession2.prototype.getDocumentLastRowColumn = function(docRow, docColumn) {
          var screenRow = this.documentToScreenRow(docRow, docColumn);
          return this.getScreenLastRowColumn(screenRow);
        };
        EditSession2.prototype.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
          var screenRow = this.documentToScreenRow(docRow, docColumn);
          return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
        };
        EditSession2.prototype.getRowSplitData = function(row) {
          if (!this.$useWrapMode) {
            return void 0;
          } else {
            return this.$wrapData[row];
          }
        };
        EditSession2.prototype.getScreenTabSize = function(screenColumn) {
          return this.$tabSize - (screenColumn % this.$tabSize | 0);
        };
        EditSession2.prototype.screenToDocumentRow = function(screenRow, screenColumn) {
          return this.screenToDocumentPosition(screenRow, screenColumn).row;
        };
        EditSession2.prototype.screenToDocumentColumn = function(screenRow, screenColumn) {
          return this.screenToDocumentPosition(screenRow, screenColumn).column;
        };
        EditSession2.prototype.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {
          if (screenRow < 0)
            return { row: 0, column: 0 };
          var line;
          var docRow = 0;
          var docColumn = 0;
          var column;
          var row = 0;
          var rowLength = 0;
          var rowCache = this.$screenRowCache;
          var i = this.$getRowCacheIndex(rowCache, screenRow);
          var l = rowCache.length;
          if (l && i >= 0) {
            var row = rowCache[i];
            var docRow = this.$docRowCache[i];
            var doCache = screenRow > rowCache[l - 1];
          } else {
            var doCache = !l;
          }
          var maxRow = this.getLength() - 1;
          var foldLine = this.getNextFoldLine(docRow);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (row <= screenRow) {
            rowLength = this.getRowLength(docRow);
            if (row + rowLength > screenRow || docRow >= maxRow) {
              break;
            } else {
              row += rowLength;
              docRow++;
              if (docRow > foldStart) {
                docRow = foldLine.end.row + 1;
                foldLine = this.getNextFoldLine(docRow, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
            }
            if (doCache) {
              this.$docRowCache.push(docRow);
              this.$screenRowCache.push(row);
            }
          }
          if (foldLine && foldLine.start.row <= docRow) {
            line = this.getFoldDisplayLine(foldLine);
            docRow = foldLine.start.row;
          } else if (row + rowLength <= screenRow || docRow > maxRow) {
            return {
              row: maxRow,
              column: this.getLine(maxRow).length
            };
          } else {
            line = this.getLine(docRow);
            foldLine = null;
          }
          var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
          if (this.$useWrapMode) {
            var splits = this.$wrapData[docRow];
            if (splits) {
              column = splits[splitIndex];
              if (splitIndex > 0 && splits.length) {
                wrapIndent = splits.indent;
                docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                line = line.substring(docColumn);
              }
            }
          }
          if (offsetX !== void 0 && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
            screenColumn = this.$bidiHandler.offsetToCol(offsetX);
          docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
          if (this.$useWrapMode && docColumn >= column)
            docColumn = column - 1;
          if (foldLine)
            return foldLine.idxToPosition(docColumn);
          return { row: docRow, column: docColumn };
        };
        EditSession2.prototype.documentToScreenPosition = function(docRow, docColumn) {
          if (typeof docColumn === "undefined")
            var pos = this.$clipPositionToDocument(
              /**@type{Point}*/
              docRow.row,
              /**@type{Point}*/
              docRow.column
            );
          else
            pos = this.$clipPositionToDocument(
              /**@type{number}*/
              docRow,
              docColumn
            );
          docRow = pos.row;
          docColumn = pos.column;
          var screenRow = 0;
          var foldStartRow = null;
          var fold = null;
          fold = this.getFoldAt(docRow, docColumn, 1);
          if (fold) {
            docRow = fold.start.row;
            docColumn = fold.start.column;
          }
          var rowEnd, row = 0;
          var rowCache = this.$docRowCache;
          var i = this.$getRowCacheIndex(rowCache, docRow);
          var l = rowCache.length;
          if (l && i >= 0) {
            var row = rowCache[i];
            var screenRow = this.$screenRowCache[i];
            var doCache = docRow > rowCache[l - 1];
          } else {
            var doCache = !l;
          }
          var foldLine = this.getNextFoldLine(row);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (row < docRow) {
            if (row >= foldStart) {
              rowEnd = foldLine.end.row + 1;
              if (rowEnd > docRow)
                break;
              foldLine = this.getNextFoldLine(rowEnd, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            } else {
              rowEnd = row + 1;
            }
            screenRow += this.getRowLength(row);
            row = rowEnd;
            if (doCache) {
              this.$docRowCache.push(row);
              this.$screenRowCache.push(screenRow);
            }
          }
          var textLine = "";
          if (foldLine && row >= foldStart) {
            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
            foldStartRow = foldLine.start.row;
          } else {
            textLine = this.getLine(docRow).substring(0, docColumn);
            foldStartRow = docRow;
          }
          var wrapIndent = 0;
          if (this.$useWrapMode) {
            var wrapRow = this.$wrapData[foldStartRow];
            if (wrapRow) {
              var screenRowOffset = 0;
              while (textLine.length >= wrapRow[screenRowOffset]) {
                screenRow++;
                screenRowOffset++;
              }
              textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
              wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
            }
          }
          if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)
            screenRow += this.lineWidgets[row].rowsAbove;
          return {
            row: screenRow,
            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
          };
        };
        EditSession2.prototype.documentToScreenColumn = function(row, docColumn) {
          return this.documentToScreenPosition(row, docColumn).column;
        };
        EditSession2.prototype.documentToScreenRow = function(docRow, docColumn) {
          return this.documentToScreenPosition(docRow, docColumn).row;
        };
        EditSession2.prototype.getScreenLength = function() {
          var screenRows = 0;
          var fold = null;
          if (!this.$useWrapMode) {
            screenRows = this.getLength();
            var foldData = this.$foldData;
            for (var i = 0; i < foldData.length; i++) {
              fold = foldData[i];
              screenRows -= fold.end.row - fold.start.row;
            }
          } else {
            var lastRow = this.$wrapData.length;
            var row = 0, i = 0;
            var fold = this.$foldData[i++];
            var foldStart = fold ? fold.start.row : Infinity;
            while (row < lastRow) {
              var splits = this.$wrapData[row];
              screenRows += splits ? splits.length + 1 : 1;
              row++;
              if (row > foldStart) {
                row = fold.end.row + 1;
                fold = this.$foldData[i++];
                foldStart = fold ? fold.start.row : Infinity;
              }
            }
          }
          if (this.lineWidgets)
            screenRows += this.$getWidgetScreenLength();
          return screenRows;
        };
        EditSession2.prototype.$setFontMetrics = function(fm) {
          if (!this.$enableVarChar)
            return;
          this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn === 0)
              return [0, 0];
            if (!maxScreenColumn)
              maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;
            var c, column;
            for (column = 0; column < str.length; column++) {
              c = str.charAt(column);
              if (c === "	") {
                screenColumn += this.getScreenTabSize(screenColumn);
              } else {
                screenColumn += fm.getCharacterWidth(c);
              }
              if (screenColumn > maxScreenColumn) {
                break;
              }
            }
            return [screenColumn, column];
          };
        };
        EditSession2.prototype.getPrecedingCharacter = function() {
          var pos = this.selection.getCursor();
          if (pos.column === 0) {
            return pos.row === 0 ? "" : this.doc.getNewLineCharacter();
          }
          var currentLine = this.getLine(pos.row);
          return currentLine[pos.column - 1];
        };
        EditSession2.prototype.destroy = function() {
          if (!this.destroyed) {
            this.bgTokenizer.setDocument(null);
            this.bgTokenizer.cleanup();
            this.destroyed = true;
          }
          this.endOperation();
          this.$stopWorker();
          this.removeAllListeners();
          if (this.doc) {
            this.doc.off("change", this.$onChange);
          }
          if (this.selection) {
            this.selection.off("changeCursor", this.$onSelectionChange);
            this.selection.off("changeSelection", this.$onSelectionChange);
          }
          this.selection.detach();
        };
        return EditSession2;
      }()
    );
    EditSession.$uid = 0;
    EditSession.prototype.$modes = config.$modes;
    EditSession.prototype.getValue = EditSession.prototype.toString;
    EditSession.prototype.$defaultUndoManager = {
      undo: function() {
      },
      redo: function() {
      },
      hasUndo: function() {
      },
      hasRedo: function() {
      },
      reset: function() {
      },
      add: function() {
      },
      addSelection: function() {
      },
      startNewGroup: function() {
      },
      addSession: function() {
      }
    };
    EditSession.prototype.$overwrite = false;
    EditSession.prototype.$mode = null;
    EditSession.prototype.$modeId = null;
    EditSession.prototype.$scrollTop = 0;
    EditSession.prototype.$scrollLeft = 0;
    EditSession.prototype.$wrapLimit = 80;
    EditSession.prototype.$useWrapMode = false;
    EditSession.prototype.$wrapLimitRange = {
      min: null,
      max: null
    };
    EditSession.prototype.lineWidgets = null;
    EditSession.prototype.isFullWidth = isFullWidth;
    oop.implement(EditSession.prototype, EventEmitter);
    var CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;
    function isFullWidth(c) {
      if (c < 4352)
        return false;
      return c >= 4352 && c <= 4447 || c >= 4515 && c <= 4519 || c >= 4602 && c <= 4607 || c >= 9001 && c <= 9002 || c >= 11904 && c <= 11929 || c >= 11931 && c <= 12019 || c >= 12032 && c <= 12245 || c >= 12272 && c <= 12283 || c >= 12288 && c <= 12350 || c >= 12353 && c <= 12438 || c >= 12441 && c <= 12543 || c >= 12549 && c <= 12589 || c >= 12593 && c <= 12686 || c >= 12688 && c <= 12730 || c >= 12736 && c <= 12771 || c >= 12784 && c <= 12830 || c >= 12832 && c <= 12871 || c >= 12880 && c <= 13054 || c >= 13056 && c <= 19903 || c >= 19968 && c <= 42124 || c >= 42128 && c <= 42182 || c >= 43360 && c <= 43388 || c >= 44032 && c <= 55203 || c >= 55216 && c <= 55238 || c >= 55243 && c <= 55291 || c >= 63744 && c <= 64255 || c >= 65040 && c <= 65049 || c >= 65072 && c <= 65106 || c >= 65108 && c <= 65126 || c >= 65128 && c <= 65131 || c >= 65281 && c <= 65376 || c >= 65504 && c <= 65510;
    }
    require2("./edit_session/folding").Folding.call(EditSession.prototype);
    require2("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);
    config.defineOptions(EditSession.prototype, "session", {
      wrap: {
        set: function(value) {
          if (!value || value == "off")
            value = false;
          else if (value == "free")
            value = true;
          else if (value == "printMargin")
            value = -1;
          else if (typeof value == "string")
            value = parseInt(value, 10) || false;
          if (this.$wrap == value)
            return;
          this.$wrap = value;
          if (!value) {
            this.setUseWrapMode(false);
          } else {
            var col = typeof value == "number" ? value : null;
            this.setWrapLimitRange(col, col);
            this.setUseWrapMode(true);
          }
        },
        get: function() {
          if (this.getUseWrapMode()) {
            if (this.$wrap == -1)
              return "printMargin";
            if (!this.getWrapLimitRange().min)
              return "free";
            return this.$wrap;
          }
          return "off";
        },
        handlesSet: true
      },
      wrapMethod: {
        set: function(val) {
          val = val == "auto" ? this.$mode.type != "text" : val != "text";
          if (val != this.$wrapAsCode) {
            this.$wrapAsCode = val;
            if (this.$useWrapMode) {
              this.$useWrapMode = false;
              this.setUseWrapMode(true);
            }
          }
        },
        initialValue: "auto"
      },
      indentedSoftWrap: {
        set: function() {
          if (this.$useWrapMode) {
            this.$useWrapMode = false;
            this.setUseWrapMode(true);
          }
        },
        initialValue: true
      },
      firstLineNumber: {
        set: function() {
          this._signal("changeBreakpoint");
        },
        initialValue: 1
      },
      useWorker: {
        set: function(useWorker) {
          this.$useWorker = useWorker;
          this.$stopWorker();
          if (useWorker)
            this.$startWorker();
        },
        initialValue: true
      },
      useSoftTabs: { initialValue: true },
      tabSize: {
        set: function(tabSize) {
          tabSize = parseInt(tabSize);
          if (tabSize > 0 && this.$tabSize !== tabSize) {
            this.$modified = true;
            this.$rowLengthCache = [];
            this.$tabSize = tabSize;
            this._signal("changeTabSize");
          }
        },
        initialValue: 4,
        handlesSet: true
      },
      navigateWithinSoftTabs: { initialValue: false },
      foldStyle: {
        set: function(val) {
          this.setFoldStyle(val);
        },
        handlesSet: true
      },
      overwrite: {
        set: function(val) {
          this._signal("changeOverwrite");
        },
        initialValue: false
      },
      newLineMode: {
        set: function(val) {
          this.doc.setNewLineMode(val);
        },
        get: function() {
          return this.doc.getNewLineMode();
        },
        handlesSet: true
      },
      mode: {
        set: function(val) {
          this.setMode(val);
        },
        get: function() {
          return this.$modeId;
        },
        handlesSet: true
      }
    });
    exports2.EditSession = EditSession;
  });
  ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(require2, exports2, module2) {
    var lang = require2("./lib/lang");
    var oop = require2("./lib/oop");
    var Range = require2("./range").Range;
    var Search = (
      /** @class */
      function() {
        function Search2() {
          this.$options = {};
        }
        Search2.prototype.set = function(options) {
          oop.mixin(this.$options, options);
          return this;
        };
        Search2.prototype.getOptions = function() {
          return lang.copyObject(this.$options);
        };
        Search2.prototype.setOptions = function(options) {
          this.$options = options;
        };
        Search2.prototype.find = function(session) {
          var options = this.$options;
          var iterator = this.$matchIterator(session, options);
          if (!iterator)
            return false;
          var firstRange = null;
          iterator.forEach(function(sr, sc, er, ec) {
            firstRange = new Range(sr, sc, er, ec);
            if (sc == ec && options.start && /**@type{Range}*/
            options.start.start && options.skipCurrent != false && firstRange.isEqual(
              /**@type{Range}*/
              options.start
            )) {
              firstRange = null;
              return false;
            }
            return true;
          });
          return firstRange;
        };
        Search2.prototype.findAll = function(session) {
          var options = this.$options;
          if (!options.needle)
            return [];
          this.$assembleRegExp(options);
          var range = options.range;
          var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();
          var ranges = [];
          var re = options.re;
          if (options.$isMultiLine) {
            var len = re.length;
            var maxRow = lines.length - len;
            var prevRange;
            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
              for (var j = 0; j < len; j++)
                if (lines[row + j].search(re[j]) == -1)
                  continue outer;
              var startLine = lines[row];
              var line = lines[row + len - 1];
              var startIndex = startLine.length - startLine.match(re[0])[0].length;
              var endIndex = line.match(re[len - 1])[0].length;
              if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
                continue;
              }
              ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
              if (len > 2)
                row = row + len - 2;
            }
          } else {
            for (var matches, i = 0; i < lines.length; i++) {
              if (this.$isMultilineSearch(options)) {
                var lng = lines.length - 1;
                matches = this.$multiLineForward(session, re, i, lng);
                if (matches) {
                  var end_row = matches.endRow <= lng ? matches.endRow - 1 : lng;
                  if (end_row > i)
                    i = end_row;
                  ranges.push(new Range(matches.startRow, matches.startCol, matches.endRow, matches.endCol));
                }
              } else {
                matches = lang.getMatchOffsets(lines[i], re);
                for (var j = 0; j < matches.length; j++) {
                  var match = matches[j];
                  ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                }
              }
            }
          }
          if (range) {
            var startColumn = range.start.column;
            var endColumn = range.end.column;
            var i = 0, j = ranges.length - 1;
            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == 0)
              i++;
            var endRow = range.end.row - range.start.row;
            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == endRow)
              j--;
            ranges = ranges.slice(i, j + 1);
            for (i = 0, j = ranges.length; i < j; i++) {
              ranges[i].start.row += range.start.row;
              ranges[i].end.row += range.start.row;
            }
          }
          return ranges;
        };
        Search2.prototype.parseReplaceString = function(replaceString) {
          var CharCode = {
            DollarSign: 36,
            Ampersand: 38,
            Digit0: 48,
            Digit1: 49,
            Digit9: 57,
            Backslash: 92,
            n: 110,
            t: 116
          };
          var replacement = "";
          for (var i = 0, len = replaceString.length; i < len; i++) {
            var chCode = replaceString.charCodeAt(i);
            if (chCode === CharCode.Backslash) {
              i++;
              if (i >= len) {
                replacement += "\\";
                break;
              }
              var nextChCode = replaceString.charCodeAt(i);
              switch (nextChCode) {
                case CharCode.Backslash:
                  replacement += "\\";
                  break;
                case CharCode.n:
                  replacement += "\n";
                  break;
                case CharCode.t:
                  replacement += "	";
                  break;
              }
              continue;
            }
            if (chCode === CharCode.DollarSign) {
              i++;
              if (i >= len) {
                replacement += "$";
                break;
              }
              var nextChCode_1 = replaceString.charCodeAt(i);
              if (nextChCode_1 === CharCode.DollarSign) {
                replacement += "$$";
                continue;
              }
              if (nextChCode_1 === CharCode.Digit0 || nextChCode_1 === CharCode.Ampersand) {
                replacement += "$&";
                continue;
              }
              if (CharCode.Digit1 <= nextChCode_1 && nextChCode_1 <= CharCode.Digit9) {
                replacement += "$" + replaceString[i];
                continue;
              }
            }
            replacement += replaceString[i];
          }
          return replacement || replaceString;
        };
        Search2.prototype.replace = function(input, replacement) {
          var options = this.$options;
          var re = this.$assembleRegExp(options);
          if (options.$isMultiLine)
            return replacement;
          if (!re)
            return;
          var mtSearch = this.$isMultilineSearch(options);
          if (mtSearch)
            input = input.replace(/\r\n|\r|\n/g, "\n");
          var match = re.exec(input);
          if (!match || !mtSearch && match[0].length != input.length)
            return null;
          replacement = options.regExp ? this.parseReplaceString(replacement) : replacement.replace(/\$/g, "$$$$");
          replacement = input.replace(re, replacement);
          if (options.preserveCase) {
            replacement = replacement.split("");
            for (var i = Math.min(input.length, input.length); i--; ) {
              var ch = input[i];
              if (ch && ch.toLowerCase() != ch)
                replacement[i] = replacement[i].toUpperCase();
              else
                replacement[i] = replacement[i].toLowerCase();
            }
            replacement = replacement.join("");
          }
          return replacement;
        };
        Search2.prototype.$assembleRegExp = function(options, $disableFakeMultiline) {
          if (options.needle instanceof RegExp)
            return options.re = options.needle;
          var needle = options.needle;
          if (!options.needle)
            return options.re = false;
          if (!options.regExp)
            needle = lang.escapeRegExp(needle);
          var modifier = options.caseSensitive ? "gm" : "gmi";
          try {
            new RegExp(needle, "u");
            options.$supportsUnicodeFlag = true;
            modifier += "u";
          } catch (e) {
            options.$supportsUnicodeFlag = false;
          }
          if (options.wholeWord)
            needle = addWordBoundary(needle, options);
          options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
          if (options.$isMultiLine)
            return options.re = this.$assembleMultilineRegExp(needle, modifier);
          try {
            var re = new RegExp(needle, modifier);
          } catch (e) {
            re = false;
          }
          return options.re = re;
        };
        Search2.prototype.$assembleMultilineRegExp = function(needle, modifier) {
          var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
          var re = [];
          for (var i = 0; i < parts.length; i++)
            try {
              re.push(new RegExp(parts[i], modifier));
            } catch (e) {
              return false;
            }
          return re;
        };
        Search2.prototype.$isMultilineSearch = function(options) {
          return options.re && /\\r\\n|\\r|\\n/.test(options.re.source) && options.regExp && !options.$isMultiLine;
        };
        Search2.prototype.$multiLineForward = function(session, re, start, last) {
          var line, chunk = chunkEnd(session, start);
          for (var row = start; row <= last; ) {
            for (var i = 0; i < chunk; i++) {
              if (row > last)
                break;
              var next = session.getLine(row++);
              line = line == null ? next : line + "\n" + next;
            }
            var match = re.exec(line);
            re.lastIndex = 0;
            if (match) {
              var beforeMatch = line.slice(0, match.index).split("\n");
              var matchedText = match[0].split("\n");
              var startRow = start + beforeMatch.length - 1;
              var startCol = beforeMatch[beforeMatch.length - 1].length;
              var endRow = startRow + matchedText.length - 1;
              var endCol = matchedText.length == 1 ? startCol + matchedText[0].length : matchedText[matchedText.length - 1].length;
              return {
                startRow,
                startCol,
                endRow,
                endCol
              };
            }
          }
          return null;
        };
        Search2.prototype.$multiLineBackward = function(session, re, endIndex, start, first) {
          var line, chunk = chunkEnd(session, start), endMargin = session.getLine(start).length - endIndex;
          for (var row = start; row >= first; ) {
            for (var i = 0; i < chunk && row >= first; i++) {
              var next = session.getLine(row--);
              line = line == null ? next : next + "\n" + line;
            }
            var match = multiLineBackwardMatch(line, re, endMargin);
            if (match) {
              var beforeMatch = line.slice(0, match.index).split("\n");
              var matchedText = match[0].split("\n");
              var startRow = row + beforeMatch.length;
              var startCol = beforeMatch[beforeMatch.length - 1].length;
              var endRow = startRow + matchedText.length - 1;
              var endCol = matchedText.length == 1 ? startCol + matchedText[0].length : matchedText[matchedText.length - 1].length;
              return {
                startRow,
                startCol,
                endRow,
                endCol
              };
            }
          }
          return null;
        };
        Search2.prototype.$matchIterator = function(session, options) {
          var re = this.$assembleRegExp(options);
          if (!re)
            return false;
          var mtSearch = this.$isMultilineSearch(options);
          var mtForward = this.$multiLineForward;
          var mtBackward = this.$multiLineBackward;
          var backwards = options.backwards == true;
          var skipCurrent = options.skipCurrent != false;
          var supportsUnicodeFlag = re.unicode;
          var range = options.range;
          var start = options.start;
          if (!start)
            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
          if (start.start)
            start = start[skipCurrent != backwards ? "end" : "start"];
          var firstRow = range ? range.start.row : 0;
          var lastRow = range ? range.end.row : session.getLength() - 1;
          if (backwards) {
            var forEach = function(callback) {
              var row = start.row;
              if (forEachInLine(row, start.column, callback))
                return;
              for (row--; row >= firstRow; row--)
                if (forEachInLine(row, Number.MAX_VALUE, callback))
                  return;
              if (options.wrap == false)
                return;
              for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                if (forEachInLine(row, Number.MAX_VALUE, callback))
                  return;
            };
          } else {
            var forEach = function(callback) {
              var row = start.row;
              if (forEachInLine(row, start.column, callback))
                return;
              for (row = row + 1; row <= lastRow; row++)
                if (forEachInLine(row, 0, callback))
                  return;
              if (options.wrap == false)
                return;
              for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                if (forEachInLine(row, 0, callback))
                  return;
            };
          }
          if (options.$isMultiLine) {
            var len = re.length;
            var forEachInLine = function(row, offset, callback) {
              var startRow = backwards ? row - len + 1 : row;
              if (startRow < 0 || startRow + len > session.getLength())
                return;
              var line = session.getLine(startRow);
              var startIndex = line.search(re[0]);
              if (!backwards && startIndex < offset || startIndex === -1)
                return;
              for (var i = 1; i < len; i++) {
                line = session.getLine(startRow + i);
                if (line.search(re[i]) == -1)
                  return;
              }
              var endIndex = line.match(re[len - 1])[0].length;
              if (backwards && endIndex > offset)
                return;
              if (callback(startRow, startIndex, startRow + len - 1, endIndex))
                return true;
            };
          } else if (backwards) {
            var forEachInLine = function(row, endIndex, callback) {
              if (mtSearch) {
                var pos = mtBackward(session, re, endIndex, row, firstRow);
                if (!pos)
                  return false;
                if (callback(pos.startRow, pos.startCol, pos.endRow, pos.endCol))
                  return true;
              } else {
                var line = session.getLine(row);
                var matches = [];
                var m, last = 0;
                re.lastIndex = 0;
                while (m = re.exec(line)) {
                  var length = m[0].length;
                  last = m.index;
                  if (!length) {
                    if (last >= line.length)
                      break;
                    re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
                  }
                  if (m.index + length > endIndex)
                    break;
                  matches.push(m.index, length);
                }
                for (var i = matches.length - 1; i >= 0; i -= 2) {
                  var column = matches[i - 1];
                  var length = matches[i];
                  if (callback(row, column, row, column + length))
                    return true;
                }
              }
            };
          } else {
            var forEachInLine = function(row, startIndex, callback) {
              re.lastIndex = startIndex;
              if (mtSearch) {
                var pos = mtForward(session, re, row, lastRow);
                if (pos) {
                  var end_row = pos.endRow <= lastRow ? pos.endRow - 1 : lastRow;
                  if (end_row > row)
                    row = end_row;
                }
                if (!pos)
                  return false;
                if (callback(pos.startRow, pos.startCol, pos.endRow, pos.endCol))
                  return true;
              } else {
                var line = session.getLine(row);
                var last;
                var m;
                while (m = re.exec(line)) {
                  var length = m[0].length;
                  last = m.index;
                  if (callback(row, last, row, last + length))
                    return true;
                  if (!length) {
                    re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
                    if (last >= line.length)
                      return false;
                  }
                }
              }
            };
          }
          return { forEach };
        };
        return Search2;
      }()
    );
    function addWordBoundary(needle, options) {
      var supportsLookbehind = lang.supportsLookbehind();
      function wordBoundary(c, firstChar2) {
        if (firstChar2 === void 0) {
          firstChar2 = true;
        }
        var wordRegExp = supportsLookbehind && options.$supportsUnicodeFlag ? new RegExp("[\\p{L}\\p{N}_]", "u") : new RegExp("\\w");
        if (wordRegExp.test(c) || options.regExp) {
          if (supportsLookbehind && options.$supportsUnicodeFlag) {
            if (firstChar2)
              return "(?<=^|[^\\p{L}\\p{N}_])";
            return "(?=[^\\p{L}\\p{N}_]|$)";
          }
          return "\\b";
        }
        return "";
      }
      var needleArray = Array.from(needle);
      var firstChar = needleArray[0];
      var lastChar = needleArray[needleArray.length - 1];
      return wordBoundary(firstChar) + needle + wordBoundary(lastChar, false);
    }
    function multiLineBackwardMatch(line, re, endMargin) {
      var match = null;
      var from = 0;
      while (from <= line.length) {
        re.lastIndex = from;
        var newMatch = re.exec(line);
        if (!newMatch)
          break;
        var end = newMatch.index + newMatch[0].length;
        if (end > line.length - endMargin)
          break;
        if (!match || end > match.index + match[0].length)
          match = newMatch;
        from = newMatch.index + 1;
      }
      return match;
    }
    function chunkEnd(session, start) {
      var base = 5e3, startPosition = { row: start, column: 0 }, startIndex = session.doc.positionToIndex(startPosition), targetIndex = startIndex + base, targetPosition = session.doc.indexToPosition(targetIndex), targetLine = targetPosition.row;
      return targetLine + 1;
    }
    exports2.Search = Search;
  });
  ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(require2, exports2, module2) {
    var __extends = this && this.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var keyUtil = require2("../lib/keys");
    var useragent = require2("../lib/useragent");
    var KEY_MODS = keyUtil.KEY_MODS;
    var MultiHashHandler = (
      /** @class */
      function() {
        function MultiHashHandler2(config, platform) {
          this.$init(config, platform, false);
        }
        MultiHashHandler2.prototype.$init = function(config, platform, $singleCommand) {
          this.platform = platform || (useragent.isMac ? "mac" : "win");
          this.commands = {};
          this.commandKeyBinding = {};
          this.addCommands(config);
          this.$singleCommand = $singleCommand;
        };
        MultiHashHandler2.prototype.addCommand = function(command) {
          if (this.commands[command.name])
            this.removeCommand(command);
          this.commands[command.name] = command;
          if (command.bindKey)
            this._buildKeyHash(command);
        };
        MultiHashHandler2.prototype.removeCommand = function(command, keepCommand) {
          var name = command && (typeof command === "string" ? command : command.name);
          command = this.commands[name];
          if (!keepCommand)
            delete this.commands[name];
          var ckb = this.commandKeyBinding;
          for (var keyId in ckb) {
            var cmdGroup = ckb[keyId];
            if (cmdGroup == command) {
              delete ckb[keyId];
            } else if (Array.isArray(cmdGroup)) {
              var i = cmdGroup.indexOf(command);
              if (i != -1) {
                cmdGroup.splice(i, 1);
                if (cmdGroup.length == 1)
                  ckb[keyId] = cmdGroup[0];
              }
            }
          }
        };
        MultiHashHandler2.prototype.bindKey = function(key, command, position) {
          if (typeof key == "object" && key) {
            if (position == void 0)
              position = key.position;
            key = key[this.platform];
          }
          if (!key)
            return;
          if (typeof command == "function")
            return this.addCommand({ exec: command, bindKey: key, name: command.name || /**@type{string}*/
            key });
          key.split("|").forEach(function(keyPart) {
            var chain = "";
            if (keyPart.indexOf(" ") != -1) {
              var parts = keyPart.split(/\s+/);
              keyPart = parts.pop();
              parts.forEach(function(keyPart2) {
                var binding2 = this.parseKeys(keyPart2);
                var id3 = KEY_MODS[binding2.hashId] + binding2.key;
                chain += (chain ? " " : "") + id3;
                this._addCommandToBinding(chain, "chainKeys");
              }, this);
              chain += " ";
            }
            var binding = this.parseKeys(keyPart);
            var id2 = KEY_MODS[binding.hashId] + binding.key;
            this._addCommandToBinding(chain + id2, command, position);
          }, this);
        };
        MultiHashHandler2.prototype._addCommandToBinding = function(keyId, command, position) {
          var ckb = this.commandKeyBinding, i;
          if (!command) {
            delete ckb[keyId];
          } else if (!ckb[keyId] || this.$singleCommand) {
            ckb[keyId] = command;
          } else {
            if (!Array.isArray(ckb[keyId])) {
              ckb[keyId] = [ckb[keyId]];
            } else if ((i = ckb[keyId].indexOf(command)) != -1) {
              ckb[keyId].splice(i, 1);
            }
            if (typeof position != "number") {
              position = getPosition(command);
            }
            var commands = ckb[keyId];
            for (i = 0; i < commands.length; i++) {
              var other = commands[i];
              var otherPos = getPosition(other);
              if (otherPos > position)
                break;
            }
            commands.splice(i, 0, command);
          }
        };
        MultiHashHandler2.prototype.addCommands = function(commands) {
          commands && Object.keys(commands).forEach(function(name) {
            var command = commands[name];
            if (!command)
              return;
            if (typeof command === "string")
              return this.bindKey(command, name);
            if (typeof command === "function")
              command = { exec: command };
            if (typeof command !== "object")
              return;
            if (!command.name)
              command.name = name;
            this.addCommand(command);
          }, this);
        };
        MultiHashHandler2.prototype.removeCommands = function(commands) {
          Object.keys(commands).forEach(function(name) {
            this.removeCommand(commands[name]);
          }, this);
        };
        MultiHashHandler2.prototype.bindKeys = function(keyList) {
          Object.keys(keyList).forEach(function(key) {
            this.bindKey(key, keyList[key]);
          }, this);
        };
        MultiHashHandler2.prototype._buildKeyHash = function(command) {
          this.bindKey(command.bindKey, command);
        };
        MultiHashHandler2.prototype.parseKeys = function(keys) {
          var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x) {
            return x;
          });
          var key = parts.pop();
          var keyCode = keyUtil[key];
          if (keyUtil.FUNCTION_KEYS[keyCode])
            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
          else if (!parts.length)
            return { key, hashId: -1 };
          else if (parts.length == 1 && parts[0] == "shift")
            return { key: key.toUpperCase(), hashId: -1 };
          var hashId = 0;
          for (var i = parts.length; i--; ) {
            var modifier = keyUtil.KEY_MODS[parts[i]];
            if (modifier == null) {
              if (typeof console != "undefined")
                console.error("invalid modifier " + parts[i] + " in " + keys);
              return false;
            }
            hashId |= modifier;
          }
          return { key, hashId };
        };
        MultiHashHandler2.prototype.findKeyCommand = function(hashId, keyString) {
          var key = KEY_MODS[hashId] + keyString;
          return this.commandKeyBinding[key];
        };
        MultiHashHandler2.prototype.handleKeyboard = function(data, hashId, keyString, keyCode) {
          if (keyCode < 0)
            return;
          var key = KEY_MODS[hashId] + keyString;
          var command = this.commandKeyBinding[key];
          if (data.$keyChain) {
            data.$keyChain += " " + key;
            command = this.commandKeyBinding[data.$keyChain] || command;
          }
          if (command) {
            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
              data.$keyChain = data.$keyChain || key;
              return { command: "null" };
            }
          }
          if (data.$keyChain) {
            if ((!hashId || hashId == 4) && keyString.length == 1)
              data.$keyChain = data.$keyChain.slice(0, -key.length - 1);
            else if (hashId == -1 || keyCode > 0)
              data.$keyChain = "";
          }
          return { command };
        };
        MultiHashHandler2.prototype.getStatusText = function(editor2, data) {
          return data.$keyChain || "";
        };
        return MultiHashHandler2;
      }()
    );
    function getPosition(command) {
      return typeof command == "object" && command.bindKey && command.bindKey.position || (command.isDefault ? -100 : 0);
    }
    var HashHandler = (
      /** @class */
      function(_super) {
        __extends(HashHandler2, _super);
        function HashHandler2(config, platform) {
          var _this = _super.call(this, config, platform) || this;
          _this.$singleCommand = true;
          return _this;
        }
        return HashHandler2;
      }(MultiHashHandler)
    );
    HashHandler.call = function(thisArg, config, platform) {
      MultiHashHandler.prototype.$init.call(thisArg, config, platform, true);
    };
    MultiHashHandler.call = function(thisArg, config, platform) {
      MultiHashHandler.prototype.$init.call(thisArg, config, platform, false);
    };
    exports2.HashHandler = HashHandler;
    exports2.MultiHashHandler = MultiHashHandler;
  });
  ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function(require2, exports2, module2) {
    var __extends = this && this.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var oop = require2("../lib/oop");
    var MultiHashHandler = require2("../keyboard/hash_handler").MultiHashHandler;
    var EventEmitter = require2("../lib/event_emitter").EventEmitter;
    var CommandManager = (
      /** @class */
      function(_super) {
        __extends(CommandManager2, _super);
        function CommandManager2(platform, commands) {
          var _this = _super.call(this, commands, platform) || this;
          _this.byName = _this.commands;
          _this.setDefaultHandler("exec", function(e) {
            if (!e.args) {
              return e.command.exec(e.editor, {}, e.event, true);
            }
            return e.command.exec(e.editor, e.args, e.event, false);
          });
          return _this;
        }
        CommandManager2.prototype.exec = function(command, editor2, args) {
          if (Array.isArray(command)) {
            for (var i = command.length; i--; ) {
              if (this.exec(command[i], editor2, args))
                return true;
            }
            return false;
          }
          if (typeof command === "string")
            command = this.commands[command];
          var e = { editor: editor2, command, args };
          if (!this.canExecute(command, editor2)) {
            this._signal("commandUnavailable", e);
            return false;
          }
          e.returnValue = this._emit("exec", e);
          this._signal("afterExec", e);
          return e.returnValue === false ? false : true;
        };
        CommandManager2.prototype.canExecute = function(command, editor2) {
          if (typeof command === "string")
            command = this.commands[command];
          if (!command)
            return false;
          if (editor2 && editor2.$readOnly && !command.readOnly)
            return false;
          if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor2))
            return false;
          return true;
        };
        CommandManager2.prototype.toggleRecording = function(editor2) {
          if (this.$inReplay)
            return;
          editor2 && editor2._emit("changeStatus");
          if (this.recording) {
            this.macro.pop();
            this.off("exec", this.$addCommandToMacro);
            if (!this.macro.length)
              this.macro = this.oldMacro;
            return this.recording = false;
          }
          if (!this.$addCommandToMacro) {
            this.$addCommandToMacro = (function(e) {
              this.macro.push([e.command, e.args]);
            }).bind(this);
          }
          this.oldMacro = this.macro;
          this.macro = [];
          this.on("exec", this.$addCommandToMacro);
          return this.recording = true;
        };
        CommandManager2.prototype.replay = function(editor2) {
          if (this.$inReplay || !this.macro)
            return;
          if (this.recording)
            return this.toggleRecording(editor2);
          try {
            this.$inReplay = true;
            this.macro.forEach(function(x) {
              if (typeof x == "string")
                this.exec(x, editor2);
              else
                this.exec(x[0], editor2, x[1]);
            }, this);
          } finally {
            this.$inReplay = false;
          }
        };
        CommandManager2.prototype.trimMacro = function(m) {
          return m.map(function(x) {
            if (typeof x[0] != "string")
              x[0] = x[0].name;
            if (!x[1])
              x = x[0];
            return x;
          });
        };
        return CommandManager2;
      }(MultiHashHandler)
    );
    oop.implement(CommandManager.prototype, EventEmitter);
    exports2.CommandManager = CommandManager;
  });
  ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function(require2, exports2, module2) {
    var lang = require2("../lib/lang");
    var config = require2("../config");
    var Range = require2("../range").Range;
    function bindKey(win, mac) {
      return { win, mac };
    }
    exports2.commands = [
      {
        name: "showSettingsMenu",
        description: "Show settings menu",
        bindKey: bindKey("Ctrl-,", "Command-,"),
        exec: function(editor2) {
          config.loadModule("ace/ext/settings_menu", function(module3) {
            module3.init(editor2);
            editor2.showSettingsMenu();
          });
        },
        readOnly: true
      },
      {
        name: "goToNextError",
        description: "Go to next error",
        bindKey: bindKey("Alt-E", "F4"),
        exec: function(editor2) {
          config.loadModule("ace/ext/error_marker", function(module3) {
            module3.showErrorMarker(editor2, 1);
          });
        },
        scrollIntoView: "animate",
        readOnly: true
      },
      {
        name: "goToPreviousError",
        description: "Go to previous error",
        bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
        exec: function(editor2) {
          config.loadModule("ace/ext/error_marker", function(module3) {
            module3.showErrorMarker(editor2, -1);
          });
        },
        scrollIntoView: "animate",
        readOnly: true
      },
      {
        name: "selectall",
        description: "Select all",
        bindKey: bindKey("Ctrl-A", "Command-A"),
        exec: function(editor2) {
          editor2.selectAll();
        },
        readOnly: true
      },
      {
        name: "centerselection",
        description: "Center selection",
        bindKey: bindKey(null, "Ctrl-L"),
        exec: function(editor2) {
          editor2.centerSelection();
        },
        readOnly: true
      },
      {
        name: "gotoline",
        description: "Go to line...",
        bindKey: bindKey("Ctrl-L", "Command-L"),
        exec: function(editor2, line) {
          if (typeof line === "number" && !isNaN(line))
            editor2.gotoLine(line);
          editor2.prompt({ $type: "gotoLine" });
        },
        readOnly: true
      },
      {
        name: "fold",
        bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
        exec: function(editor2) {
          editor2.session.toggleFold(false);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "unfold",
        bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
        exec: function(editor2) {
          editor2.session.toggleFold(true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "toggleFoldWidget",
        description: "Toggle fold widget",
        bindKey: bindKey("F2", "F2"),
        exec: function(editor2) {
          editor2.session.toggleFoldWidget();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "toggleParentFoldWidget",
        description: "Toggle parent fold widget",
        bindKey: bindKey("Alt-F2", "Alt-F2"),
        exec: function(editor2) {
          editor2.session.toggleFoldWidget(true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "foldall",
        description: "Fold all",
        bindKey: bindKey(null, "Ctrl-Command-Option-0"),
        exec: function(editor2) {
          editor2.session.foldAll();
        },
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "foldAllComments",
        description: "Fold all comments",
        bindKey: bindKey(null, "Ctrl-Command-Option-0"),
        exec: function(editor2) {
          editor2.session.foldAllComments();
        },
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "foldOther",
        description: "Fold other",
        bindKey: bindKey("Alt-0", "Command-Option-0"),
        exec: function(editor2) {
          editor2.session.foldAll();
          editor2.session.unfold(editor2.selection.getAllRanges());
        },
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "unfoldall",
        description: "Unfold all",
        bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
        exec: function(editor2) {
          editor2.session.unfold();
        },
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "findnext",
        description: "Find next",
        bindKey: bindKey("Ctrl-K", "Command-G"),
        exec: function(editor2) {
          editor2.findNext();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "findprevious",
        description: "Find previous",
        bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
        exec: function(editor2) {
          editor2.findPrevious();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      },
      {
        name: "selectOrFindNext",
        description: "Select or find next",
        bindKey: bindKey("Alt-K", "Ctrl-G"),
        exec: function(editor2) {
          if (editor2.selection.isEmpty())
            editor2.selection.selectWord();
          else
            editor2.findNext();
        },
        readOnly: true
      },
      {
        name: "selectOrFindPrevious",
        description: "Select or find previous",
        bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
        exec: function(editor2) {
          if (editor2.selection.isEmpty())
            editor2.selection.selectWord();
          else
            editor2.findPrevious();
        },
        readOnly: true
      },
      {
        name: "find",
        description: "Find",
        bindKey: bindKey("Ctrl-F", "Command-F"),
        exec: function(editor2) {
          config.loadModule("ace/ext/searchbox", function(e) {
            e.Search(editor2);
          });
        },
        readOnly: true
      },
      {
        name: "overwrite",
        description: "Overwrite",
        bindKey: "Insert",
        exec: function(editor2) {
          editor2.toggleOverwrite();
        },
        readOnly: true
      },
      {
        name: "selecttostart",
        description: "Select to start",
        bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
        exec: function(editor2) {
          editor2.getSelection().selectFileStart();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      },
      {
        name: "gotostart",
        description: "Go to start",
        bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
        exec: function(editor2) {
          editor2.navigateFileStart();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      },
      {
        name: "selectup",
        description: "Select up",
        bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
        exec: function(editor2) {
          editor2.getSelection().selectUp();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "golineup",
        description: "Go line up",
        bindKey: bindKey("Up", "Up|Ctrl-P"),
        exec: function(editor2, args) {
          editor2.navigateUp(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selecttoend",
        description: "Select to end",
        bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
        exec: function(editor2) {
          editor2.getSelection().selectFileEnd();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      },
      {
        name: "gotoend",
        description: "Go to end",
        bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
        exec: function(editor2) {
          editor2.navigateFileEnd();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      },
      {
        name: "selectdown",
        description: "Select down",
        bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
        exec: function(editor2) {
          editor2.getSelection().selectDown();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "golinedown",
        description: "Go line down",
        bindKey: bindKey("Down", "Down|Ctrl-N"),
        exec: function(editor2, args) {
          editor2.navigateDown(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selectwordleft",
        description: "Select word left",
        bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
        exec: function(editor2) {
          editor2.getSelection().selectWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "gotowordleft",
        description: "Go to word left",
        bindKey: bindKey("Ctrl-Left", "Option-Left"),
        exec: function(editor2) {
          editor2.navigateWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selecttolinestart",
        description: "Select to line start",
        bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
        exec: function(editor2) {
          editor2.getSelection().selectLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "gotolinestart",
        description: "Go to line start",
        bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
        exec: function(editor2) {
          editor2.navigateLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selectleft",
        description: "Select left",
        bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
        exec: function(editor2) {
          editor2.getSelection().selectLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "gotoleft",
        description: "Go to left",
        bindKey: bindKey("Left", "Left|Ctrl-B"),
        exec: function(editor2, args) {
          editor2.navigateLeft(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selectwordright",
        description: "Select word right",
        bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
        exec: function(editor2) {
          editor2.getSelection().selectWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "gotowordright",
        description: "Go to word right",
        bindKey: bindKey("Ctrl-Right", "Option-Right"),
        exec: function(editor2) {
          editor2.navigateWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selecttolineend",
        description: "Select to line end",
        bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
        exec: function(editor2) {
          editor2.getSelection().selectLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "gotolineend",
        description: "Go to line end",
        bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
        exec: function(editor2) {
          editor2.navigateLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selectright",
        description: "Select right",
        bindKey: bindKey("Shift-Right", "Shift-Right"),
        exec: function(editor2) {
          editor2.getSelection().selectRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "gotoright",
        description: "Go to right",
        bindKey: bindKey("Right", "Right|Ctrl-F"),
        exec: function(editor2, args) {
          editor2.navigateRight(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selectpagedown",
        description: "Select page down",
        bindKey: "Shift-PageDown",
        exec: function(editor2) {
          editor2.selectPageDown();
        },
        readOnly: true
      },
      {
        name: "pagedown",
        description: "Page down",
        bindKey: bindKey(null, "Option-PageDown"),
        exec: function(editor2) {
          editor2.scrollPageDown();
        },
        readOnly: true
      },
      {
        name: "gotopagedown",
        description: "Go to page down",
        bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
        exec: function(editor2) {
          editor2.gotoPageDown();
        },
        readOnly: true
      },
      {
        name: "selectpageup",
        description: "Select page up",
        bindKey: "Shift-PageUp",
        exec: function(editor2) {
          editor2.selectPageUp();
        },
        readOnly: true
      },
      {
        name: "pageup",
        description: "Page up",
        bindKey: bindKey(null, "Option-PageUp"),
        exec: function(editor2) {
          editor2.scrollPageUp();
        },
        readOnly: true
      },
      {
        name: "gotopageup",
        description: "Go to page up",
        bindKey: "PageUp",
        exec: function(editor2) {
          editor2.gotoPageUp();
        },
        readOnly: true
      },
      {
        name: "scrollup",
        description: "Scroll up",
        bindKey: bindKey("Ctrl-Up", null),
        exec: function(e) {
          e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
        },
        readOnly: true
      },
      {
        name: "scrolldown",
        description: "Scroll down",
        bindKey: bindKey("Ctrl-Down", null),
        exec: function(e) {
          e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
        },
        readOnly: true
      },
      {
        name: "selectlinestart",
        description: "Select line start",
        bindKey: "Shift-Home",
        exec: function(editor2) {
          editor2.getSelection().selectLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "selectlineend",
        description: "Select line end",
        bindKey: "Shift-End",
        exec: function(editor2) {
          editor2.getSelection().selectLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "togglerecording",
        description: "Toggle recording",
        bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
        exec: function(editor2) {
          editor2.commands.toggleRecording(editor2);
        },
        readOnly: true
      },
      {
        name: "replaymacro",
        description: "Replay macro",
        bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
        exec: function(editor2) {
          editor2.commands.replay(editor2);
        },
        readOnly: true
      },
      {
        name: "jumptomatching",
        description: "Jump to matching",
        bindKey: bindKey("Ctrl-\\|Ctrl-P", "Command-\\"),
        exec: function(editor2) {
          editor2.jumpToMatching();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
      },
      {
        name: "selecttomatching",
        description: "Select to matching",
        bindKey: bindKey("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
        exec: function(editor2) {
          editor2.jumpToMatching(true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
      },
      {
        name: "expandToMatching",
        description: "Expand to matching",
        bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
        exec: function(editor2) {
          editor2.jumpToMatching(true, true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
      },
      {
        name: "passKeysToBrowser",
        description: "Pass keys to browser",
        bindKey: bindKey(null, null),
        exec: function() {
        },
        passEvent: true,
        readOnly: true
      },
      {
        name: "copy",
        description: "Copy",
        exec: function(editor2) {
        },
        readOnly: true
      },
      {
        name: "cut",
        description: "Cut",
        exec: function(editor2) {
          var cutLine = editor2.$copyWithEmptySelection && editor2.selection.isEmpty();
          var range = cutLine ? editor2.selection.getLineRange() : editor2.selection.getRange();
          editor2._emit("cut", range);
          if (!range.isEmpty())
            editor2.session.remove(range);
          editor2.clearSelection();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      },
      {
        name: "paste",
        description: "Paste",
        exec: function(editor2, args) {
          editor2.$handlePaste(args);
        },
        scrollIntoView: "cursor"
      },
      {
        name: "removeline",
        description: "Remove line",
        bindKey: bindKey("Ctrl-D", "Command-D"),
        exec: function(editor2) {
          editor2.removeLines();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEachLine"
      },
      {
        name: "duplicateSelection",
        description: "Duplicate selection",
        bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
        exec: function(editor2) {
          editor2.duplicateSelection();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      },
      {
        name: "sortlines",
        description: "Sort lines",
        bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
        exec: function(editor2) {
          editor2.sortLines();
        },
        scrollIntoView: "selection",
        multiSelectAction: "forEachLine"
      },
      {
        name: "togglecomment",
        description: "Toggle comment",
        bindKey: bindKey("Ctrl-/", "Command-/"),
        exec: function(editor2) {
          editor2.toggleCommentLines();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      },
      {
        name: "toggleBlockComment",
        description: "Toggle block comment",
        bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
        exec: function(editor2) {
          editor2.toggleBlockComment();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      },
      {
        name: "modifyNumberUp",
        description: "Modify number up",
        bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
        exec: function(editor2) {
          editor2.modifyNumber(1);
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      },
      {
        name: "modifyNumberDown",
        description: "Modify number down",
        bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
        exec: function(editor2) {
          editor2.modifyNumber(-1);
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      },
      {
        name: "replace",
        description: "Replace",
        bindKey: bindKey("Ctrl-H", "Command-Option-F"),
        exec: function(editor2) {
          config.loadModule("ace/ext/searchbox", function(e) {
            e.Search(editor2, true);
          });
        }
      },
      {
        name: "undo",
        description: "Undo",
        bindKey: bindKey("Ctrl-Z", "Command-Z"),
        exec: function(editor2) {
          editor2.undo();
        }
      },
      {
        name: "redo",
        description: "Redo",
        bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
        exec: function(editor2) {
          editor2.redo();
        }
      },
      {
        name: "copylinesup",
        description: "Copy lines up",
        bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
        exec: function(editor2) {
          editor2.copyLinesUp();
        },
        scrollIntoView: "cursor"
      },
      {
        name: "movelinesup",
        description: "Move lines up",
        bindKey: bindKey("Alt-Up", "Option-Up"),
        exec: function(editor2) {
          editor2.moveLinesUp();
        },
        scrollIntoView: "cursor"
      },
      {
        name: "copylinesdown",
        description: "Copy lines down",
        bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
        exec: function(editor2) {
          editor2.copyLinesDown();
        },
        scrollIntoView: "cursor"
      },
      {
        name: "movelinesdown",
        description: "Move lines down",
        bindKey: bindKey("Alt-Down", "Option-Down"),
        exec: function(editor2) {
          editor2.moveLinesDown();
        },
        scrollIntoView: "cursor"
      },
      {
        name: "del",
        description: "Delete",
        bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
        exec: function(editor2) {
          editor2.remove("right");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "backspace",
        description: "Backspace",
        bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
        exec: function(editor2) {
          editor2.remove("left");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "cut_or_delete",
        description: "Cut or delete",
        bindKey: bindKey("Shift-Delete", null),
        exec: function(editor2) {
          if (editor2.selection.isEmpty()) {
            editor2.remove("left");
          } else {
            return false;
          }
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removetolinestart",
        description: "Remove to line start",
        bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
        exec: function(editor2) {
          editor2.removeToLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removetolineend",
        description: "Remove to line end",
        bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
        exec: function(editor2) {
          editor2.removeToLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removetolinestarthard",
        description: "Remove to line start hard",
        bindKey: bindKey("Ctrl-Shift-Backspace", null),
        exec: function(editor2) {
          var range = editor2.selection.getRange();
          range.start.column = 0;
          editor2.session.remove(range);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removetolineendhard",
        description: "Remove to line end hard",
        bindKey: bindKey("Ctrl-Shift-Delete", null),
        exec: function(editor2) {
          var range = editor2.selection.getRange();
          range.end.column = Number.MAX_VALUE;
          editor2.session.remove(range);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removewordleft",
        description: "Remove word left",
        bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
        exec: function(editor2) {
          editor2.removeWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removewordright",
        description: "Remove word right",
        bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
        exec: function(editor2) {
          editor2.removeWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "outdent",
        description: "Outdent",
        bindKey: bindKey("Shift-Tab", "Shift-Tab"),
        exec: function(editor2) {
          editor2.blockOutdent();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      },
      {
        name: "indent",
        description: "Indent",
        bindKey: bindKey("Tab", "Tab"),
        exec: function(editor2) {
          editor2.indent();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      },
      {
        name: "blockoutdent",
        description: "Block outdent",
        bindKey: bindKey("Ctrl-[", "Ctrl-["),
        exec: function(editor2) {
          editor2.blockOutdent();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      },
      {
        name: "blockindent",
        description: "Block indent",
        bindKey: bindKey("Ctrl-]", "Ctrl-]"),
        exec: function(editor2) {
          editor2.blockIndent();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      },
      {
        name: "insertstring",
        description: "Insert string",
        exec: function(editor2, str) {
          editor2.insert(str);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "inserttext",
        description: "Insert text",
        exec: function(editor2, args) {
          editor2.insert(lang.stringRepeat(args.text || "", args.times || 1));
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "splitline",
        description: "Split line",
        bindKey: bindKey(null, "Ctrl-O"),
        exec: function(editor2) {
          editor2.splitLine();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "transposeletters",
        description: "Transpose letters",
        bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
        exec: function(editor2) {
          editor2.transposeLetters();
        },
        multiSelectAction: function(editor2) {
          editor2.transposeSelections(1);
        },
        scrollIntoView: "cursor"
      },
      {
        name: "touppercase",
        description: "To uppercase",
        bindKey: bindKey("Ctrl-U", "Ctrl-U"),
        exec: function(editor2) {
          editor2.toUpperCase();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "tolowercase",
        description: "To lowercase",
        bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
        exec: function(editor2) {
          editor2.toLowerCase();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "autoindent",
        description: "Auto Indent",
        bindKey: bindKey(null, null),
        exec: function(editor2) {
          editor2.autoIndent();
        },
        scrollIntoView: "animate"
      },
      {
        name: "expandtoline",
        description: "Expand to line",
        bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
        exec: function(editor2) {
          var range = editor2.selection.getRange();
          range.start.column = range.end.column = 0;
          range.end.row++;
          editor2.selection.setRange(range, false);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      },
      {
        name: "openlink",
        bindKey: bindKey("Ctrl+F3", "F3"),
        exec: function(editor2) {
          editor2.openLink();
        }
      },
      {
        name: "joinlines",
        description: "Join lines",
        bindKey: bindKey(null, null),
        exec: function(editor2) {
          var isBackwards = editor2.selection.isBackwards();
          var selectionStart = isBackwards ? editor2.selection.getSelectionLead() : editor2.selection.getSelectionAnchor();
          var selectionEnd = isBackwards ? editor2.selection.getSelectionAnchor() : editor2.selection.getSelectionLead();
          var firstLineEndCol = editor2.session.doc.getLine(selectionStart.row).length;
          var selectedText = editor2.session.doc.getTextRange(editor2.selection.getRange());
          var selectedCount = selectedText.replace(/\n\s*/, " ").length;
          var insertLine = editor2.session.doc.getLine(selectionStart.row);
          for (var i2 = selectionStart.row + 1; i2 <= selectionEnd.row + 1; i2++) {
            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor2.session.doc.getLine(i2)));
            if (curLine.length !== 0) {
              curLine = " " + curLine;
            }
            insertLine += curLine;
          }
          if (selectionEnd.row + 1 < editor2.session.doc.getLength() - 1) {
            insertLine += editor2.session.doc.getNewLineCharacter();
          }
          editor2.clearSelection();
          editor2.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
          if (selectedCount > 0) {
            editor2.selection.moveCursorTo(selectionStart.row, selectionStart.column);
            editor2.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
          } else {
            firstLineEndCol = editor2.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? firstLineEndCol + 1 : firstLineEndCol;
            editor2.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
          }
        },
        multiSelectAction: "forEach",
        readOnly: true
      },
      {
        name: "invertSelection",
        description: "Invert selection",
        bindKey: bindKey(null, null),
        exec: function(editor2) {
          var endRow = editor2.session.doc.getLength() - 1;
          var endCol = editor2.session.doc.getLine(endRow).length;
          var ranges = editor2.selection.rangeList.ranges;
          var newRanges = [];
          if (ranges.length < 1) {
            ranges = [editor2.selection.getRange()];
          }
          for (var i2 = 0; i2 < ranges.length; i2++) {
            if (i2 == ranges.length - 1) {
              if (!(ranges[i2].end.row === endRow && ranges[i2].end.column === endCol)) {
                newRanges.push(new Range(ranges[i2].end.row, ranges[i2].end.column, endRow, endCol));
              }
            }
            if (i2 === 0) {
              if (!(ranges[i2].start.row === 0 && ranges[i2].start.column === 0)) {
                newRanges.push(new Range(0, 0, ranges[i2].start.row, ranges[i2].start.column));
              }
            } else {
              newRanges.push(new Range(ranges[i2 - 1].end.row, ranges[i2 - 1].end.column, ranges[i2].start.row, ranges[i2].start.column));
            }
          }
          editor2.exitMultiSelectMode();
          editor2.clearSelection();
          for (var i2 = 0; i2 < newRanges.length; i2++) {
            editor2.selection.addRange(newRanges[i2], false);
          }
        },
        readOnly: true,
        scrollIntoView: "none"
      },
      {
        name: "addLineAfter",
        description: "Add new line after the current line",
        exec: function(editor2) {
          editor2.selection.clearSelection();
          editor2.navigateLineEnd();
          editor2.insert("\n");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "addLineBefore",
        description: "Add new line before the current line",
        exec: function(editor2) {
          editor2.selection.clearSelection();
          var cursor = editor2.getCursorPosition();
          editor2.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
          editor2.insert("\n");
          if (cursor.row === 0)
            editor2.navigateUp();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "openCommandPallete",
        exec: function(editor2) {
          console.warn("This is an obsolete command. Please use `openCommandPalette` instead.");
          editor2.prompt({ $type: "commands" });
        },
        readOnly: true
      },
      {
        name: "openCommandPalette",
        description: "Open command palette",
        bindKey: bindKey("F1", "F1"),
        exec: function(editor2) {
          editor2.prompt({ $type: "commands" });
        },
        readOnly: true
      },
      {
        name: "modeSelect",
        description: "Change language mode...",
        bindKey: bindKey(null, null),
        exec: function(editor2) {
          editor2.prompt({ $type: "modes" });
        },
        readOnly: true
      }
    ];
    for (var i = 1; i < 9; i++) {
      exports2.commands.push({
        name: "foldToLevel" + i,
        description: "Fold To Level " + i,
        level: i,
        exec: function(editor2) {
          editor2.session.foldToLevel(this.level);
        },
        scrollIntoView: "center",
        readOnly: true
      });
    }
  });
  ace.define("ace/keyboard/gutter_handler", ["require", "exports", "module", "ace/lib/keys", "ace/mouse/default_gutter_handler"], function(require2, exports2, module2) {
    var keys = require2("../lib/keys");
    var GutterTooltip = require2("../mouse/default_gutter_handler").GutterTooltip;
    var GutterKeyboardHandler = (
      /** @class */
      function() {
        function GutterKeyboardHandler2(editor2) {
          this.editor = editor2;
          this.gutterLayer = editor2.renderer.$gutterLayer;
          this.element = editor2.renderer.$gutter;
          this.lines = editor2.renderer.$gutterLayer.$lines;
          this.activeRowIndex = null;
          this.activeLane = null;
          this.annotationTooltip = new GutterTooltip(this.editor);
        }
        GutterKeyboardHandler2.prototype.addListener = function() {
          this.element.addEventListener("keydown", this.$onGutterKeyDown.bind(this));
          this.element.addEventListener("focusout", this.$blurGutter.bind(this));
          this.editor.on("mousewheel", this.$blurGutter.bind(this));
        };
        GutterKeyboardHandler2.prototype.removeListener = function() {
          this.element.removeEventListener("keydown", this.$onGutterKeyDown.bind(this));
          this.element.removeEventListener("focusout", this.$blurGutter.bind(this));
          this.editor.off("mousewheel", this.$blurGutter.bind(this));
        };
        GutterKeyboardHandler2.prototype.$onGutterKeyDown = function(e) {
          if (this.annotationTooltip.isOpen) {
            e.preventDefault();
            if (e.keyCode === keys["escape"])
              this.annotationTooltip.hideTooltip();
            return;
          }
          if (e.target === this.element) {
            if (e.keyCode != keys["enter"]) {
              return;
            }
            e.preventDefault();
            var row = this.editor.getCursorPosition().row;
            if (!this.editor.isRowVisible(row))
              this.editor.scrollToLine(row, true, true);
            setTimeout(
              (function() {
                var index2 = this.$rowToRowIndex(this.gutterLayer.$cursorCell.row);
                var nearestFoldLaneWidgetIndex = this.$findNearestFoldLaneWidget(index2);
                var nearestAnnotationIndex = this.$findNearestAnnotation(index2);
                if (nearestFoldLaneWidgetIndex === null && nearestAnnotationIndex === null)
                  return;
                var futureActiveRowIndex = this.$findClosestNumber(nearestFoldLaneWidgetIndex, nearestAnnotationIndex, index2);
                if (futureActiveRowIndex === nearestFoldLaneWidgetIndex) {
                  this.activeLane = "fold";
                  this.activeRowIndex = nearestFoldLaneWidgetIndex;
                  if (this.$isCustomWidgetVisible(nearestFoldLaneWidgetIndex)) {
                    this.$focusCustomWidget(this.activeRowIndex);
                    return;
                  } else {
                    this.$focusFoldWidget(this.activeRowIndex);
                    return;
                  }
                } else {
                  this.activeRowIndex = nearestAnnotationIndex;
                  this.activeLane = "annotation";
                  this.$focusAnnotation(this.activeRowIndex);
                  return;
                }
              }).bind(this),
              10
            );
            return;
          }
          this.$handleGutterKeyboardInteraction(e);
          setTimeout((function() {
            this.editor._signal("gutterkeydown", new GutterKeyboardEvent(e, this));
          }).bind(this), 10);
        };
        GutterKeyboardHandler2.prototype.$handleGutterKeyboardInteraction = function(e) {
          if (e.keyCode === keys["tab"]) {
            e.preventDefault();
            return;
          }
          if (e.keyCode === keys["escape"]) {
            e.preventDefault();
            this.$blurGutter();
            this.element.focus();
            this.lane = null;
            return;
          }
          if (e.keyCode === keys["up"]) {
            e.preventDefault();
            switch (this.activeLane) {
              case "fold":
                this.$moveFoldWidgetUp();
                break;
              case "annotation":
                this.$moveAnnotationUp();
                break;
            }
            return;
          }
          if (e.keyCode === keys["down"]) {
            e.preventDefault();
            switch (this.activeLane) {
              case "fold":
                this.$moveFoldWidgetDown();
                break;
              case "annotation":
                this.$moveAnnotationDown();
                break;
            }
            return;
          }
          if (e.keyCode === keys["left"]) {
            e.preventDefault();
            this.$switchLane("annotation");
            return;
          }
          if (e.keyCode === keys["right"]) {
            e.preventDefault();
            this.$switchLane("fold");
            return;
          }
          if (e.keyCode === keys["enter"] || e.keyCode === keys["space"]) {
            e.preventDefault();
            switch (this.activeLane) {
              case "fold":
                var row = this.$rowIndexToRow(this.activeRowIndex);
                var customWidget = this.editor.session.$gutterCustomWidgets[row];
                if (customWidget) {
                  if (customWidget.callbacks && customWidget.callbacks.onClick) {
                    customWidget.callbacks.onClick(e, row);
                  }
                } else if (this.gutterLayer.session.foldWidgets[row] === "start") {
                  this.editor.session.onFoldWidgetClick(this.$rowIndexToRow(this.activeRowIndex), e);
                  setTimeout(
                    (function() {
                      if (this.$rowIndexToRow(this.activeRowIndex) !== row) {
                        this.$blurFoldWidget(this.activeRowIndex);
                        this.activeRowIndex = this.$rowToRowIndex(row);
                        this.$focusFoldWidget(this.activeRowIndex);
                      }
                    }).bind(this),
                    10
                  );
                  break;
                } else if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === "end") {
                  break;
                }
                return;
              case "annotation":
                var gutterElement = this.lines.cells[this.activeRowIndex].element.childNodes[2];
                var rect = gutterElement.getBoundingClientRect();
                var style2 = this.annotationTooltip.getElement().style;
                style2.left = rect.right + "px";
                style2.top = rect.bottom + "px";
                this.annotationTooltip.showTooltip(this.$rowIndexToRow(this.activeRowIndex));
                break;
            }
            return;
          }
        };
        GutterKeyboardHandler2.prototype.$blurGutter = function() {
          if (this.activeRowIndex !== null) {
            switch (this.activeLane) {
              case "fold":
                this.$blurFoldWidget(this.activeRowIndex);
                this.$blurCustomWidget(this.activeRowIndex);
                break;
              case "annotation":
                this.$blurAnnotation(this.activeRowIndex);
                break;
            }
          }
          if (this.annotationTooltip.isOpen)
            this.annotationTooltip.hideTooltip();
          return;
        };
        GutterKeyboardHandler2.prototype.$isFoldWidgetVisible = function(index2) {
          var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index2));
          var isIconVisible = this.$getFoldWidget(index2).style.display !== "none";
          return isRowFullyVisible && isIconVisible;
        };
        GutterKeyboardHandler2.prototype.$isCustomWidgetVisible = function(index2) {
          var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index2));
          var isIconVisible = !!this.$getCustomWidget(index2);
          return isRowFullyVisible && isIconVisible;
        };
        GutterKeyboardHandler2.prototype.$isAnnotationVisible = function(index2) {
          var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index2));
          var isIconVisible = this.$getAnnotation(index2).style.display !== "none";
          return isRowFullyVisible && isIconVisible;
        };
        GutterKeyboardHandler2.prototype.$getFoldWidget = function(index2) {
          var cell = this.lines.get(index2);
          var element = cell.element;
          return element.childNodes[1];
        };
        GutterKeyboardHandler2.prototype.$getCustomWidget = function(index2) {
          var cell = this.lines.get(index2);
          var element = cell.element;
          return element.childNodes[3];
        };
        GutterKeyboardHandler2.prototype.$getAnnotation = function(index2) {
          var cell = this.lines.get(index2);
          var element = cell.element;
          return element.childNodes[2];
        };
        GutterKeyboardHandler2.prototype.$findNearestFoldLaneWidget = function(index2) {
          if (this.$isCustomWidgetVisible(index2))
            return index2;
          if (this.$isFoldWidgetVisible(index2))
            return index2;
          var i = 0;
          while (index2 - i > 0 || index2 + i < this.lines.getLength() - 1) {
            i++;
            if (index2 - i >= 0 && this.$isCustomWidgetVisible(index2 - i))
              return index2 - i;
            if (index2 + i <= this.lines.getLength() - 1 && this.$isCustomWidgetVisible(index2 + i))
              return index2 + i;
            if (index2 - i >= 0 && this.$isFoldWidgetVisible(index2 - i))
              return index2 - i;
            if (index2 + i <= this.lines.getLength() - 1 && this.$isFoldWidgetVisible(index2 + i))
              return index2 + i;
          }
          return null;
        };
        GutterKeyboardHandler2.prototype.$findNearestAnnotation = function(index2) {
          if (this.$isAnnotationVisible(index2))
            return index2;
          var i = 0;
          while (index2 - i > 0 || index2 + i < this.lines.getLength() - 1) {
            i++;
            if (index2 - i >= 0 && this.$isAnnotationVisible(index2 - i))
              return index2 - i;
            if (index2 + i <= this.lines.getLength() - 1 && this.$isAnnotationVisible(index2 + i))
              return index2 + i;
          }
          return null;
        };
        GutterKeyboardHandler2.prototype.$focusFoldWidget = function(index2) {
          if (index2 == null)
            return;
          var foldWidget = this.$getFoldWidget(index2);
          foldWidget.classList.add(this.editor.renderer.keyboardFocusClassName);
          foldWidget.focus();
        };
        GutterKeyboardHandler2.prototype.$focusCustomWidget = function(index2) {
          if (index2 == null)
            return;
          var customWidget = this.$getCustomWidget(index2);
          if (customWidget) {
            customWidget.classList.add(this.editor.renderer.keyboardFocusClassName);
            customWidget.focus();
          }
        };
        GutterKeyboardHandler2.prototype.$focusAnnotation = function(index2) {
          if (index2 == null)
            return;
          var annotation = this.$getAnnotation(index2);
          annotation.classList.add(this.editor.renderer.keyboardFocusClassName);
          annotation.focus();
        };
        GutterKeyboardHandler2.prototype.$blurFoldWidget = function(index2) {
          var foldWidget = this.$getFoldWidget(index2);
          foldWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);
          foldWidget.blur();
        };
        GutterKeyboardHandler2.prototype.$blurCustomWidget = function(index2) {
          var customWidget = this.$getCustomWidget(index2);
          if (customWidget) {
            customWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);
            customWidget.blur();
          }
        };
        GutterKeyboardHandler2.prototype.$blurAnnotation = function(index2) {
          var annotation = this.$getAnnotation(index2);
          annotation.classList.remove(this.editor.renderer.keyboardFocusClassName);
          annotation.blur();
        };
        GutterKeyboardHandler2.prototype.$moveFoldWidgetUp = function() {
          var index2 = this.activeRowIndex;
          while (index2 > 0) {
            index2--;
            if (this.$isFoldWidgetVisible(index2) || this.$isCustomWidgetVisible(index2)) {
              this.$blurFoldWidget(this.activeRowIndex);
              this.$blurCustomWidget(this.activeRowIndex);
              this.activeRowIndex = index2;
              if (this.$isFoldWidgetVisible(index2)) {
                this.$focusFoldWidget(this.activeRowIndex);
              } else {
                this.$focusCustomWidget(this.activeRowIndex);
              }
              return;
            }
          }
          return;
        };
        GutterKeyboardHandler2.prototype.$moveFoldWidgetDown = function() {
          var index2 = this.activeRowIndex;
          while (index2 < this.lines.getLength() - 1) {
            index2++;
            if (this.$isFoldWidgetVisible(index2) || this.$isCustomWidgetVisible(index2)) {
              this.$blurFoldWidget(this.activeRowIndex);
              this.$blurCustomWidget(this.activeRowIndex);
              this.activeRowIndex = index2;
              if (this.$isFoldWidgetVisible(index2)) {
                this.$focusFoldWidget(this.activeRowIndex);
              } else {
                this.$focusCustomWidget(this.activeRowIndex);
              }
              return;
            }
          }
          return;
        };
        GutterKeyboardHandler2.prototype.$moveAnnotationUp = function() {
          var index2 = this.activeRowIndex;
          while (index2 > 0) {
            index2--;
            if (this.$isAnnotationVisible(index2)) {
              this.$blurAnnotation(this.activeRowIndex);
              this.activeRowIndex = index2;
              this.$focusAnnotation(this.activeRowIndex);
              return;
            }
          }
          return;
        };
        GutterKeyboardHandler2.prototype.$moveAnnotationDown = function() {
          var index2 = this.activeRowIndex;
          while (index2 < this.lines.getLength() - 1) {
            index2++;
            if (this.$isAnnotationVisible(index2)) {
              this.$blurAnnotation(this.activeRowIndex);
              this.activeRowIndex = index2;
              this.$focusAnnotation(this.activeRowIndex);
              return;
            }
          }
          return;
        };
        GutterKeyboardHandler2.prototype.$findClosestNumber = function(num1, num2, target) {
          if (num1 === null)
            return num2;
          if (num2 === null)
            return num1;
          return Math.abs(target - num1) <= Math.abs(target - num2) ? num1 : num2;
        };
        GutterKeyboardHandler2.prototype.$switchLane = function(desinationLane) {
          switch (desinationLane) {
            case "annotation":
              if (this.activeLane === "annotation") {
                break;
              }
              var annotationIndex = this.$findNearestAnnotation(this.activeRowIndex);
              if (annotationIndex == null) {
                break;
              }
              this.activeLane = "annotation";
              this.$blurFoldWidget(this.activeRowIndex);
              this.$blurCustomWidget(this.activeRowIndex);
              this.activeRowIndex = annotationIndex;
              this.$focusAnnotation(this.activeRowIndex);
              break;
            case "fold":
              if (this.activeLane === "fold") {
                break;
              }
              var foldLaneWidgetIndex = this.$findNearestFoldLaneWidget(this.activeRowIndex);
              if (foldLaneWidgetIndex === null) {
                break;
              }
              this.activeLane = "fold";
              this.$blurAnnotation(this.activeRowIndex);
              this.activeRowIndex = foldLaneWidgetIndex;
              if (this.$isCustomWidgetVisible(foldLaneWidgetIndex)) {
                this.$focusCustomWidget(this.activeRowIndex);
              } else {
                this.$focusFoldWidget(this.activeRowIndex);
              }
              break;
          }
          return;
        };
        GutterKeyboardHandler2.prototype.$rowIndexToRow = function(index2) {
          var cell = this.lines.get(index2);
          if (cell)
            return cell.row;
          return null;
        };
        GutterKeyboardHandler2.prototype.$rowToRowIndex = function(row) {
          for (var i = 0; i < this.lines.getLength(); i++) {
            var cell = this.lines.get(i);
            if (cell.row == row)
              return i;
          }
          return null;
        };
        return GutterKeyboardHandler2;
      }()
    );
    exports2.GutterKeyboardHandler = GutterKeyboardHandler;
    var GutterKeyboardEvent = (
      /** @class */
      function() {
        function GutterKeyboardEvent2(domEvent, gutterKeyboardHandler) {
          this.gutterKeyboardHandler = gutterKeyboardHandler;
          this.domEvent = domEvent;
        }
        GutterKeyboardEvent2.prototype.getKey = function() {
          return keys.keyCodeToString(this.domEvent.keyCode);
        };
        GutterKeyboardEvent2.prototype.getRow = function() {
          return this.gutterKeyboardHandler.$rowIndexToRow(this.gutterKeyboardHandler.activeRowIndex);
        };
        GutterKeyboardEvent2.prototype.isInAnnotationLane = function() {
          return this.gutterKeyboardHandler.activeLane === "annotation";
        };
        GutterKeyboardEvent2.prototype.isInFoldLane = function() {
          return this.gutterKeyboardHandler.activeLane === "fold";
        };
        return GutterKeyboardEvent2;
      }()
    );
    exports2.GutterKeyboardEvent = GutterKeyboardEvent;
  });
  ace.define("ace/editor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator", "ace/keyboard/gutter_handler", "ace/config", "ace/clipboard", "ace/lib/keys", "ace/lib/event", "ace/tooltip"], function(require2, exports2, module2) {
    var __values = this && this.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var oop = require2("./lib/oop");
    var dom = require2("./lib/dom");
    var lang = require2("./lib/lang");
    var useragent = require2("./lib/useragent");
    var TextInput = require2("./keyboard/textinput").TextInput;
    var MouseHandler = require2("./mouse/mouse_handler").MouseHandler;
    var FoldHandler = require2("./mouse/fold_handler").FoldHandler;
    var KeyBinding = require2("./keyboard/keybinding").KeyBinding;
    var EditSession = require2("./edit_session").EditSession;
    var Search = require2("./search").Search;
    var Range = require2("./range").Range;
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var CommandManager = require2("./commands/command_manager").CommandManager;
    var defaultCommands = require2("./commands/default_commands").commands;
    var config = require2("./config");
    var TokenIterator = require2("./token_iterator").TokenIterator;
    var GutterKeyboardHandler = require2("./keyboard/gutter_handler").GutterKeyboardHandler;
    var nls = require2("./config").nls;
    var clipboard = require2("./clipboard");
    var keys = require2("./lib/keys");
    var event = require2("./lib/event");
    var HoverTooltip = require2("./tooltip").HoverTooltip;
    var Editor2 = (
      /** @class */
      function() {
        function Editor3(renderer, session, options) {
          this.id = "editor" + ++Editor3.$uid;
          this.session;
          this.$toDestroy = [];
          var container2 = renderer.getContainerElement();
          this.container = container2;
          this.renderer = renderer;
          this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
          if (typeof document == "object") {
            this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
            this.renderer.textarea = this.textInput.getElement();
            this.$mouseHandler = new MouseHandler(this);
            new FoldHandler(this);
          }
          this.keyBinding = new KeyBinding(this);
          this.$search = new Search().set({
            wrap: true
          });
          this.$historyTracker = this.$historyTracker.bind(this);
          this.commands.on("exec", this.$historyTracker);
          this.$initOperationListeners();
          this._$emitInputEvent = lang.delayedCall((function() {
            this._signal("input", {});
            if (this.session && !this.session.destroyed)
              this.session.bgTokenizer.scheduleStart();
          }).bind(this));
          this.on("change", function(_, _self) {
            _self._$emitInputEvent.schedule(31);
          });
          this.setSession(session || options && options.session || new EditSession(""));
          config.resetOptions(this);
          if (options)
            this.setOptions(options);
          config._signal("editor", this);
        }
        Editor3.prototype.$initOperationListeners = function() {
          this.commands.on("exec", this.startOperation.bind(this), true);
          this.commands.on("afterExec", this.endOperation.bind(this), true);
        };
        Editor3.prototype.startOperation = function(commandEvent) {
          this.session.startOperation(commandEvent);
        };
        Editor3.prototype.endOperation = function(e) {
          this.session.endOperation(e);
        };
        Editor3.prototype.onStartOperation = function(commandEvent) {
          this.curOp = this.session.curOp;
          this.curOp.scrollTop = this.renderer.scrollTop;
          this.prevOp = this.session.prevOp;
          if (!commandEvent) {
            this.previousCommand = null;
          }
        };
        Editor3.prototype.onEndOperation = function(e) {
          if (this.curOp && this.session) {
            if (e && e.returnValue === false) {
              this.curOp = null;
              return;
            }
            this._signal("beforeEndOperation");
            if (!this.curOp)
              return;
            var command = this.curOp.command;
            var scrollIntoView = command && command.scrollIntoView;
            if (scrollIntoView) {
              switch (scrollIntoView) {
                case "center-animate":
                  scrollIntoView = "animate";
                case "center":
                  this.renderer.scrollCursorIntoView(null, 0.5);
                  break;
                case "animate":
                case "cursor":
                  this.renderer.scrollCursorIntoView();
                  break;
                case "selectionPart":
                  var range = this.selection.getRange();
                  var config2 = this.renderer.layerConfig;
                  if (range.start.row >= config2.lastRow || range.end.row <= config2.firstRow) {
                    this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                  }
                  break;
              }
              if (scrollIntoView == "animate")
                this.renderer.animateScrolling(this.curOp.scrollTop);
            }
            this.$lastSel = this.session.selection.toJSON();
            this.prevOp = this.curOp;
            this.curOp = null;
          }
        };
        Editor3.prototype.$historyTracker = function(e) {
          if (!this.$mergeUndoDeltas)
            return;
          var prev = this.prevOp;
          var mergeableCommands = this.$mergeableCommands;
          var shouldMerge = prev.command && e.command.name == prev.command.name;
          if (e.command.name == "insertstring") {
            var text = e.args;
            if (this.mergeNextCommand === void 0)
              this.mergeNextCommand = true;
            shouldMerge = shouldMerge && this.mergeNextCommand && (!/\s/.test(text) || /\s/.test(prev.args));
            this.mergeNextCommand = true;
          } else {
            shouldMerge = shouldMerge && mergeableCommands.indexOf(e.command.name) !== -1;
          }
          if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2e3) {
            shouldMerge = false;
          }
          if (shouldMerge)
            this.session.mergeUndoDeltas = true;
          else if (mergeableCommands.indexOf(e.command.name) !== -1)
            this.sequenceStartTime = Date.now();
        };
        Editor3.prototype.setKeyboardHandler = function(keyboardHandler, cb) {
          if (keyboardHandler && typeof keyboardHandler === "string" && keyboardHandler != "ace") {
            this.$keybindingId = keyboardHandler;
            var _self = this;
            config.loadModule(["keybinding", keyboardHandler], function(module3) {
              if (_self.$keybindingId == keyboardHandler)
                _self.keyBinding.setKeyboardHandler(module3 && module3.handler);
              cb && cb();
            });
          } else {
            this.$keybindingId = null;
            this.keyBinding.setKeyboardHandler(keyboardHandler);
            cb && cb();
          }
        };
        Editor3.prototype.getKeyboardHandler = function() {
          return this.keyBinding.getKeyboardHandler();
        };
        Editor3.prototype.setSession = function(session) {
          if (this.session == session)
            return;
          if (this.curOp)
            this.endOperation();
          this.curOp = {};
          var oldSession = this.session;
          if (oldSession) {
            this.session.off("change", this.$onDocumentChange);
            this.session.off("changeMode", this.$onChangeMode);
            this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
            this.session.off("changeTabSize", this.$onChangeTabSize);
            this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
            this.session.off("changeWrapMode", this.$onChangeWrapMode);
            this.session.off("changeFold", this.$onChangeFold);
            this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
            this.session.off("changeBackMarker", this.$onChangeBackMarker);
            this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
            this.session.off("changeAnnotation", this.$onChangeAnnotation);
            this.session.off("changeOverwrite", this.$onCursorChange);
            this.session.off("changeScrollTop", this.$onScrollTopChange);
            this.session.off("changeScrollLeft", this.$onScrollLeftChange);
            this.session.off("startOperation", this.$onStartOperation);
            this.session.off("endOperation", this.$onEndOperation);
            var selection = this.session.getSelection();
            selection.off("changeCursor", this.$onCursorChange);
            selection.off("changeSelection", this.$onSelectionChange);
          }
          this.session = session;
          if (session) {
            this.$onDocumentChange = this.onDocumentChange.bind(this);
            session.on("change", this.$onDocumentChange);
            this.renderer.setSession(session);
            this.$onChangeMode = this.onChangeMode.bind(this);
            session.on("changeMode", this.$onChangeMode);
            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
            session.on("tokenizerUpdate", this.$onTokenizerUpdate);
            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
            session.on("changeTabSize", this.$onChangeTabSize);
            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
            session.on("changeWrapLimit", this.$onChangeWrapLimit);
            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
            session.on("changeWrapMode", this.$onChangeWrapMode);
            this.$onChangeFold = this.onChangeFold.bind(this);
            session.on("changeFold", this.$onChangeFold);
            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
            this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
            this.session.on("changeBackMarker", this.$onChangeBackMarker);
            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
            this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
            this.session.on("changeAnnotation", this.$onChangeAnnotation);
            this.$onCursorChange = this.onCursorChange.bind(this);
            this.session.on("changeOverwrite", this.$onCursorChange);
            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
            this.session.on("changeScrollTop", this.$onScrollTopChange);
            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
            this.session.on("changeScrollLeft", this.$onScrollLeftChange);
            this.selection = session.getSelection();
            this.selection.on("changeCursor", this.$onCursorChange);
            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.on("changeSelection", this.$onSelectionChange);
            this.$onStartOperation = this.onStartOperation.bind(this);
            this.session.on("startOperation", this.$onStartOperation);
            this.$onEndOperation = this.onEndOperation.bind(this);
            this.session.on("endOperation", this.$onEndOperation);
            this.onChangeMode();
            this.onCursorChange();
            this.onScrollTopChange();
            this.onScrollLeftChange();
            this.onSelectionChange();
            this.onChangeFrontMarker();
            this.onChangeBackMarker();
            this.onChangeBreakpoint();
            this.onChangeAnnotation();
            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
            this.renderer.updateFull();
          } else {
            this.selection = null;
            this.renderer.setSession(session);
          }
          this._signal("changeSession", {
            session,
            oldSession
          });
          this.curOp = null;
          oldSession && oldSession._signal("changeEditor", { oldEditor: this });
          if (oldSession)
            oldSession.$editor = null;
          session && session._signal("changeEditor", { editor: this });
          if (session)
            session.$editor = this;
          if (session && !session.destroyed)
            session.bgTokenizer.scheduleStart();
        };
        Editor3.prototype.getSession = function() {
          return this.session;
        };
        Editor3.prototype.setValue = function(val, cursorPos) {
          this.session.doc.setValue(val);
          if (!cursorPos)
            this.selectAll();
          else if (cursorPos == 1)
            this.navigateFileEnd();
          else if (cursorPos == -1)
            this.navigateFileStart();
          return val;
        };
        Editor3.prototype.getValue = function() {
          return this.session.getValue();
        };
        Editor3.prototype.getSelection = function() {
          return this.selection;
        };
        Editor3.prototype.resize = function(force) {
          this.renderer.onResize(force);
        };
        Editor3.prototype.setTheme = function(theme, cb) {
          this.renderer.setTheme(theme, cb);
        };
        Editor3.prototype.getTheme = function() {
          return this.renderer.getTheme();
        };
        Editor3.prototype.setStyle = function(style2, incluude) {
          this.renderer.setStyle(style2, incluude);
        };
        Editor3.prototype.unsetStyle = function(style2) {
          this.renderer.unsetStyle(style2);
        };
        Editor3.prototype.getFontSize = function() {
          return this.getOption("fontSize") || dom.computedStyle(this.container).fontSize;
        };
        Editor3.prototype.setFontSize = function(size) {
          this.setOption("fontSize", size);
        };
        Editor3.prototype.$highlightBrackets = function() {
          if (this.$highlightPending) {
            return;
          }
          var self2 = this;
          this.$highlightPending = true;
          setTimeout(function() {
            self2.$highlightPending = false;
            var session = self2.session;
            if (!session || session.destroyed)
              return;
            if (session.$bracketHighlight) {
              session.$bracketHighlight.markerIds.forEach(function(id2) {
                session.removeMarker(id2);
              });
              session.$bracketHighlight = null;
            }
            var pos = self2.getCursorPosition();
            var handler = self2.getKeyboardHandler();
            var isBackwards = handler && handler.$getDirectionForHighlight && handler.$getDirectionForHighlight(self2);
            var ranges = session.getMatchingBracketRanges(pos, isBackwards);
            if (!ranges) {
              var iterator = new TokenIterator(session, pos.row, pos.column);
              var token = iterator.getCurrentToken();
              if (token && /\b(?:tag-open|tag-name)/.test(token.type)) {
                var tagNamesRanges = session.getMatchingTags(pos);
                if (tagNamesRanges) {
                  ranges = [
                    tagNamesRanges.openTagName.isEmpty() ? tagNamesRanges.openTag : tagNamesRanges.openTagName,
                    tagNamesRanges.closeTagName.isEmpty() ? tagNamesRanges.closeTag : tagNamesRanges.closeTagName
                  ];
                }
              }
            }
            if (!ranges && session.$mode.getMatching)
              ranges = session.$mode.getMatching(self2.session);
            if (!ranges) {
              if (self2.getHighlightIndentGuides())
                self2.renderer.$textLayer.$highlightIndentGuide();
              return;
            }
            var markerType = "ace_bracket";
            if (!Array.isArray(ranges)) {
              ranges = [ranges];
            } else if (ranges.length == 1) {
              markerType = "ace_error_bracket";
            }
            if (ranges.length == 2) {
              if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)
                ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];
              else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)
                ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];
            }
            session.$bracketHighlight = {
              ranges,
              markerIds: ranges.map(function(range) {
                return session.addMarker(range, markerType, "text");
              })
            };
            if (self2.getHighlightIndentGuides())
              self2.renderer.$textLayer.$highlightIndentGuide();
          }, 50);
        };
        Editor3.prototype.focus = function() {
          this.textInput.focus();
        };
        Editor3.prototype.isFocused = function() {
          return this.textInput.isFocused();
        };
        Editor3.prototype.blur = function() {
          this.textInput.blur();
        };
        Editor3.prototype.onFocus = function(e) {
          if (this.$isFocused)
            return;
          this.$isFocused = true;
          this.renderer.showCursor();
          this.renderer.visualizeFocus();
          this._emit("focus", e);
        };
        Editor3.prototype.onBlur = function(e) {
          if (!this.$isFocused)
            return;
          this.$isFocused = false;
          this.renderer.hideCursor();
          this.renderer.visualizeBlur();
          this._emit("blur", e);
        };
        Editor3.prototype.$cursorChange = function() {
          this.renderer.updateCursor();
          this.$highlightBrackets();
          this.$updateHighlightActiveLine();
        };
        Editor3.prototype.onDocumentChange = function(delta) {
          var wrap = this.session.$useWrapMode;
          var lastRow = delta.start.row == delta.end.row ? delta.end.row : Infinity;
          this.renderer.updateLines(delta.start.row, lastRow, wrap);
          this._signal("change", delta);
          this.$cursorChange();
        };
        Editor3.prototype.onTokenizerUpdate = function(e) {
          var rows = e.data;
          this.renderer.updateLines(rows.first, rows.last);
        };
        Editor3.prototype.onScrollTopChange = function() {
          this.renderer.scrollToY(this.session.getScrollTop());
        };
        Editor3.prototype.onScrollLeftChange = function() {
          this.renderer.scrollToX(this.session.getScrollLeft());
        };
        Editor3.prototype.onCursorChange = function() {
          this.$cursorChange();
          this._signal("changeSelection");
        };
        Editor3.prototype.$updateHighlightActiveLine = function() {
          var session = this.getSession();
          var highlight;
          if (this.$highlightActiveLine) {
            if (this.$selectionStyle != "line" || !this.selection.isMultiLine())
              highlight = this.getCursorPosition();
            if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())
              highlight = false;
            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
              highlight = false;
          }
          if (session.$highlightLineMarker && !highlight) {
            session.removeMarker(session.$highlightLineMarker.id);
            session.$highlightLineMarker = null;
          } else if (!session.$highlightLineMarker && highlight) {
            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
            range.id = session.addMarker(range, "ace_active-line", "screenLine");
            session.$highlightLineMarker = range;
          } else if (highlight) {
            session.$highlightLineMarker.start.row = highlight.row;
            session.$highlightLineMarker.end.row = highlight.row;
            session.$highlightLineMarker.start.column = highlight.column;
            session._signal("changeBackMarker");
          }
        };
        Editor3.prototype.onSelectionChange = function(e) {
          var session = this.session;
          if (session.$selectionMarker) {
            session.removeMarker(session.$selectionMarker);
          }
          session.$selectionMarker = null;
          if (!this.selection.isEmpty()) {
            var range = this.selection.getRange();
            var style2 = this.getSelectionStyle();
            session.$selectionMarker = session.addMarker(range, "ace_selection", style2);
          } else {
            this.$updateHighlightActiveLine();
          }
          var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
          this.session.highlight(re);
          this._signal("changeSelection");
        };
        Editor3.prototype.$getSelectionHighLightRegexp = function() {
          var session = this.session;
          var selection = this.getSelectionRange();
          if (selection.isEmpty() || selection.isMultiLine())
            return;
          var startColumn = selection.start.column;
          var endColumn = selection.end.column;
          var line = session.getLine(selection.start.row);
          var needle = line.substring(startColumn, endColumn);
          if (needle.length > 5e3 || !/[\w\d]/.test(needle))
            return;
          var re = this.$search.$assembleRegExp({
            wholeWord: true,
            caseSensitive: true,
            needle
          });
          var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
          if (!re.test(wordWithBoundary))
            return;
          return re;
        };
        Editor3.prototype.onChangeFrontMarker = function() {
          this.renderer.updateFrontMarkers();
        };
        Editor3.prototype.onChangeBackMarker = function() {
          this.renderer.updateBackMarkers();
        };
        Editor3.prototype.onChangeBreakpoint = function() {
          this.renderer.updateBreakpoints();
        };
        Editor3.prototype.onChangeAnnotation = function() {
          this.renderer.setAnnotations(this.session.getAnnotations());
        };
        Editor3.prototype.onChangeMode = function(e) {
          this.renderer.updateText();
          this._emit("changeMode", e);
        };
        Editor3.prototype.onChangeWrapLimit = function() {
          this.renderer.updateFull();
        };
        Editor3.prototype.onChangeWrapMode = function() {
          this.renderer.onResize(true);
        };
        Editor3.prototype.onChangeFold = function() {
          this.$updateHighlightActiveLine();
          this.renderer.updateFull();
        };
        Editor3.prototype.getSelectedText = function() {
          return this.session.getTextRange(this.getSelectionRange());
        };
        Editor3.prototype.getCopyText = function() {
          var text = this.getSelectedText();
          var nl = this.session.doc.getNewLineCharacter();
          var copyLine = false;
          if (!text && this.$copyWithEmptySelection) {
            copyLine = true;
            var ranges = this.selection.getAllRanges();
            for (var i = 0; i < ranges.length; i++) {
              var range = ranges[i];
              if (i && ranges[i - 1].start.row == range.start.row)
                continue;
              text += this.session.getLine(range.start.row) + nl;
            }
          }
          var e = { text };
          this._signal("copy", e);
          clipboard.lineMode = copyLine ? e.text : false;
          return e.text;
        };
        Editor3.prototype.onCopy = function() {
          this.commands.exec("copy", this);
        };
        Editor3.prototype.onCut = function() {
          this.commands.exec("cut", this);
        };
        Editor3.prototype.onPaste = function(text, event2) {
          var e = { text, event: event2 };
          this.commands.exec("paste", this, e);
        };
        Editor3.prototype.$handlePaste = function(e) {
          if (typeof e == "string")
            e = { text: e };
          this._signal("paste", e);
          var text = e.text;
          var lineMode = text === clipboard.lineMode;
          var session = this.session;
          if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
            if (lineMode)
              session.insert({ row: this.selection.lead.row, column: 0 }, text);
            else
              this.insert(text);
          } else if (lineMode) {
            this.selection.rangeList.ranges.forEach(function(range2) {
              session.insert({ row: range2.start.row, column: 0 }, text);
            });
          } else {
            var lines = text.split(/\r\n|\r|\n/);
            var ranges = this.selection.rangeList.ranges;
            var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);
            if (lines.length != ranges.length || isFullLine)
              return this.commands.exec("insertstring", this, text);
            for (var i = ranges.length; i--; ) {
              var range = ranges[i];
              if (!range.isEmpty())
                session.remove(range);
              session.insert(range.start, lines[i]);
            }
          }
        };
        Editor3.prototype.execCommand = function(command, args) {
          return this.commands.exec(command, this, args);
        };
        Editor3.prototype.insert = function(text, pasted) {
          var session = this.session;
          var mode = session.getMode();
          var cursor = this.getCursorPosition();
          if (this.getBehavioursEnabled() && !pasted) {
            var transform = mode.transformAction(session.getState(cursor.row), "insertion", this, session, text);
            if (transform) {
              if (text !== transform.text) {
                if (!this.inVirtualSelectionMode) {
                  this.session.mergeUndoDeltas = false;
                  this.mergeNextCommand = false;
                }
              }
              text = transform.text;
            }
          }
          if (text == "	")
            text = this.session.getTabString();
          if (!this.selection.isEmpty()) {
            var range = this.getSelectionRange();
            cursor = this.session.remove(range);
            this.clearSelection();
          } else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
            var range = Range.fromPoints(cursor, cursor);
            range.end.column += text.length;
            this.session.remove(range);
          }
          if (text == "\n" || text == "\r\n") {
            var line = session.getLine(cursor.row);
            if (cursor.column > line.search(/\S|$/)) {
              var d = line.substr(cursor.column).search(/\S|$/);
              session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
            }
          }
          this.clearSelection();
          var start = cursor.column;
          var lineState = session.getState(cursor.row);
          var line = session.getLine(cursor.row);
          var shouldOutdent = mode.checkOutdent(lineState, line, text);
          session.insert(cursor, text);
          if (transform && transform.selection) {
            if (transform.selection.length == 2) {
              this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
            } else {
              this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
            }
          }
          if (this.$enableAutoIndent) {
            if (session.getDocument().isNewLine(text)) {
              var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
              session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);
            }
            if (shouldOutdent)
              mode.autoOutdent(lineState, session, cursor.row);
          }
        };
        Editor3.prototype.autoIndent = function() {
          var session = this.session;
          var mode = session.getMode();
          var ranges = this.selection.isEmpty() ? [new Range(0, 0, session.doc.getLength() - 1, 0)] : this.selection.getAllRanges();
          var prevLineState = "";
          var prevLine = "";
          var lineIndent = "";
          var tab2 = session.getTabString();
          for (var i = 0; i < ranges.length; i++) {
            var startRow = ranges[i].start.row;
            var endRow = ranges[i].end.row;
            for (var row = startRow; row <= endRow; row++) {
              if (row > 0) {
                prevLineState = session.getState(row - 1);
                prevLine = session.getLine(row - 1);
                lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab2);
              }
              var line = session.getLine(row);
              var currIndent = mode.$getIndent(line);
              if (lineIndent !== currIndent) {
                if (currIndent.length > 0) {
                  var range = new Range(row, 0, row, currIndent.length);
                  session.remove(range);
                }
                if (lineIndent.length > 0) {
                  session.insert({ row, column: 0 }, lineIndent);
                }
              }
              mode.autoOutdent(prevLineState, session, row);
            }
          }
        };
        Editor3.prototype.onTextInput = function(text, composition) {
          if (!composition)
            return this.keyBinding.onTextInput(text);
          this.startOperation({ command: { name: "insertstring" } });
          var applyComposition = this.applyComposition.bind(this, text, composition);
          if (this.selection.rangeCount)
            this.forEachSelection(applyComposition);
          else
            applyComposition();
          this.endOperation();
        };
        Editor3.prototype.applyComposition = function(text, composition) {
          if (composition.extendLeft || composition.extendRight) {
            var r = this.selection.getRange();
            r.start.column -= composition.extendLeft;
            r.end.column += composition.extendRight;
            if (r.start.column < 0) {
              r.start.row--;
              r.start.column += this.session.getLine(r.start.row).length + 1;
            }
            this.selection.setRange(r);
            if (!text && !r.isEmpty())
              this.remove();
          }
          if (text || !this.selection.isEmpty())
            this.insert(text, true);
          if (composition.restoreStart || composition.restoreEnd) {
            var r = this.selection.getRange();
            r.start.column -= composition.restoreStart;
            r.end.column -= composition.restoreEnd;
            this.selection.setRange(r);
          }
        };
        Editor3.prototype.onCommandKey = function(e, hashId, keyCode) {
          return this.keyBinding.onCommandKey(e, hashId, keyCode);
        };
        Editor3.prototype.setOverwrite = function(overwrite) {
          this.session.setOverwrite(overwrite);
        };
        Editor3.prototype.getOverwrite = function() {
          return this.session.getOverwrite();
        };
        Editor3.prototype.toggleOverwrite = function() {
          this.session.toggleOverwrite();
        };
        Editor3.prototype.setScrollSpeed = function(speed) {
          this.setOption("scrollSpeed", speed);
        };
        Editor3.prototype.getScrollSpeed = function() {
          return this.getOption("scrollSpeed");
        };
        Editor3.prototype.setDragDelay = function(dragDelay) {
          this.setOption("dragDelay", dragDelay);
        };
        Editor3.prototype.getDragDelay = function() {
          return this.getOption("dragDelay");
        };
        Editor3.prototype.setSelectionStyle = function(val) {
          this.setOption("selectionStyle", val);
        };
        Editor3.prototype.getSelectionStyle = function() {
          return this.getOption("selectionStyle");
        };
        Editor3.prototype.setHighlightActiveLine = function(shouldHighlight) {
          this.setOption("highlightActiveLine", shouldHighlight);
        };
        Editor3.prototype.getHighlightActiveLine = function() {
          return this.getOption("highlightActiveLine");
        };
        Editor3.prototype.setHighlightGutterLine = function(shouldHighlight) {
          this.setOption("highlightGutterLine", shouldHighlight);
        };
        Editor3.prototype.getHighlightGutterLine = function() {
          return this.getOption("highlightGutterLine");
        };
        Editor3.prototype.setHighlightSelectedWord = function(shouldHighlight) {
          this.setOption("highlightSelectedWord", shouldHighlight);
        };
        Editor3.prototype.getHighlightSelectedWord = function() {
          return this.$highlightSelectedWord;
        };
        Editor3.prototype.setAnimatedScroll = function(shouldAnimate) {
          this.renderer.setAnimatedScroll(shouldAnimate);
        };
        Editor3.prototype.getAnimatedScroll = function() {
          return this.renderer.getAnimatedScroll();
        };
        Editor3.prototype.setShowInvisibles = function(showInvisibles) {
          this.renderer.setShowInvisibles(showInvisibles);
        };
        Editor3.prototype.getShowInvisibles = function() {
          return this.renderer.getShowInvisibles();
        };
        Editor3.prototype.setDisplayIndentGuides = function(display) {
          this.renderer.setDisplayIndentGuides(display);
        };
        Editor3.prototype.getDisplayIndentGuides = function() {
          return this.renderer.getDisplayIndentGuides();
        };
        Editor3.prototype.setHighlightIndentGuides = function(highlight) {
          this.renderer.setHighlightIndentGuides(highlight);
        };
        Editor3.prototype.getHighlightIndentGuides = function() {
          return this.renderer.getHighlightIndentGuides();
        };
        Editor3.prototype.setShowPrintMargin = function(showPrintMargin) {
          this.renderer.setShowPrintMargin(showPrintMargin);
        };
        Editor3.prototype.getShowPrintMargin = function() {
          return this.renderer.getShowPrintMargin();
        };
        Editor3.prototype.setPrintMarginColumn = function(showPrintMargin) {
          this.renderer.setPrintMarginColumn(showPrintMargin);
        };
        Editor3.prototype.getPrintMarginColumn = function() {
          return this.renderer.getPrintMarginColumn();
        };
        Editor3.prototype.setReadOnly = function(readOnly) {
          this.setOption("readOnly", readOnly);
        };
        Editor3.prototype.getReadOnly = function() {
          return this.getOption("readOnly");
        };
        Editor3.prototype.setBehavioursEnabled = function(enabled) {
          this.setOption("behavioursEnabled", enabled);
        };
        Editor3.prototype.getBehavioursEnabled = function() {
          return this.getOption("behavioursEnabled");
        };
        Editor3.prototype.setWrapBehavioursEnabled = function(enabled) {
          this.setOption("wrapBehavioursEnabled", enabled);
        };
        Editor3.prototype.getWrapBehavioursEnabled = function() {
          return this.getOption("wrapBehavioursEnabled");
        };
        Editor3.prototype.setShowFoldWidgets = function(show) {
          this.setOption("showFoldWidgets", show);
        };
        Editor3.prototype.getShowFoldWidgets = function() {
          return this.getOption("showFoldWidgets");
        };
        Editor3.prototype.setFadeFoldWidgets = function(fade) {
          this.setOption("fadeFoldWidgets", fade);
        };
        Editor3.prototype.getFadeFoldWidgets = function() {
          return this.getOption("fadeFoldWidgets");
        };
        Editor3.prototype.remove = function(dir) {
          if (this.selection.isEmpty()) {
            if (dir == "left")
              this.selection.selectLeft();
            else
              this.selection.selectRight();
          }
          var range = this.getSelectionRange();
          if (this.getBehavioursEnabled()) {
            var session = this.session;
            var state = session.getState(range.start.row);
            var new_range = session.getMode().transformAction(state, "deletion", this, session, range);
            if (range.end.column === 0) {
              var text = session.getTextRange(range);
              if (text[text.length - 1] == "\n") {
                var line = session.getLine(range.end.row);
                if (/^\s+$/.test(line)) {
                  range.end.column = line.length;
                }
              }
            }
            if (new_range)
              range = new_range;
          }
          this.session.remove(range);
          this.clearSelection();
        };
        Editor3.prototype.removeWordRight = function() {
          if (this.selection.isEmpty())
            this.selection.selectWordRight();
          this.session.remove(this.getSelectionRange());
          this.clearSelection();
        };
        Editor3.prototype.removeWordLeft = function() {
          if (this.selection.isEmpty())
            this.selection.selectWordLeft();
          this.session.remove(this.getSelectionRange());
          this.clearSelection();
        };
        Editor3.prototype.removeToLineStart = function() {
          if (this.selection.isEmpty())
            this.selection.selectLineStart();
          if (this.selection.isEmpty())
            this.selection.selectLeft();
          this.session.remove(this.getSelectionRange());
          this.clearSelection();
        };
        Editor3.prototype.removeToLineEnd = function() {
          if (this.selection.isEmpty())
            this.selection.selectLineEnd();
          var range = this.getSelectionRange();
          if (range.start.column == range.end.column && range.start.row == range.end.row) {
            range.end.column = 0;
            range.end.row++;
          }
          this.session.remove(range);
          this.clearSelection();
        };
        Editor3.prototype.splitLine = function() {
          if (!this.selection.isEmpty()) {
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          }
          var cursor = this.getCursorPosition();
          this.insert("\n");
          this.moveCursorToPosition(cursor);
        };
        Editor3.prototype.setGhostText = function(text, position) {
          this.renderer.setGhostText(text, position);
        };
        Editor3.prototype.removeGhostText = function() {
          this.renderer.removeGhostText();
        };
        Editor3.prototype.transposeLetters = function() {
          if (!this.selection.isEmpty()) {
            return;
          }
          var cursor = this.getCursorPosition();
          var column = cursor.column;
          if (column === 0)
            return;
          var line = this.session.getLine(cursor.row);
          var swap, range;
          if (column < line.length) {
            swap = line.charAt(column) + line.charAt(column - 1);
            range = new Range(cursor.row, column - 1, cursor.row, column + 1);
          } else {
            swap = line.charAt(column - 1) + line.charAt(column - 2);
            range = new Range(cursor.row, column - 2, cursor.row, column);
          }
          this.session.replace(range, swap);
          this.session.selection.moveToPosition(range.end);
        };
        Editor3.prototype.toLowerCase = function() {
          var originalRange = this.getSelectionRange();
          if (this.selection.isEmpty()) {
            this.selection.selectWord();
          }
          var range = this.getSelectionRange();
          var text = this.session.getTextRange(range);
          this.session.replace(range, text.toLowerCase());
          this.selection.setSelectionRange(originalRange);
        };
        Editor3.prototype.toUpperCase = function() {
          var originalRange = this.getSelectionRange();
          if (this.selection.isEmpty()) {
            this.selection.selectWord();
          }
          var range = this.getSelectionRange();
          var text = this.session.getTextRange(range);
          this.session.replace(range, text.toUpperCase());
          this.selection.setSelectionRange(originalRange);
        };
        Editor3.prototype.indent = function() {
          var session = this.session;
          var range = this.getSelectionRange();
          if (range.start.row < range.end.row) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, "	");
            return;
          } else if (range.start.column < range.end.column) {
            var text = session.getTextRange(range);
            if (!/^\s+$/.test(text)) {
              var rows = this.$getSelectedRows();
              session.indentRows(rows.first, rows.last, "	");
              return;
            }
          }
          var line = session.getLine(range.start.row);
          var position = range.start;
          var size = session.getTabSize();
          var column = session.documentToScreenColumn(position.row, position.column);
          if (this.session.getUseSoftTabs()) {
            var count = size - column % size;
            var indentString = lang.stringRepeat(" ", count);
          } else {
            var count = column % size;
            while (line[range.start.column - 1] == " " && count) {
              range.start.column--;
              count--;
            }
            this.selection.setSelectionRange(range);
            indentString = "	";
          }
          return this.insert(indentString);
        };
        Editor3.prototype.blockIndent = function() {
          var rows = this.$getSelectedRows();
          this.session.indentRows(rows.first, rows.last, "	");
        };
        Editor3.prototype.blockOutdent = function() {
          var selection = this.session.getSelection();
          this.session.outdentRows(selection.getRange());
        };
        Editor3.prototype.sortLines = function() {
          var rows = this.$getSelectedRows();
          var session = this.session;
          var lines = [];
          for (var i = rows.first; i <= rows.last; i++)
            lines.push(session.getLine(i));
          lines.sort(function(a, b) {
            if (a.toLowerCase() < b.toLowerCase())
              return -1;
            if (a.toLowerCase() > b.toLowerCase())
              return 1;
            return 0;
          });
          var deleteRange = new Range(0, 0, 0, 0);
          for (var i = rows.first; i <= rows.last; i++) {
            var line = session.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            deleteRange.end.column = line.length;
            session.replace(deleteRange, lines[i - rows.first]);
          }
        };
        Editor3.prototype.toggleCommentLines = function() {
          var state = this.session.getState(this.getCursorPosition().row);
          var rows = this.$getSelectedRows();
          this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
        };
        Editor3.prototype.toggleBlockComment = function() {
          var cursor = this.getCursorPosition();
          var state = this.session.getState(cursor.row);
          var range = this.getSelectionRange();
          this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
        };
        Editor3.prototype.getNumberAt = function(row, column) {
          var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
          _numberRx.lastIndex = 0;
          var s = this.session.getLine(row);
          while (_numberRx.lastIndex < column) {
            var m = _numberRx.exec(s);
            if (m.index <= column && m.index + m[0].length >= column) {
              var number = {
                value: m[0],
                start: m.index,
                end: m.index + m[0].length
              };
              return number;
            }
          }
          return null;
        };
        Editor3.prototype.modifyNumber = function(amount) {
          var row = this.selection.getCursor().row;
          var column = this.selection.getCursor().column;
          var charRange = new Range(row, column - 1, row, column);
          var c = this.session.getTextRange(charRange);
          if (!isNaN(parseFloat(c)) && isFinite(c)) {
            var nr = this.getNumberAt(row, column);
            if (nr) {
              var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
              var decimals = nr.start + nr.value.length - fp;
              var t = parseFloat(nr.value);
              t *= Math.pow(10, decimals);
              if (fp !== nr.end && column < fp) {
                amount *= Math.pow(10, nr.end - column - 1);
              } else {
                amount *= Math.pow(10, nr.end - column);
              }
              t += amount;
              t /= Math.pow(10, decimals);
              var nnr = t.toFixed(decimals);
              var replaceRange = new Range(row, nr.start, row, nr.end);
              this.session.replace(replaceRange, nnr);
              this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
            }
          } else {
            this.toggleWord();
          }
        };
        Editor3.prototype.toggleWord = function() {
          var row = this.selection.getCursor().row;
          var column = this.selection.getCursor().column;
          this.selection.selectWord();
          var currentState = this.getSelectedText();
          var currWordStart = this.selection.getWordRange().start.column;
          var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, "$1 ").split(/\s/);
          var delta = column - currWordStart - 1;
          if (delta < 0)
            delta = 0;
          var curLength = 0, itLength = 0;
          var that = this;
          if (currentState.match(/[A-Za-z0-9_]+/)) {
            wordParts.forEach(function(item3, i2) {
              itLength = curLength + item3.length;
              if (delta >= curLength && delta <= itLength) {
                currentState = item3;
                that.selection.clearSelection();
                that.moveCursorTo(row, curLength + currWordStart);
                that.selection.selectTo(row, itLength + currWordStart);
              }
              curLength = itLength;
            });
          }
          var wordPairs = this.$toggleWordPairs;
          var reg;
          for (var i = 0; i < wordPairs.length; i++) {
            var item2 = wordPairs[i];
            for (var j = 0; j <= 1; j++) {
              var negate = +!j;
              var firstCondition = currentState.match(new RegExp("^\\s?_?(" + lang.escapeRegExp(item2[j]) + ")\\s?$", "i"));
              if (firstCondition) {
                var secondCondition = currentState.match(new RegExp("([_]|^|\\s)(" + lang.escapeRegExp(firstCondition[1]) + ")($|\\s)", "g"));
                if (secondCondition) {
                  reg = currentState.replace(new RegExp(lang.escapeRegExp(item2[j]), "i"), function(result) {
                    var res = item2[negate];
                    if (result.toUpperCase() == result) {
                      res = res.toUpperCase();
                    } else if (result.charAt(0).toUpperCase() == result.charAt(0)) {
                      res = res.substr(0, 0) + item2[negate].charAt(0).toUpperCase() + res.substr(1);
                    }
                    return res;
                  });
                  this.insert(reg);
                  reg = "";
                }
              }
            }
          }
        };
        Editor3.prototype.findLinkAt = function(row, column) {
          var e_1, _a;
          var line = this.session.getLine(row);
          var wordParts = line.split(/((?:https?|ftp):\/\/[\S]+)/);
          var columnPosition = column;
          if (columnPosition < 0)
            columnPosition = 0;
          var previousPosition = 0, currentPosition = 0, match;
          try {
            for (var wordParts_1 = __values(wordParts), wordParts_1_1 = wordParts_1.next(); !wordParts_1_1.done; wordParts_1_1 = wordParts_1.next()) {
              var item2 = wordParts_1_1.value;
              currentPosition = previousPosition + item2.length;
              if (columnPosition >= previousPosition && columnPosition <= currentPosition) {
                if (item2.match(/((?:https?|ftp):\/\/[\S]+)/)) {
                  match = item2.replace(/[\s:.,'";}\]]+$/, "");
                  break;
                }
              }
              previousPosition = currentPosition;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (wordParts_1_1 && !wordParts_1_1.done && (_a = wordParts_1.return)) _a.call(wordParts_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return match;
        };
        Editor3.prototype.openLink = function() {
          var cursor = this.selection.getCursor();
          var url = this.findLinkAt(cursor.row, cursor.column);
          if (url)
            window.open(url, "_blank");
          return url != null;
        };
        Editor3.prototype.removeLines = function() {
          var rows = this.$getSelectedRows();
          this.session.removeFullLines(rows.first, rows.last);
          this.clearSelection();
        };
        Editor3.prototype.duplicateSelection = function() {
          var sel = this.selection;
          var doc = this.session;
          var range = sel.getRange();
          var reverse = sel.isBackwards();
          if (range.isEmpty()) {
            var row = range.start.row;
            doc.duplicateLines(row, row);
          } else {
            var point = reverse ? range.start : range.end;
            var endPoint = doc.insert(point, doc.getTextRange(range));
            range.start = point;
            range.end = endPoint;
            sel.setSelectionRange(range, reverse);
          }
        };
        Editor3.prototype.moveLinesDown = function() {
          this.$moveLines(1, false);
        };
        Editor3.prototype.moveLinesUp = function() {
          this.$moveLines(-1, false);
        };
        Editor3.prototype.moveText = function(range, toPosition, copy) {
          return this.session.moveText(range, toPosition, copy);
        };
        Editor3.prototype.copyLinesUp = function() {
          this.$moveLines(-1, true);
        };
        Editor3.prototype.copyLinesDown = function() {
          this.$moveLines(1, true);
        };
        Editor3.prototype.$moveLines = function(dir, copy) {
          var rows, moved;
          var selection = this.selection;
          if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
            var range = selection.toOrientedRange();
            rows = this.$getSelectedRows(range);
            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
            if (copy && dir == -1)
              moved = 0;
            range.moveBy(moved, 0);
            selection.fromOrientedRange(range);
          } else {
            var ranges = selection.rangeList.ranges;
            selection.rangeList.detach(this.session);
            this.inVirtualSelectionMode = true;
            var diff = 0;
            var totalDiff = 0;
            var l = ranges.length;
            for (var i = 0; i < l; i++) {
              var rangeIndex = i;
              ranges[i].moveBy(diff, 0);
              rows = this.$getSelectedRows(ranges[i]);
              var first = rows.first;
              var last = rows.last;
              while (++i < l) {
                if (totalDiff)
                  ranges[i].moveBy(totalDiff, 0);
                var subRows = this.$getSelectedRows(ranges[i]);
                if (copy && subRows.first != last)
                  break;
                else if (!copy && subRows.first > last + 1)
                  break;
                last = subRows.last;
              }
              i--;
              diff = this.session.$moveLines(first, last, copy ? 0 : dir);
              if (copy && dir == -1)
                rangeIndex = i + 1;
              while (rangeIndex <= i) {
                ranges[rangeIndex].moveBy(diff, 0);
                rangeIndex++;
              }
              if (!copy)
                diff = 0;
              totalDiff += diff;
            }
            selection.fromOrientedRange(selection.ranges[0]);
            selection.rangeList.attach(this.session);
            this.inVirtualSelectionMode = false;
          }
        };
        Editor3.prototype.$getSelectedRows = function(range) {
          range = (range || this.getSelectionRange()).collapseRows();
          return {
            first: this.session.getRowFoldStart(range.start.row),
            last: this.session.getRowFoldEnd(range.end.row)
          };
        };
        Editor3.prototype.onCompositionStart = function(compositionState) {
          this.renderer.showComposition(compositionState);
        };
        Editor3.prototype.onCompositionUpdate = function(text) {
          this.renderer.setCompositionText(text);
        };
        Editor3.prototype.onCompositionEnd = function() {
          this.renderer.hideComposition();
        };
        Editor3.prototype.getFirstVisibleRow = function() {
          return this.renderer.getFirstVisibleRow();
        };
        Editor3.prototype.getLastVisibleRow = function() {
          return this.renderer.getLastVisibleRow();
        };
        Editor3.prototype.isRowVisible = function(row) {
          return row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow();
        };
        Editor3.prototype.isRowFullyVisible = function(row) {
          return row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow();
        };
        Editor3.prototype.$getVisibleRowCount = function() {
          return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
        };
        Editor3.prototype.$moveByPage = function(dir, select) {
          var renderer = this.renderer;
          var config2 = this.renderer.layerConfig;
          var rows = dir * Math.floor(config2.height / config2.lineHeight);
          if (select === true) {
            this.selection.$moveSelection(function() {
              this.moveCursorBy(rows, 0);
            });
          } else if (select === false) {
            this.selection.moveCursorBy(rows, 0);
            this.selection.clearSelection();
          }
          var scrollTop = renderer.scrollTop;
          renderer.scrollBy(0, rows * config2.lineHeight);
          if (select != null)
            renderer.scrollCursorIntoView(null, 0.5);
          renderer.animateScrolling(scrollTop);
        };
        Editor3.prototype.selectPageDown = function() {
          this.$moveByPage(1, true);
        };
        Editor3.prototype.selectPageUp = function() {
          this.$moveByPage(-1, true);
        };
        Editor3.prototype.gotoPageDown = function() {
          this.$moveByPage(1, false);
        };
        Editor3.prototype.gotoPageUp = function() {
          this.$moveByPage(-1, false);
        };
        Editor3.prototype.scrollPageDown = function() {
          this.$moveByPage(1);
        };
        Editor3.prototype.scrollPageUp = function() {
          this.$moveByPage(-1);
        };
        Editor3.prototype.scrollToRow = function(row) {
          this.renderer.scrollToRow(row);
        };
        Editor3.prototype.scrollToLine = function(line, center, animate, callback) {
          this.renderer.scrollToLine(line, center, animate, callback);
        };
        Editor3.prototype.centerSelection = function() {
          var range = this.getSelectionRange();
          var pos = {
            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
          };
          this.renderer.alignCursor(pos, 0.5);
        };
        Editor3.prototype.getCursorPosition = function() {
          return this.selection.getCursor();
        };
        Editor3.prototype.getCursorPositionScreen = function() {
          return this.session.documentToScreenPosition(this.getCursorPosition());
        };
        Editor3.prototype.getSelectionRange = function() {
          return this.selection.getRange();
        };
        Editor3.prototype.selectAll = function() {
          this.selection.selectAll();
        };
        Editor3.prototype.clearSelection = function() {
          this.selection.clearSelection();
        };
        Editor3.prototype.moveCursorTo = function(row, column) {
          this.selection.moveCursorTo(row, column);
        };
        Editor3.prototype.moveCursorToPosition = function(pos) {
          this.selection.moveCursorToPosition(pos);
        };
        Editor3.prototype.jumpToMatching = function(select, expand) {
          var cursor = this.getCursorPosition();
          var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
          var prevToken = iterator.getCurrentToken();
          var tokenCount = 0;
          if (prevToken && prevToken.type.indexOf("tag-name") !== -1) {
            prevToken = iterator.stepBackward();
          }
          var token = prevToken || iterator.stepForward();
          if (!token)
            return;
          var matchType;
          var found = false;
          var depth = {};
          var i = cursor.column - token.start;
          var bracketType;
          var brackets = {
            ")": "(",
            "(": "(",
            "]": "[",
            "[": "[",
            "{": "{",
            "}": "{"
          };
          do {
            if (token.value.match(/[{}()\[\]]/g)) {
              for (; i < token.value.length && !found; i++) {
                if (!brackets[token.value[i]]) {
                  continue;
                }
                bracketType = brackets[token.value[i]] + "." + token.type.replace("rparen", "lparen");
                if (isNaN(depth[bracketType])) {
                  depth[bracketType] = 0;
                }
                switch (token.value[i]) {
                  case "(":
                  case "[":
                  case "{":
                    depth[bracketType]++;
                    break;
                  case ")":
                  case "]":
                  case "}":
                    depth[bracketType]--;
                    if (depth[bracketType] === -1) {
                      matchType = "bracket";
                      found = true;
                    }
                    break;
                }
              }
            } else if (token.type.indexOf("tag-name") !== -1) {
              if (isNaN(depth[token.value])) {
                depth[token.value] = 0;
              }
              if (prevToken.value === "<" && tokenCount > 1) {
                depth[token.value]++;
              } else if (prevToken.value === "</") {
                depth[token.value]--;
              }
              if (depth[token.value] === -1) {
                matchType = "tag";
                found = true;
              }
            }
            if (!found) {
              prevToken = token;
              tokenCount++;
              token = iterator.stepForward();
              i = 0;
            }
          } while (token && !found);
          if (!matchType)
            return;
          var range, pos;
          if (matchType === "bracket") {
            range = this.session.getBracketRange(cursor);
            if (!range) {
              range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
              pos = range.start;
              if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                range = this.session.getBracketRange(pos);
            }
          } else if (matchType === "tag") {
            if (!token || token.type.indexOf("tag-name") === -1)
              return;
            range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
            if (range.compare(cursor.row, cursor.column) === 0) {
              var tagsRanges = this.session.getMatchingTags(cursor);
              if (tagsRanges) {
                if (tagsRanges.openTag.contains(cursor.row, cursor.column)) {
                  range = tagsRanges.closeTag;
                  pos = range.start;
                } else {
                  range = tagsRanges.openTag;
                  if (tagsRanges.closeTag.start.row === cursor.row && tagsRanges.closeTag.start.column === cursor.column)
                    pos = range.end;
                  else
                    pos = range.start;
                }
              }
            }
            pos = pos || range.start;
          }
          pos = range && range.cursor || pos;
          if (pos) {
            if (select) {
              if (range && expand) {
                this.selection.setRange(range);
              } else if (range && range.isEqual(this.getSelectionRange())) {
                this.clearSelection();
              } else {
                this.selection.selectTo(pos.row, pos.column);
              }
            } else {
              this.selection.moveTo(pos.row, pos.column);
            }
          }
        };
        Editor3.prototype.gotoLine = function(lineNumber, column, animate) {
          this.selection.clearSelection();
          this.session.unfold({ row: lineNumber - 1, column: column || 0 });
          this.exitMultiSelectMode && this.exitMultiSelectMode();
          this.moveCursorTo(lineNumber - 1, column || 0);
          if (!this.isRowFullyVisible(lineNumber - 1))
            this.scrollToLine(lineNumber - 1, true, animate);
        };
        Editor3.prototype.navigateTo = function(row, column) {
          this.selection.moveTo(row, column);
        };
        Editor3.prototype.navigateUp = function(times) {
          if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
            var selectionStart = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionStart);
          }
          this.selection.clearSelection();
          this.selection.moveCursorBy(-times || -1, 0);
        };
        Editor3.prototype.navigateDown = function(times) {
          if (this.selection.isMultiLine() && this.selection.isBackwards()) {
            var selectionEnd = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionEnd);
          }
          this.selection.clearSelection();
          this.selection.moveCursorBy(times || 1, 0);
        };
        Editor3.prototype.navigateLeft = function(times) {
          if (!this.selection.isEmpty()) {
            var selectionStart = this.getSelectionRange().start;
            this.moveCursorToPosition(selectionStart);
          } else {
            times = times || 1;
            while (times--) {
              this.selection.moveCursorLeft();
            }
          }
          this.clearSelection();
        };
        Editor3.prototype.navigateRight = function(times) {
          if (!this.selection.isEmpty()) {
            var selectionEnd = this.getSelectionRange().end;
            this.moveCursorToPosition(selectionEnd);
          } else {
            times = times || 1;
            while (times--) {
              this.selection.moveCursorRight();
            }
          }
          this.clearSelection();
        };
        Editor3.prototype.navigateLineStart = function() {
          this.selection.moveCursorLineStart();
          this.clearSelection();
        };
        Editor3.prototype.navigateLineEnd = function() {
          this.selection.moveCursorLineEnd();
          this.clearSelection();
        };
        Editor3.prototype.navigateFileEnd = function() {
          this.selection.moveCursorFileEnd();
          this.clearSelection();
        };
        Editor3.prototype.navigateFileStart = function() {
          this.selection.moveCursorFileStart();
          this.clearSelection();
        };
        Editor3.prototype.navigateWordRight = function() {
          this.selection.moveCursorWordRight();
          this.clearSelection();
        };
        Editor3.prototype.navigateWordLeft = function() {
          this.selection.moveCursorWordLeft();
          this.clearSelection();
        };
        Editor3.prototype.replace = function(replacement, options) {
          if (options)
            this.$search.set(options);
          var range = this.$search.find(this.session);
          var replaced = 0;
          if (!range)
            return replaced;
          if (this.$tryReplace(range, replacement)) {
            replaced = 1;
          }
          this.selection.setSelectionRange(range);
          this.renderer.scrollSelectionIntoView(range.start, range.end);
          return replaced;
        };
        Editor3.prototype.replaceAll = function(replacement, options) {
          if (options) {
            this.$search.set(options);
          }
          var ranges = this.$search.findAll(this.session);
          var replaced = 0;
          if (!ranges.length)
            return replaced;
          var selection = this.getSelectionRange();
          this.selection.moveTo(0, 0);
          for (var i = ranges.length - 1; i >= 0; --i) {
            if (this.$tryReplace(ranges[i], replacement)) {
              replaced++;
            }
          }
          this.selection.setSelectionRange(selection);
          return replaced;
        };
        Editor3.prototype.$tryReplace = function(range, replacement) {
          var input = this.session.getTextRange(range);
          replacement = this.$search.replace(input, replacement);
          if (replacement !== null) {
            range.end = this.session.replace(range, replacement);
            return range;
          } else {
            return null;
          }
        };
        Editor3.prototype.getLastSearchOptions = function() {
          return this.$search.getOptions();
        };
        Editor3.prototype.find = function(needle, options, animate) {
          if (!options)
            options = {};
          if (typeof needle == "string" || needle instanceof RegExp)
            options.needle = needle;
          else if (typeof needle == "object")
            oop.mixin(options, needle);
          var range = this.selection.getRange();
          if (options.needle == null) {
            needle = this.session.getTextRange(range) || this.$search.$options.needle;
            if (!needle) {
              range = this.session.getWordRange(range.start.row, range.start.column);
              needle = this.session.getTextRange(range);
            }
            this.$search.set({ needle });
          }
          this.$search.set(options);
          if (!options.start)
            this.$search.set({ start: range });
          var newRange = this.$search.find(this.session);
          if (options.preventScroll)
            return newRange;
          if (newRange) {
            this.revealRange(newRange, animate);
            return newRange;
          }
          if (options.backwards)
            range.start = range.end;
          else
            range.end = range.start;
          this.selection.setRange(range);
        };
        Editor3.prototype.findNext = function(options, animate) {
          this.find({ skipCurrent: true, backwards: false }, options, animate);
        };
        Editor3.prototype.findPrevious = function(options, animate) {
          this.find(options, { skipCurrent: true, backwards: true }, animate);
        };
        Editor3.prototype.revealRange = function(range, animate) {
          this.session.unfold(range);
          this.selection.setSelectionRange(range);
          var scrollTop = this.renderer.scrollTop;
          this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
          if (animate !== false)
            this.renderer.animateScrolling(scrollTop);
        };
        Editor3.prototype.undo = function() {
          this.session.getUndoManager().undo(this.session);
          this.renderer.scrollCursorIntoView(null, 0.5);
        };
        Editor3.prototype.redo = function() {
          this.session.getUndoManager().redo(this.session);
          this.renderer.scrollCursorIntoView(null, 0.5);
        };
        Editor3.prototype.destroy = function() {
          this.destroyed = true;
          if (this.$toDestroy) {
            this.$toDestroy.forEach(function(el) {
              el.destroy();
            });
            this.$toDestroy = [];
          }
          if (this.$mouseHandler)
            this.$mouseHandler.destroy();
          this.renderer.destroy();
          this._signal("destroy", this);
          if (this.session)
            this.session.destroy();
          if (this._$emitInputEvent)
            this._$emitInputEvent.cancel();
          this.removeAllListeners();
        };
        Editor3.prototype.setAutoScrollEditorIntoView = function(enable) {
          if (!enable)
            return;
          var rect;
          var self2 = this;
          var shouldScroll = false;
          if (!this.$scrollAnchor)
            this.$scrollAnchor = document.createElement("div");
          var scrollAnchor = this.$scrollAnchor;
          scrollAnchor.style.cssText = "position:absolute";
          this.container.insertBefore(scrollAnchor, this.container.firstChild);
          var onChangeSelection = this.on("changeSelection", function() {
            shouldScroll = true;
          });
          var onBeforeRender = this.renderer.on("beforeRender", function() {
            if (shouldScroll)
              rect = self2.renderer.container.getBoundingClientRect();
          });
          var onAfterRender = this.renderer.on("afterRender", function() {
            if (shouldScroll && rect && (self2.isFocused() || self2.searchBox && self2.searchBox.isFocused())) {
              var renderer = self2.renderer;
              var pos = renderer.$cursorLayer.$pixelPos;
              var config2 = renderer.layerConfig;
              var top = pos.top - config2.offset;
              if (pos.top >= 0 && top + rect.top < 0) {
                shouldScroll = true;
              } else if (pos.top < config2.height && pos.top + rect.top + config2.lineHeight > window.innerHeight) {
                shouldScroll = false;
              } else {
                shouldScroll = null;
              }
              if (shouldScroll != null) {
                scrollAnchor.style.top = top + "px";
                scrollAnchor.style.left = pos.left + "px";
                scrollAnchor.style.height = config2.lineHeight + "px";
                scrollAnchor.scrollIntoView(shouldScroll);
              }
              shouldScroll = rect = null;
            }
          });
          this.setAutoScrollEditorIntoView = function(enable2) {
            if (enable2)
              return;
            delete this.setAutoScrollEditorIntoView;
            this.off("changeSelection", onChangeSelection);
            this.renderer.off("afterRender", onAfterRender);
            this.renderer.off("beforeRender", onBeforeRender);
          };
        };
        Editor3.prototype.$resetCursorStyle = function() {
          var style2 = this.$cursorStyle || "ace";
          var cursorLayer = this.renderer.$cursorLayer;
          if (!cursorLayer)
            return;
          cursorLayer.setSmoothBlinking(/smooth/.test(style2));
          cursorLayer.isBlinking = !this.$readOnly && style2 != "wide";
          dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style2));
        };
        Editor3.prototype.prompt = function(message, options, callback) {
          var editor2 = this;
          config.loadModule("ace/ext/prompt", function(module3) {
            module3.prompt(editor2, message, options, callback);
          });
        };
        return Editor3;
      }()
    );
    Editor2.$uid = 0;
    Editor2.prototype.curOp = null;
    Editor2.prototype.prevOp = {};
    Editor2.prototype.$mergeableCommands = ["backspace", "del", "insertstring"];
    Editor2.prototype.$toggleWordPairs = [
      ["first", "last"],
      ["true", "false"],
      ["yes", "no"],
      ["width", "height"],
      ["top", "bottom"],
      ["right", "left"],
      ["on", "off"],
      ["x", "y"],
      ["get", "set"],
      ["max", "min"],
      ["horizontal", "vertical"],
      ["show", "hide"],
      ["add", "remove"],
      ["up", "down"],
      ["before", "after"],
      ["even", "odd"],
      ["in", "out"],
      ["inside", "outside"],
      ["next", "previous"],
      ["increase", "decrease"],
      ["attach", "detach"],
      ["&&", "||"],
      ["==", "!="]
    ];
    oop.implement(Editor2.prototype, EventEmitter);
    config.defineOptions(Editor2.prototype, "editor", {
      selectionStyle: {
        set: function(style2) {
          this.onSelectionChange();
          this._signal("changeSelectionStyle", { data: style2 });
        },
        initialValue: "line"
      },
      highlightActiveLine: {
        set: function() {
          this.$updateHighlightActiveLine();
        },
        initialValue: true
      },
      highlightSelectedWord: {
        set: function(shouldHighlight) {
          this.$onSelectionChange();
        },
        initialValue: true
      },
      readOnly: {
        set: function(readOnly) {
          var _this = this;
          this.textInput.setReadOnly(readOnly);
          if (this.destroyed)
            return;
          this.$resetCursorStyle();
          if (!this.$readOnlyCallback) {
            this.$readOnlyCallback = function(e) {
              var shouldShow = false;
              if (e && e.type == "keydown") {
                if (e && e.key && !e.ctrlKey && !e.metaKey) {
                  if (e.key == " ")
                    e.preventDefault();
                  shouldShow = e.key.length == 1;
                }
                if (!shouldShow)
                  return;
              } else if (e && e.type !== "exec") {
                shouldShow = true;
              }
              if (shouldShow) {
                if (!_this.hoverTooltip) {
                  _this.hoverTooltip = new HoverTooltip();
                }
                var domNode = dom.createElement("div");
                domNode.textContent = nls("editor.tooltip.disable-editing", "Editing is disabled");
                if (!_this.hoverTooltip.isOpen) {
                  _this.hoverTooltip.showForRange(_this, _this.getSelectionRange(), domNode);
                }
              } else if (_this.hoverTooltip && _this.hoverTooltip.isOpen) {
                _this.hoverTooltip.hide();
              }
            };
          }
          var textArea = this.textInput.getElement();
          if (readOnly) {
            event.addListener(textArea, "keydown", this.$readOnlyCallback, this);
            this.commands.on("exec", this.$readOnlyCallback);
            this.commands.on("commandUnavailable", this.$readOnlyCallback);
          } else {
            event.removeListener(textArea, "keydown", this.$readOnlyCallback);
            this.commands.off("exec", this.$readOnlyCallback);
            this.commands.off("commandUnavailable", this.$readOnlyCallback);
            if (this.hoverTooltip) {
              this.hoverTooltip.destroy();
              this.hoverTooltip = null;
            }
          }
        },
        initialValue: false
      },
      copyWithEmptySelection: {
        set: function(value) {
          this.textInput.setCopyWithEmptySelection(value);
        },
        initialValue: false
      },
      cursorStyle: {
        set: function(val) {
          this.$resetCursorStyle();
        },
        values: ["ace", "slim", "smooth", "wide"],
        initialValue: "ace"
      },
      mergeUndoDeltas: {
        values: [false, true, "always"],
        initialValue: true
      },
      behavioursEnabled: { initialValue: true },
      wrapBehavioursEnabled: { initialValue: true },
      enableAutoIndent: { initialValue: true },
      autoScrollEditorIntoView: {
        set: function(val) {
          this.setAutoScrollEditorIntoView(val);
        }
      },
      keyboardHandler: {
        set: function(val) {
          this.setKeyboardHandler(val);
        },
        get: function() {
          return this.$keybindingId;
        },
        handlesSet: true
      },
      value: {
        set: function(val) {
          this.session.setValue(val);
        },
        get: function() {
          return this.getValue();
        },
        handlesSet: true,
        hidden: true
      },
      session: {
        set: function(val) {
          this.setSession(val);
        },
        get: function() {
          return this.session;
        },
        handlesSet: true,
        hidden: true
      },
      showLineNumbers: {
        set: function(show) {
          this.renderer.$gutterLayer.setShowLineNumbers(show);
          this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
          if (show && this.$relativeLineNumbers)
            relativeNumberRenderer.attach(this);
          else
            relativeNumberRenderer.detach(this);
        },
        initialValue: true
      },
      relativeLineNumbers: {
        set: function(value) {
          if (this.$showLineNumbers && value)
            relativeNumberRenderer.attach(this);
          else
            relativeNumberRenderer.detach(this);
        }
      },
      placeholder: {
        set: function(message) {
          if (!this.$updatePlaceholder) {
            this.$updatePlaceholder = (function() {
              var hasValue = this.session && (this.renderer.$composition || this.session.getLength() > 1 || this.session.getLine(0).length > 0);
              if (hasValue && this.renderer.placeholderNode) {
                this.renderer.off("afterRender", this.$updatePlaceholder);
                dom.removeCssClass(this.container, "ace_hasPlaceholder");
                this.renderer.placeholderNode.remove();
                this.renderer.placeholderNode = null;
              } else if (!hasValue && !this.renderer.placeholderNode) {
                this.renderer.on("afterRender", this.$updatePlaceholder);
                dom.addCssClass(this.container, "ace_hasPlaceholder");
                var el = dom.createElement("div");
                el.className = "ace_placeholder";
                el.textContent = this.$placeholder || "";
                this.renderer.placeholderNode = el;
                this.renderer.content.appendChild(this.renderer.placeholderNode);
              } else if (!hasValue && this.renderer.placeholderNode) {
                this.renderer.placeholderNode.textContent = this.$placeholder || "";
              }
            }).bind(this);
            this.on("input", this.$updatePlaceholder);
          }
          this.$updatePlaceholder();
        }
      },
      enableKeyboardAccessibility: {
        set: function(value) {
          var blurCommand = {
            name: "blurTextInput",
            description: "Set focus to the editor content div to allow tabbing through the page",
            bindKey: "Esc",
            exec: function(editor2) {
              editor2.blur();
              editor2.renderer.scroller.focus();
            },
            readOnly: true
          };
          var focusOnEnterKeyup = function(e) {
            if (e.target == this.renderer.scroller && e.keyCode === keys["enter"]) {
              e.preventDefault();
              var row = this.getCursorPosition().row;
              if (!this.isRowVisible(row))
                this.scrollToLine(row, true, true);
              this.focus();
            }
          };
          var gutterKeyboardHandler;
          if (value) {
            this.renderer.enableKeyboardAccessibility = true;
            this.renderer.keyboardFocusClassName = "ace_keyboard-focus";
            this.textInput.getElement().setAttribute("tabindex", -1);
            this.textInput.setNumberOfExtraLines(useragent.isWin ? 3 : 0);
            this.renderer.scroller.setAttribute("tabindex", 0);
            this.renderer.scroller.setAttribute("role", "group");
            this.renderer.scroller.setAttribute("aria-roledescription", nls("editor.scroller.aria-roledescription", "editor"));
            this.renderer.scroller.classList.add(this.renderer.keyboardFocusClassName);
            this.renderer.scroller.setAttribute("aria-label", nls("editor.scroller.aria-label", "Editor content, press Enter to start editing, press Escape to exit"));
            this.renderer.scroller.addEventListener("keyup", focusOnEnterKeyup.bind(this));
            this.commands.addCommand(blurCommand);
            this.renderer.$gutter.setAttribute("tabindex", 0);
            this.renderer.$gutter.setAttribute("aria-hidden", false);
            this.renderer.$gutter.setAttribute("role", "group");
            this.renderer.$gutter.setAttribute("aria-roledescription", nls("editor.gutter.aria-roledescription", "editor gutter"));
            this.renderer.$gutter.setAttribute("aria-label", nls("editor.gutter.aria-label", "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit"));
            this.renderer.$gutter.classList.add(this.renderer.keyboardFocusClassName);
            this.renderer.content.setAttribute("aria-hidden", true);
            if (!gutterKeyboardHandler)
              gutterKeyboardHandler = new GutterKeyboardHandler(this);
            gutterKeyboardHandler.addListener();
            this.textInput.setAriaOptions({
              setLabel: true
            });
          } else {
            this.renderer.enableKeyboardAccessibility = false;
            this.textInput.getElement().setAttribute("tabindex", 0);
            this.textInput.setNumberOfExtraLines(0);
            this.renderer.scroller.setAttribute("tabindex", -1);
            this.renderer.scroller.removeAttribute("role");
            this.renderer.scroller.removeAttribute("aria-roledescription");
            this.renderer.scroller.classList.remove(this.renderer.keyboardFocusClassName);
            this.renderer.scroller.removeAttribute("aria-label");
            this.renderer.scroller.removeEventListener("keyup", focusOnEnterKeyup.bind(this));
            this.commands.removeCommand(blurCommand);
            this.renderer.content.removeAttribute("aria-hidden");
            this.renderer.$gutter.setAttribute("tabindex", -1);
            this.renderer.$gutter.setAttribute("aria-hidden", true);
            this.renderer.$gutter.removeAttribute("role");
            this.renderer.$gutter.removeAttribute("aria-roledescription");
            this.renderer.$gutter.removeAttribute("aria-label");
            this.renderer.$gutter.classList.remove(this.renderer.keyboardFocusClassName);
            if (gutterKeyboardHandler)
              gutterKeyboardHandler.removeListener();
          }
        },
        initialValue: false
      },
      textInputAriaLabel: {
        set: function(val) {
          this.$textInputAriaLabel = val;
        },
        initialValue: ""
      },
      enableMobileMenu: {
        set: function(val) {
          this.$enableMobileMenu = val;
        },
        initialValue: true
      },
      customScrollbar: "renderer",
      hScrollBarAlwaysVisible: "renderer",
      vScrollBarAlwaysVisible: "renderer",
      highlightGutterLine: "renderer",
      animatedScroll: "renderer",
      showInvisibles: "renderer",
      showPrintMargin: "renderer",
      printMarginColumn: "renderer",
      printMargin: "renderer",
      fadeFoldWidgets: "renderer",
      showFoldWidgets: "renderer",
      displayIndentGuides: "renderer",
      highlightIndentGuides: "renderer",
      showGutter: "renderer",
      fontSize: "renderer",
      fontFamily: "renderer",
      maxLines: "renderer",
      minLines: "renderer",
      scrollPastEnd: "renderer",
      fixedWidthGutter: "renderer",
      theme: "renderer",
      hasCssTransforms: "renderer",
      maxPixelHeight: "renderer",
      useTextareaForIME: "renderer",
      useResizeObserver: "renderer",
      useSvgGutterIcons: "renderer",
      showFoldedAnnotations: "renderer",
      scrollSpeed: "$mouseHandler",
      dragDelay: "$mouseHandler",
      dragEnabled: "$mouseHandler",
      focusTimeout: "$mouseHandler",
      tooltipFollowsMouse: "$mouseHandler",
      firstLineNumber: "session",
      overwrite: "session",
      newLineMode: "session",
      useWorker: "session",
      useSoftTabs: "session",
      navigateWithinSoftTabs: "session",
      tabSize: "session",
      wrap: "session",
      indentedSoftWrap: "session",
      foldStyle: "session",
      mode: "session"
    });
    var relativeNumberRenderer = {
      getText: function(session, row) {
        return (Math.abs(session.selection.lead.row - row) || row + 1 + (row < 9 ? "·" : "")) + "";
      },
      getWidth: function(session, lastLineNumber, config2) {
        return Math.max(lastLineNumber.toString().length, (config2.lastRow + 1).toString().length, 2) * config2.characterWidth;
      },
      update: function(e, editor2) {
        editor2.renderer.$loop.schedule(editor2.renderer.CHANGE_GUTTER);
      },
      attach: function(editor2) {
        editor2.renderer.$gutterLayer.$renderer = this;
        editor2.on("changeSelection", this.update);
        this.update(null, editor2);
      },
      detach: function(editor2) {
        if (editor2.renderer.$gutterLayer.$renderer == this)
          editor2.renderer.$gutterLayer.$renderer = null;
        editor2.off("changeSelection", this.update);
        this.update(null, editor2);
      }
    };
    exports2.Editor = Editor2;
  });
  ace.define("ace/layer/lines", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
    var dom = require2("../lib/dom");
    var Lines = (
      /** @class */
      function() {
        function Lines2(element, canvasHeight) {
          this.element = element;
          this.canvasHeight = canvasHeight || 5e5;
          this.element.style.height = this.canvasHeight * 2 + "px";
          this.cells = [];
          this.cellCache = [];
          this.$offsetCoefficient = 0;
        }
        Lines2.prototype.moveContainer = function(config) {
          dom.translate(this.element, 0, -(config.firstRowScreen * config.lineHeight % this.canvasHeight) - config.offset * this.$offsetCoefficient);
        };
        Lines2.prototype.pageChanged = function(oldConfig, newConfig) {
          return Math.floor(oldConfig.firstRowScreen * oldConfig.lineHeight / this.canvasHeight) !== Math.floor(newConfig.firstRowScreen * newConfig.lineHeight / this.canvasHeight);
        };
        Lines2.prototype.computeLineTop = function(row, config, session) {
          var screenTop = config.firstRowScreen * config.lineHeight;
          var screenPage = Math.floor(screenTop / this.canvasHeight);
          var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;
          return lineTop - screenPage * this.canvasHeight;
        };
        Lines2.prototype.computeLineHeight = function(row, config, session) {
          return config.lineHeight * session.getRowLineCount(row);
        };
        Lines2.prototype.getLength = function() {
          return this.cells.length;
        };
        Lines2.prototype.get = function(index2) {
          return this.cells[index2];
        };
        Lines2.prototype.shift = function() {
          this.$cacheCell(this.cells.shift());
        };
        Lines2.prototype.pop = function() {
          this.$cacheCell(this.cells.pop());
        };
        Lines2.prototype.push = function(cell) {
          if (Array.isArray(cell)) {
            this.cells.push.apply(this.cells, cell);
            var fragment = dom.createFragment(this.element);
            for (var i = 0; i < cell.length; i++) {
              fragment.appendChild(cell[i].element);
            }
            this.element.appendChild(fragment);
          } else {
            this.cells.push(cell);
            this.element.appendChild(cell.element);
          }
        };
        Lines2.prototype.unshift = function(cell) {
          if (Array.isArray(cell)) {
            this.cells.unshift.apply(this.cells, cell);
            var fragment = dom.createFragment(this.element);
            for (var i = 0; i < cell.length; i++) {
              fragment.appendChild(cell[i].element);
            }
            if (this.element.firstChild)
              this.element.insertBefore(fragment, this.element.firstChild);
            else
              this.element.appendChild(fragment);
          } else {
            this.cells.unshift(cell);
            this.element.insertAdjacentElement("afterbegin", cell.element);
          }
        };
        Lines2.prototype.last = function() {
          if (this.cells.length)
            return this.cells[this.cells.length - 1];
          else
            return null;
        };
        Lines2.prototype.$cacheCell = function(cell) {
          if (!cell)
            return;
          cell.element.remove();
          this.cellCache.push(cell);
        };
        Lines2.prototype.createCell = function(row, config, session, initElement) {
          var cell = this.cellCache.pop();
          if (!cell) {
            var element = dom.createElement("div");
            if (initElement)
              initElement(element);
            this.element.appendChild(element);
            cell = {
              element,
              text: "",
              row
            };
          }
          cell.row = row;
          return cell;
        };
        return Lines2;
      }()
    );
    exports2.Lines = Lines;
  });
  ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/layer/lines", "ace/config"], function(require2, exports2, module2) {
    var dom = require2("../lib/dom");
    var oop = require2("../lib/oop");
    var lang = require2("../lib/lang");
    var EventEmitter = require2("../lib/event_emitter").EventEmitter;
    var Lines = require2("./lines").Lines;
    var nls = require2("../config").nls;
    var Gutter = (
      /** @class */
      function() {
        function Gutter2(parentEl) {
          this.element = dom.createElement("div");
          this.element.className = "ace_layer ace_gutter-layer";
          parentEl.appendChild(this.element);
          this.setShowFoldWidgets(this.$showFoldWidgets);
          this.gutterWidth = 0;
          this.$annotations = [];
          this.$updateAnnotations = this.$updateAnnotations.bind(this);
          this.$lines = new Lines(this.element);
          this.$lines.$offsetCoefficient = 1;
        }
        Gutter2.prototype.setSession = function(session) {
          if (this.session)
            this.session.off("change", this.$updateAnnotations);
          this.session = session;
          if (session)
            session.on("change", this.$updateAnnotations);
        };
        Gutter2.prototype.addGutterDecoration = function(row, className) {
          if (window.console)
            console.warn && console.warn("deprecated use session.addGutterDecoration");
          this.session.addGutterDecoration(row, className);
        };
        Gutter2.prototype.removeGutterDecoration = function(row, className) {
          if (window.console)
            console.warn && console.warn("deprecated use session.removeGutterDecoration");
          this.session.removeGutterDecoration(row, className);
        };
        Gutter2.prototype.setAnnotations = function(annotations) {
          this.$annotations = [];
          for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            var row = annotation.row;
            var rowInfo = this.$annotations[row];
            if (!rowInfo)
              rowInfo = this.$annotations[row] = { text: [], type: [], displayText: [] };
            var annoText = annotation.text;
            var displayAnnoText = annotation.text;
            var annoType = annotation.type;
            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
            displayAnnoText = displayAnnoText ? displayAnnoText : annotation.html || "";
            if (rowInfo.text.indexOf(annoText) === -1) {
              rowInfo.text.push(annoText);
              rowInfo.type.push(annoType);
              rowInfo.displayText.push(displayAnnoText);
            }
            var className = annotation.className;
            if (className) {
              rowInfo.className = className;
            } else if (annoType === "error") {
              rowInfo.className = " ace_error";
            } else if (annoType === "security" && !/\bace_error\b/.test(rowInfo.className)) {
              rowInfo.className = " ace_security";
            } else if (annoType === "warning" && !/\bace_(error|security)\b/.test(rowInfo.className)) {
              rowInfo.className = " ace_warning";
            } else if (annoType === "info" && !rowInfo.className) {
              rowInfo.className = " ace_info";
            } else if (annoType === "hint" && !rowInfo.className) {
              rowInfo.className = " ace_hint";
            }
          }
        };
        Gutter2.prototype.$updateAnnotations = function(delta) {
          if (!this.$annotations.length)
            return;
          var firstRow = delta.start.row;
          var len = delta.end.row - firstRow;
          if (len === 0) ;
          else if (delta.action == "remove") {
            this.$annotations.splice(firstRow, len + 1, null);
          } else {
            var args = new Array(len + 1);
            args.unshift(firstRow, 1);
            this.$annotations.splice.apply(this.$annotations, args);
          }
        };
        Gutter2.prototype.update = function(config) {
          this.config = config;
          var session = this.session;
          var firstRow = config.firstRow;
          var lastRow = Math.min(
            config.lastRow + config.gutterOffset,
            // needed to compensate for hor scollbar
            session.getLength() - 1
          );
          this.oldLastRow = lastRow;
          this.config = config;
          this.$lines.moveContainer(config);
          this.$updateCursorRow();
          var fold = session.getNextFoldLine(firstRow);
          var foldStart = fold ? fold.start.row : Infinity;
          var cell = null;
          var index2 = -1;
          var row = firstRow;
          while (true) {
            if (row > foldStart) {
              row = fold.end.row + 1;
              fold = session.getNextFoldLine(row, fold);
              foldStart = fold ? fold.start.row : Infinity;
            }
            if (row > lastRow) {
              while (this.$lines.getLength() > index2 + 1)
                this.$lines.pop();
              break;
            }
            cell = this.$lines.get(++index2);
            if (cell) {
              cell.row = row;
            } else {
              cell = this.$lines.createCell(row, config, this.session, onCreateCell);
              this.$lines.push(cell);
            }
            this.$renderCell(cell, config, fold, row);
            row++;
          }
          this._signal("afterRender");
          this.$updateGutterWidth(config);
        };
        Gutter2.prototype.$updateGutterWidth = function(config) {
          var session = this.session;
          var gutterRenderer = session.gutterRenderer || this.$renderer;
          var firstLineNumber = session.$firstLineNumber;
          var lastLineText = this.$lines.last() ? this.$lines.last().text : "";
          if (this.$fixedWidth || session.$useWrapMode)
            lastLineText = session.getLength() + firstLineNumber - 1;
          var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineText, config) : lastLineText.toString().length * config.characterWidth;
          var padding = this.$padding || this.$computePadding();
          gutterWidth += padding.left + padding.right;
          if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
            this.gutterWidth = gutterWidth;
            this.element.parentNode.style.width = this.element.style.width = Math.ceil(this.gutterWidth) + "px";
            this._signal("changeGutterWidth", gutterWidth);
          }
        };
        Gutter2.prototype.$updateCursorRow = function() {
          if (!this.$highlightGutterLine)
            return;
          var position = this.session.selection.getCursor();
          if (this.$cursorRow === position.row)
            return;
          this.$cursorRow = position.row;
        };
        Gutter2.prototype.updateLineHighlight = function() {
          if (!this.$highlightGutterLine)
            return;
          var row = this.session.selection.cursor.row;
          this.$cursorRow = row;
          if (this.$cursorCell && this.$cursorCell.row == row)
            return;
          if (this.$cursorCell)
            this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
          var cells = this.$lines.cells;
          this.$cursorCell = null;
          for (var i = 0; i < cells.length; i++) {
            var cell = cells[i];
            if (cell.row >= this.$cursorRow) {
              if (cell.row > this.$cursorRow) {
                var fold = this.session.getFoldLine(this.$cursorRow);
                if (i > 0 && fold && fold.start.row == cells[i - 1].row)
                  cell = cells[i - 1];
                else
                  break;
              }
              cell.element.className = "ace_gutter-active-line " + cell.element.className;
              this.$cursorCell = cell;
              break;
            }
          }
        };
        Gutter2.prototype.scrollLines = function(config) {
          var oldConfig = this.config;
          this.config = config;
          this.$updateCursorRow();
          if (this.$lines.pageChanged(oldConfig, config))
            return this.update(config);
          this.$lines.moveContainer(config);
          var lastRow = Math.min(
            config.lastRow + config.gutterOffset,
            // needed to compensate for hor scollbar
            this.session.getLength() - 1
          );
          var oldLastRow = this.oldLastRow;
          this.oldLastRow = lastRow;
          if (!oldConfig || oldLastRow < config.firstRow)
            return this.update(config);
          if (lastRow < oldConfig.firstRow)
            return this.update(config);
          if (oldConfig.firstRow < config.firstRow)
            for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
              this.$lines.shift();
          if (oldLastRow > lastRow)
            for (var row = this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row > 0; row--)
              this.$lines.pop();
          if (config.firstRow < oldConfig.firstRow) {
            this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));
          }
          if (lastRow > oldLastRow) {
            this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));
          }
          this.updateLineHighlight();
          this._signal("afterRender");
          this.$updateGutterWidth(config);
        };
        Gutter2.prototype.$renderLines = function(config, firstRow, lastRow) {
          var fragment = [];
          var row = firstRow;
          var foldLine = this.session.getNextFoldLine(row);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (true) {
            if (row > foldStart) {
              row = foldLine.end.row + 1;
              foldLine = this.session.getNextFoldLine(row, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
              break;
            var cell = this.$lines.createCell(row, config, this.session, onCreateCell);
            this.$renderCell(cell, config, foldLine, row);
            fragment.push(cell);
            row++;
          }
          return fragment;
        };
        Gutter2.prototype.$renderCell = function(cell, config, fold, row) {
          var element = cell.element;
          var session = this.session;
          var textNode = element.childNodes[0];
          var foldWidget = element.childNodes[1];
          var annotationNode = element.childNodes[2];
          var customWidget = element.childNodes[3];
          var annotationIconNode = annotationNode.firstChild;
          var firstLineNumber = session.$firstLineNumber;
          var breakpoints = session.$breakpoints;
          var decorations = session.$decorations;
          var gutterRenderer = session.gutterRenderer || this.$renderer;
          var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
          var foldStart = fold ? fold.start.row : Number.MAX_VALUE;
          var lineHeight = config.lineHeight + "px";
          var className = this.$useSvgGutterIcons ? "ace_gutter-cell_svg-icons " : "ace_gutter-cell ";
          var iconClassName = this.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
          var rowText = (gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber).toString();
          if (this.$highlightGutterLine) {
            if (row == this.$cursorRow || fold && row < this.$cursorRow && row >= foldStart && this.$cursorRow <= fold.end.row) {
              className += "ace_gutter-active-line ";
              if (this.$cursorCell != cell) {
                if (this.$cursorCell)
                  this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
                this.$cursorCell = cell;
              }
            }
          }
          if (breakpoints[row])
            className += breakpoints[row];
          if (decorations[row])
            className += decorations[row];
          if (this.$annotations[row] && row !== foldStart)
            className += this.$annotations[row].className;
          if (foldWidgets) {
            var c = foldWidgets[row];
            if (c == null)
              c = foldWidgets[row] = session.getFoldWidget(row);
          }
          if (c) {
            var foldClass = "ace_fold-widget ace_" + c;
            var isClosedFold = c == "start" && row == foldStart && row < fold.end.row;
            if (isClosedFold) {
              foldClass += " ace_closed";
              var foldAnnotationClass = "";
              var annotationInFold = false;
              for (var i = row + 1; i <= fold.end.row; i++) {
                if (!this.$annotations[i])
                  continue;
                if (this.$annotations[i].className === " ace_error") {
                  annotationInFold = true;
                  foldAnnotationClass = " ace_error_fold";
                  break;
                }
                if (this.$annotations[i].className === " ace_security") {
                  annotationInFold = true;
                  foldAnnotationClass = " ace_security_fold";
                } else if (this.$annotations[i].className === " ace_warning" && foldAnnotationClass !== " ace_security_fold") {
                  annotationInFold = true;
                  foldAnnotationClass = " ace_warning_fold";
                }
              }
              className += foldAnnotationClass;
            } else
              foldClass += " ace_open";
            if (foldWidget.className != foldClass)
              foldWidget.className = foldClass;
            dom.setStyle(foldWidget.style, "height", lineHeight);
            dom.setStyle(foldWidget.style, "display", "inline-block");
            foldWidget.setAttribute("role", "button");
            foldWidget.setAttribute("tabindex", "-1");
            var foldRange = session.getFoldWidgetRange(row);
            if (foldRange)
              foldWidget.setAttribute("aria-label", nls("gutter.code-folding.range.aria-label", "Toggle code folding, rows $0 through $1", [
                foldRange.start.row + 1,
                foldRange.end.row + 1
              ]));
            else {
              if (fold)
                foldWidget.setAttribute("aria-label", nls("gutter.code-folding.closed.aria-label", "Toggle code folding, rows $0 through $1", [
                  fold.start.row + 1,
                  fold.end.row + 1
                ]));
              else
                foldWidget.setAttribute("aria-label", nls("gutter.code-folding.open.aria-label", "Toggle code folding, row $0", [row + 1]));
            }
            if (isClosedFold) {
              foldWidget.setAttribute("aria-expanded", "false");
              foldWidget.setAttribute("title", nls("gutter.code-folding.closed.title", "Unfold code"));
            } else {
              foldWidget.setAttribute("aria-expanded", "true");
              foldWidget.setAttribute("title", nls("gutter.code-folding.open.title", "Fold code"));
            }
          } else {
            if (foldWidget) {
              dom.setStyle(foldWidget.style, "display", "none");
              foldWidget.setAttribute("tabindex", "0");
              foldWidget.removeAttribute("role");
              foldWidget.removeAttribute("aria-label");
            }
          }
          var customWidgetAttributes = this.session.$gutterCustomWidgets[row];
          if (customWidgetAttributes) {
            this.$addCustomWidget(row, customWidgetAttributes, cell);
          } else if (customWidget) {
            this.$removeCustomWidget(row, cell);
          }
          if (annotationInFold && this.$showFoldedAnnotations) {
            annotationNode.className = "ace_gutter_annotation";
            annotationIconNode.className = iconClassName;
            annotationIconNode.className += foldAnnotationClass;
            dom.setStyle(annotationIconNode.style, "height", lineHeight);
            dom.setStyle(annotationNode.style, "display", "block");
            dom.setStyle(annotationNode.style, "height", lineHeight);
            var ariaLabel;
            switch (foldAnnotationClass) {
              case " ace_error_fold":
                ariaLabel = nls("gutter.annotation.aria-label.error", "Error, read annotations row $0", [rowText]);
                break;
              case " ace_security_fold":
                ariaLabel = nls("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [rowText]);
                break;
              case " ace_warning_fold":
                ariaLabel = nls("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [rowText]);
                break;
            }
            annotationNode.setAttribute("aria-label", ariaLabel);
            annotationNode.setAttribute("tabindex", "-1");
            annotationNode.setAttribute("role", "button");
          } else if (this.$annotations[row]) {
            annotationNode.className = "ace_gutter_annotation";
            annotationIconNode.className = iconClassName;
            if (this.$useSvgGutterIcons)
              annotationIconNode.className += this.$annotations[row].className;
            else
              element.classList.add(this.$annotations[row].className.replace(" ", ""));
            dom.setStyle(annotationIconNode.style, "height", lineHeight);
            dom.setStyle(annotationNode.style, "display", "block");
            dom.setStyle(annotationNode.style, "height", lineHeight);
            var ariaLabel;
            switch (this.$annotations[row].className) {
              case " ace_error":
                ariaLabel = nls("gutter.annotation.aria-label.error", "Error, read annotations row $0", [rowText]);
                break;
              case " ace_security":
                ariaLabel = nls("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [rowText]);
                break;
              case " ace_warning":
                ariaLabel = nls("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [rowText]);
                break;
              case " ace_info":
                ariaLabel = nls("gutter.annotation.aria-label.info", "Info, read annotations row $0", [rowText]);
                break;
              case " ace_hint":
                ariaLabel = nls("gutter.annotation.aria-label.hint", "Suggestion, read annotations row $0", [rowText]);
                break;
            }
            annotationNode.setAttribute("aria-label", ariaLabel);
            annotationNode.setAttribute("tabindex", "-1");
            annotationNode.setAttribute("role", "button");
          } else {
            dom.setStyle(annotationNode.style, "display", "none");
            annotationNode.removeAttribute("aria-label");
            annotationNode.removeAttribute("role");
            annotationNode.setAttribute("tabindex", "0");
          }
          if (rowText !== textNode.data) {
            textNode.data = rowText;
          }
          if (element.className != className)
            element.className = className;
          dom.setStyle(cell.element.style, "height", this.$lines.computeLineHeight(row, config, session) + "px");
          dom.setStyle(cell.element.style, "top", this.$lines.computeLineTop(row, config, session) + "px");
          cell.text = rowText;
          if (annotationNode.style.display === "none" && foldWidget.style.display === "none" && !customWidgetAttributes)
            cell.element.setAttribute("aria-hidden", true);
          else
            cell.element.setAttribute("aria-hidden", false);
          return cell;
        };
        Gutter2.prototype.setHighlightGutterLine = function(highlightGutterLine) {
          this.$highlightGutterLine = highlightGutterLine;
        };
        Gutter2.prototype.setShowLineNumbers = function(show) {
          this.$renderer = !show && {
            getWidth: function() {
              return 0;
            },
            getText: function() {
              return "";
            }
          };
        };
        Gutter2.prototype.getShowLineNumbers = function() {
          return this.$showLineNumbers;
        };
        Gutter2.prototype.setShowFoldWidgets = function(show) {
          if (show)
            dom.addCssClass(this.element, "ace_folding-enabled");
          else
            dom.removeCssClass(this.element, "ace_folding-enabled");
          this.$showFoldWidgets = show;
          this.$padding = null;
        };
        Gutter2.prototype.getShowFoldWidgets = function() {
          return this.$showFoldWidgets;
        };
        Gutter2.prototype.$hideFoldWidget = function(row, cell) {
          var rowCell = cell || this.$getGutterCell(row);
          if (rowCell && rowCell.element) {
            var foldWidget = rowCell.element.childNodes[1];
            if (foldWidget) {
              dom.setStyle(foldWidget.style, "display", "none");
            }
          }
        };
        Gutter2.prototype.$showFoldWidget = function(row, cell) {
          var rowCell = cell || this.$getGutterCell(row);
          if (rowCell && rowCell.element) {
            var foldWidget = rowCell.element.childNodes[1];
            if (foldWidget && this.session.foldWidgets && this.session.foldWidgets[rowCell.row]) {
              dom.setStyle(foldWidget.style, "display", "inline-block");
            }
          }
        };
        Gutter2.prototype.$getGutterCell = function(row) {
          var cells = this.$lines.cells;
          var visibileRow = this.session.documentToScreenRow(row, 0);
          return cells[row - this.config.firstRowScreen - (row - visibileRow)];
        };
        Gutter2.prototype.$addCustomWidget = function(row, _a, cell) {
          var className = _a.className, label = _a.label, title = _a.title, callbacks = _a.callbacks;
          this.session.$gutterCustomWidgets[row] = { className, label, title, callbacks };
          this.$hideFoldWidget(row, cell);
          var rowCell = cell || this.$getGutterCell(row);
          if (rowCell && rowCell.element) {
            var customWidget = rowCell.element.querySelector(".ace_custom-widget");
            if (customWidget) {
              customWidget.remove();
            }
            customWidget = dom.createElement("span");
            customWidget.className = "ace_custom-widget ".concat(className);
            customWidget.setAttribute("tabindex", "-1");
            customWidget.setAttribute("role", "button");
            customWidget.setAttribute("aria-label", label);
            customWidget.setAttribute("title", title);
            dom.setStyle(customWidget.style, "display", "inline-block");
            dom.setStyle(customWidget.style, "height", "inherit");
            if (callbacks && callbacks.onClick) {
              customWidget.addEventListener("click", function(e) {
                callbacks.onClick(e, row);
                e.stopPropagation();
              });
            }
            rowCell.element.appendChild(customWidget);
          }
        };
        Gutter2.prototype.$removeCustomWidget = function(row, cell) {
          delete this.session.$gutterCustomWidgets[row];
          this.$showFoldWidget(row, cell);
          var rowCell = cell || this.$getGutterCell(row);
          if (rowCell && rowCell.element) {
            var customWidget = rowCell.element.querySelector(".ace_custom-widget");
            if (customWidget) {
              rowCell.element.removeChild(customWidget);
            }
          }
        };
        Gutter2.prototype.$computePadding = function() {
          if (!this.element.firstChild)
            return { left: 0, right: 0 };
          var style2 = dom.computedStyle(
            /**@type{Element}*/
            this.element.firstChild
          );
          this.$padding = {};
          this.$padding.left = (parseInt(style2.borderLeftWidth) || 0) + (parseInt(style2.paddingLeft) || 0) + 1;
          this.$padding.right = (parseInt(style2.borderRightWidth) || 0) + (parseInt(style2.paddingRight) || 0);
          return this.$padding;
        };
        Gutter2.prototype.getRegion = function(point) {
          var padding = this.$padding || this.$computePadding();
          var rect = this.element.getBoundingClientRect();
          if (point.x < padding.left + rect.left)
            return "markers";
          if (this.$showFoldWidgets && point.x > rect.right - padding.right)
            return "foldWidgets";
        };
        return Gutter2;
      }()
    );
    Gutter.prototype.$fixedWidth = false;
    Gutter.prototype.$highlightGutterLine = true;
    Gutter.prototype.$renderer = "";
    Gutter.prototype.$showLineNumbers = true;
    Gutter.prototype.$showFoldWidgets = true;
    oop.implement(Gutter.prototype, EventEmitter);
    function onCreateCell(element) {
      var textNode = document.createTextNode("");
      element.appendChild(textNode);
      var foldWidget = dom.createElement("span");
      element.appendChild(foldWidget);
      var annotationNode = dom.createElement("span");
      element.appendChild(annotationNode);
      var annotationIconNode = dom.createElement("span");
      annotationNode.appendChild(annotationIconNode);
      return element;
    }
    exports2.Gutter = Gutter;
  });
  ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function(require2, exports2, module2) {
    var Range = require2("../range").Range;
    var dom = require2("../lib/dom");
    var Marker = (
      /** @class */
      function() {
        function Marker2(parentEl) {
          this.element = dom.createElement("div");
          this.element.className = "ace_layer ace_marker-layer";
          parentEl.appendChild(this.element);
        }
        Marker2.prototype.setPadding = function(padding) {
          this.$padding = padding;
        };
        Marker2.prototype.setSession = function(session) {
          this.session = session;
        };
        Marker2.prototype.setMarkers = function(markers) {
          this.markers = markers;
        };
        Marker2.prototype.elt = function(className, css) {
          var x = this.i != -1 && this.element.childNodes[this.i];
          if (!x) {
            x = document.createElement("div");
            this.element.appendChild(x);
            this.i = -1;
          } else {
            this.i++;
          }
          x.style.cssText = css;
          x.className = className;
        };
        Marker2.prototype.update = function(config) {
          if (!config)
            return;
          this.config = config;
          this.i = 0;
          var html;
          for (var key in this.markers) {
            var marker = this.markers[key];
            if (!marker.range) {
              marker.update(html, this, this.session, config);
              continue;
            }
            var range = marker.range.clipRows(config.firstRow, config.lastRow);
            if (range.isEmpty())
              continue;
            range = range.toScreenRange(this.session);
            if (marker.renderer) {
              var top = this.$getTop(range.start.row, config);
              var left = this.$padding + range.start.column * config.characterWidth;
              marker.renderer(html, range, left, top, config);
            } else if (marker.type == "fullLine") {
              this.drawFullLineMarker(html, range, marker.clazz, config);
            } else if (marker.type == "screenLine") {
              this.drawScreenLineMarker(html, range, marker.clazz, config);
            } else if (range.isMultiLine()) {
              if (marker.type == "text")
                this.drawTextMarker(html, range, marker.clazz, config);
              else
                this.drawMultiLineMarker(html, range, marker.clazz, config);
            } else {
              this.drawSingleLineMarker(html, range, marker.clazz + " ace_start ace_br15", config);
            }
          }
          if (this.i != -1) {
            while (this.i < this.element.childElementCount)
              this.element.removeChild(this.element.lastChild);
          }
        };
        Marker2.prototype.$getTop = function(row, layerConfig) {
          return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
        };
        Marker2.prototype.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
          var session = this.session;
          var start = range.start.row;
          var end = range.end.row;
          var row = start;
          var prev = 0;
          var curr = 0;
          var next = session.getScreenLastRowColumn(row);
          var lineRange = new Range(row, range.start.column, row, curr);
          for (; row <= end; row++) {
            lineRange.start.row = lineRange.end.row = row;
            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
            lineRange.end.column = next;
            prev = curr;
            curr = next;
            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
            this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? " ace_start" : "") + " ace_br" + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);
          }
        };
        Marker2.prototype.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
          var padding = this.$padding;
          var height = config.lineHeight;
          var top = this.$getTop(range.start.row, config);
          var left = padding + range.start.column * config.characterWidth;
          extraStyle = extraStyle || "";
          if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
            var range1 = range.clone();
            range1.end.row = range1.start.row;
            range1.end.column = this.session.getLine(range1.start.row).length;
            this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
          } else {
            this.elt(clazz + " ace_br1 ace_start", "height:" + height + "px;right:" + padding + "px;top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
          }
          if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
            var range1 = range.clone();
            range1.start.row = range1.end.row;
            range1.start.column = 0;
            this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
          } else {
            top = this.$getTop(range.end.row, config);
            var width = range.end.column * config.characterWidth;
            this.elt(clazz + " ace_br12", "height:" + height + "px;width:" + width + "px;top:" + top + "px;left:" + padding + "px;" + (extraStyle || ""));
          }
          height = (range.end.row - range.start.row - 1) * config.lineHeight;
          if (height <= 0)
            return;
          top = this.$getTop(range.start.row + 1, config);
          var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
          this.elt(clazz + (radiusClass ? " ace_br" + radiusClass : ""), "height:" + height + "px;right:" + padding + "px;top:" + top + "px;left:" + padding + "px;" + (extraStyle || ""));
        };
        Marker2.prototype.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
          if (this.session.$bidiHandler.isBidiRow(range.start.row))
            return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);
          var height = config.lineHeight;
          var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
          var top = this.$getTop(range.start.row, config);
          var left = this.$padding + range.start.column * config.characterWidth;
          this.elt(clazz, "height:" + height + "px;width:" + width + "px;top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
        };
        Marker2.prototype.drawBidiSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
          var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
          var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);
          selections.forEach(function(selection) {
            this.elt(clazz, "height:" + height + "px;width:" + (selection.width + (extraLength || 0)) + "px;top:" + top + "px;left:" + (padding + selection.left) + "px;" + (extraStyle || ""));
          }, this);
        };
        Marker2.prototype.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
          var top = this.$getTop(range.start.row, config);
          var height = config.lineHeight;
          if (range.start.row != range.end.row)
            height += this.$getTop(range.end.row, config) - top;
          this.elt(clazz, "height:" + height + "px;top:" + top + "px;left:0;right:0;" + (extraStyle || ""));
        };
        Marker2.prototype.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
          var top = this.$getTop(range.start.row, config);
          var height = config.lineHeight;
          this.elt(clazz, "height:" + height + "px;top:" + top + "px;left:0;right:0;" + (extraStyle || ""));
        };
        return Marker2;
      }()
    );
    Marker.prototype.$padding = 0;
    function getBorderClass(tl, tr, br, bl) {
      return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
    }
    exports2.Marker = Marker;
  });
  ace.define("ace/layer/text_util", ["require", "exports", "module"], function(require2, exports2, module2) {
    var textTokens = /* @__PURE__ */ new Set(["text", "rparen", "lparen"]);
    exports2.isTextToken = function(tokenType) {
      return textTokens.has(tokenType);
    };
  });
  ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/layer/lines", "ace/lib/event_emitter", "ace/config", "ace/layer/text_util"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var dom = require2("../lib/dom");
    var lang = require2("../lib/lang");
    var Lines = require2("./lines").Lines;
    var EventEmitter = require2("../lib/event_emitter").EventEmitter;
    var nls = require2("../config").nls;
    var isTextToken = require2("./text_util").isTextToken;
    var Text = (
      /** @class */
      function() {
        function Text2(parentEl) {
          this.dom = dom;
          this.element = this.dom.createElement("div");
          this.element.className = "ace_layer ace_text-layer";
          parentEl.appendChild(this.element);
          this.$updateEolChar = this.$updateEolChar.bind(this);
          this.$lines = new Lines(this.element);
        }
        Text2.prototype.$updateEolChar = function() {
          var doc = this.session.doc;
          var unixMode = doc.getNewLineCharacter() == "\n" && doc.getNewLineMode() != "windows";
          var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
          if (this.EOL_CHAR != EOL_CHAR) {
            this.EOL_CHAR = EOL_CHAR;
            return true;
          }
        };
        Text2.prototype.setPadding = function(padding) {
          this.$padding = padding;
          this.element.style.margin = "0 " + padding + "px";
        };
        Text2.prototype.getLineHeight = function() {
          return this.$fontMetrics.$characterSize.height || 0;
        };
        Text2.prototype.getCharacterWidth = function() {
          return this.$fontMetrics.$characterSize.width || 0;
        };
        Text2.prototype.$setFontMetrics = function(measure) {
          this.$fontMetrics = measure;
          this.$fontMetrics.on(
            "changeCharacterSize",
            (function(e) {
              this._signal("changeCharacterSize", e);
            }).bind(this)
          );
          this.$pollSizeChanges();
        };
        Text2.prototype.checkForSizeChanges = function() {
          this.$fontMetrics.checkForSizeChanges();
        };
        Text2.prototype.$pollSizeChanges = function() {
          return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
        };
        Text2.prototype.setSession = function(session) {
          this.session = session;
          if (session)
            this.$computeTabString();
        };
        Text2.prototype.setShowInvisibles = function(showInvisibles) {
          if (this.showInvisibles == showInvisibles)
            return false;
          this.showInvisibles = showInvisibles;
          if (typeof showInvisibles == "string") {
            this.showSpaces = /tab/i.test(showInvisibles);
            this.showTabs = /space/i.test(showInvisibles);
            this.showEOL = /eol/i.test(showInvisibles);
          } else {
            this.showSpaces = this.showTabs = this.showEOL = showInvisibles;
          }
          this.$computeTabString();
          return true;
        };
        Text2.prototype.setDisplayIndentGuides = function(display) {
          if (this.displayIndentGuides == display)
            return false;
          this.displayIndentGuides = display;
          this.$computeTabString();
          return true;
        };
        Text2.prototype.setHighlightIndentGuides = function(highlight) {
          if (this.$highlightIndentGuides === highlight)
            return false;
          this.$highlightIndentGuides = highlight;
          return highlight;
        };
        Text2.prototype.$computeTabString = function() {
          var tabSize = this.session.getTabSize();
          this.tabSize = tabSize;
          var tabStr = this.$tabStrings = [0];
          for (var i = 1; i < tabSize + 1; i++) {
            if (this.showTabs) {
              var span = this.dom.createElement("span");
              span.className = "ace_invisible ace_invisible_tab";
              span.textContent = lang.stringRepeat(this.TAB_CHAR, i);
              tabStr.push(span);
            } else {
              tabStr.push(this.dom.createTextNode(lang.stringRepeat(" ", i), this.element));
            }
          }
          if (this.displayIndentGuides) {
            this.$indentGuideRe = /\s\S| \t|\t |\s$/;
            var className = "ace_indent-guide";
            var spaceClass = this.showSpaces ? " ace_invisible ace_invisible_space" : "";
            var spaceContent = this.showSpaces ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize) : lang.stringRepeat(" ", this.tabSize);
            var tabClass = this.showTabs ? " ace_invisible ace_invisible_tab" : "";
            var tabContent = this.showTabs ? lang.stringRepeat(this.TAB_CHAR, this.tabSize) : spaceContent;
            var span = this.dom.createElement("span");
            span.className = className + spaceClass;
            span.textContent = spaceContent;
            this.$tabStrings[" "] = span;
            var span = this.dom.createElement("span");
            span.className = className + tabClass;
            span.textContent = tabContent;
            this.$tabStrings["	"] = span;
          }
        };
        Text2.prototype.updateLines = function(config, firstRow, lastRow) {
          if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
            return this.update(config);
          }
          this.config = config;
          var first = Math.max(firstRow, config.firstRow);
          var last = Math.min(lastRow, config.lastRow);
          var lineElements = this.element.childNodes;
          var lineElementsIdx = 0;
          for (var row = config.firstRow; row < first; row++) {
            var foldLine = this.session.getFoldLine(row);
            if (foldLine) {
              if (foldLine.containsRow(first)) {
                first = foldLine.start.row;
                break;
              } else {
                row = foldLine.end.row;
              }
            }
            lineElementsIdx++;
          }
          var heightChanged = false;
          var row = first;
          var foldLine = this.session.getNextFoldLine(row);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (true) {
            if (row > foldStart) {
              row = foldLine.end.row + 1;
              foldLine = this.session.getNextFoldLine(row, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > last)
              break;
            var lineElement = lineElements[lineElementsIdx++];
            if (lineElement) {
              this.dom.removeChildren(lineElement);
              this.$renderLine(lineElement, row, row == foldStart ? foldLine : false);
              if (heightChanged)
                lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + "px";
              var height = config.lineHeight * this.session.getRowLength(row) + "px";
              if (lineElement.style.height != height) {
                heightChanged = true;
                lineElement.style.height = height;
              }
            }
            row++;
          }
          if (heightChanged) {
            while (lineElementsIdx < this.$lines.cells.length) {
              var cell = this.$lines.cells[lineElementsIdx++];
              cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + "px";
            }
          }
        };
        Text2.prototype.scrollLines = function(config) {
          var oldConfig = this.config;
          this.config = config;
          if (this.$lines.pageChanged(oldConfig, config))
            return this.update(config);
          this.$lines.moveContainer(config);
          var lastRow = config.lastRow;
          var oldLastRow = oldConfig ? oldConfig.lastRow : -1;
          if (!oldConfig || oldLastRow < config.firstRow)
            return this.update(config);
          if (lastRow < oldConfig.firstRow)
            return this.update(config);
          if (!oldConfig || oldConfig.lastRow < config.firstRow)
            return this.update(config);
          if (config.lastRow < oldConfig.firstRow)
            return this.update(config);
          if (oldConfig.firstRow < config.firstRow)
            for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
              this.$lines.shift();
          if (oldConfig.lastRow > config.lastRow)
            for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)
              this.$lines.pop();
          if (config.firstRow < oldConfig.firstRow) {
            this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));
          }
          if (config.lastRow > oldConfig.lastRow) {
            this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));
          }
          this.$highlightIndentGuide();
        };
        Text2.prototype.$renderLinesFragment = function(config, firstRow, lastRow) {
          var fragment = [];
          var row = firstRow;
          var foldLine = this.session.getNextFoldLine(row);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (true) {
            if (row > foldStart) {
              row = foldLine.end.row + 1;
              foldLine = this.session.getNextFoldLine(row, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
              break;
            var line = this.$lines.createCell(row, config, this.session);
            var lineEl = line.element;
            this.dom.removeChildren(lineEl);
            dom.setStyle(lineEl.style, "height", this.$lines.computeLineHeight(row, config, this.session) + "px");
            dom.setStyle(lineEl.style, "top", this.$lines.computeLineTop(row, config, this.session) + "px");
            this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);
            if (this.$useLineGroups()) {
              lineEl.className = "ace_line_group";
            } else {
              lineEl.className = "ace_line";
            }
            fragment.push(line);
            row++;
          }
          return fragment;
        };
        Text2.prototype.update = function(config) {
          this.$lines.moveContainer(config);
          this.config = config;
          var firstRow = config.firstRow;
          var lastRow = config.lastRow;
          var lines = this.$lines;
          while (lines.getLength())
            lines.pop();
          lines.push(this.$renderLinesFragment(config, firstRow, lastRow));
        };
        Text2.prototype.$renderToken = function(parent, screenColumn, token, value) {
          var self2 = this;
          var re = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069\u2060\u2061\u2062\u2063\u2064\u206A\u206B\u206B\u206C\u206D\u206E\u206F]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;
          var valueFragment = this.dom.createFragment(this.element);
          var m;
          var i = 0;
          while (m = re.exec(value)) {
            var tab2 = m[1];
            var simpleSpace = m[2];
            var controlCharacter = m[3];
            var cjkSpace = m[4];
            var cjk = m[5];
            if (!self2.showSpaces && simpleSpace)
              continue;
            var before = i != m.index ? value.slice(i, m.index) : "";
            i = m.index + m[0].length;
            if (before) {
              valueFragment.appendChild(this.dom.createTextNode(before, this.element));
            }
            if (tab2) {
              var tabSize = self2.session.getScreenTabSize(screenColumn + m.index);
              var text = self2.$tabStrings[tabSize].cloneNode(true);
              text["charCount"] = 1;
              valueFragment.appendChild(text);
              screenColumn += tabSize - 1;
            } else if (simpleSpace) {
              if (self2.showSpaces) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_space";
                span.textContent = lang.stringRepeat(self2.SPACE_CHAR, simpleSpace.length);
                valueFragment.appendChild(span);
              } else {
                valueFragment.appendChild(this.dom.createTextNode(simpleSpace, this.element));
              }
            } else if (controlCharacter) {
              var span = this.dom.createElement("span");
              span.className = "ace_invisible ace_invisible_space ace_invalid";
              span.textContent = lang.stringRepeat(self2.SPACE_CHAR, controlCharacter.length);
              valueFragment.appendChild(span);
            } else if (cjkSpace) {
              screenColumn += 1;
              var span = this.dom.createElement("span");
              span.style.width = self2.config.characterWidth * 2 + "px";
              span.className = self2.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
              span.textContent = self2.showSpaces ? self2.SPACE_CHAR : cjkSpace;
              valueFragment.appendChild(span);
            } else if (cjk) {
              screenColumn += 1;
              var span = this.dom.createElement("span");
              span.style.width = self2.config.characterWidth * 2 + "px";
              span.className = "ace_cjk";
              span.textContent = cjk;
              valueFragment.appendChild(span);
            }
          }
          valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));
          if (!isTextToken(token.type)) {
            var classes2 = "ace_" + token.type.replace(/\./g, " ace_");
            var span = this.dom.createElement("span");
            if (token.type == "fold") {
              span.style.width = token.value.length * this.config.characterWidth + "px";
              span.setAttribute("title", nls("inline-fold.closed.title", "Unfold code"));
            }
            span.className = classes2;
            span.appendChild(valueFragment);
            parent.appendChild(span);
          } else {
            parent.appendChild(valueFragment);
          }
          return screenColumn + value.length;
        };
        Text2.prototype.renderIndentGuide = function(parent, value, max) {
          var cols = value.search(this.$indentGuideRe);
          if (cols <= 0 || cols >= max)
            return value;
          if (value[0] == " ") {
            cols -= cols % this.tabSize;
            var count = cols / this.tabSize;
            for (var i = 0; i < count; i++) {
              parent.appendChild(this.$tabStrings[" "].cloneNode(true));
            }
            this.$highlightIndentGuide();
            return value.substr(cols);
          } else if (value[0] == "	") {
            for (var i = 0; i < cols; i++) {
              parent.appendChild(this.$tabStrings["	"].cloneNode(true));
            }
            this.$highlightIndentGuide();
            return value.substr(cols);
          }
          this.$highlightIndentGuide();
          return value;
        };
        Text2.prototype.$highlightIndentGuide = function() {
          if (!this.$highlightIndentGuides || !this.displayIndentGuides)
            return;
          this.$highlightIndentGuideMarker = {
            indentLevel: void 0,
            start: void 0,
            end: void 0,
            dir: void 0
          };
          var lines = this.session.doc.$lines;
          if (!lines)
            return;
          var cursor = this.session.selection.getCursor();
          var initialIndent = /^\s*/.exec(this.session.doc.getLine(cursor.row))[0].length;
          var elementIndentLevel = Math.floor(initialIndent / this.tabSize);
          this.$highlightIndentGuideMarker = {
            indentLevel: elementIndentLevel,
            start: cursor.row
          };
          var bracketHighlight = this.session.$bracketHighlight;
          if (bracketHighlight) {
            var ranges = this.session.$bracketHighlight.ranges;
            for (var i = 0; i < ranges.length; i++) {
              if (cursor.row !== ranges[i].start.row) {
                this.$highlightIndentGuideMarker.end = ranges[i].start.row + 1;
                if (cursor.row > ranges[i].start.row) {
                  this.$highlightIndentGuideMarker.dir = -1;
                } else {
                  this.$highlightIndentGuideMarker.dir = 1;
                }
                break;
              }
            }
          }
          if (!this.$highlightIndentGuideMarker.end) {
            if (lines[cursor.row] !== "" && cursor.column === lines[cursor.row].length) {
              this.$highlightIndentGuideMarker.dir = 1;
              for (var i = cursor.row + 1; i < lines.length; i++) {
                var line = lines[i];
                var currentIndent = /^\s*/.exec(line)[0].length;
                if (line !== "") {
                  this.$highlightIndentGuideMarker.end = i;
                  if (currentIndent <= initialIndent)
                    break;
                }
              }
            }
          }
          this.$renderHighlightIndentGuide();
        };
        Text2.prototype.$clearActiveIndentGuide = function() {
          var activeIndentGuides = this.element.querySelectorAll(".ace_indent-guide-active");
          for (var i = 0; i < activeIndentGuides.length; i++) {
            activeIndentGuides[i].classList.remove("ace_indent-guide-active");
          }
        };
        Text2.prototype.$setIndentGuideActive = function(cell, indentLevel) {
          var line = this.session.doc.getLine(cell.row);
          if (line !== "") {
            var element = cell.element;
            if (cell.element.classList && cell.element.classList.contains("ace_line_group")) {
              if (cell.element.childNodes.length > 0) {
                element = cell.element.childNodes[0];
              } else {
                return;
              }
            }
            var childNodes = element.childNodes;
            if (childNodes) {
              var node = childNodes[indentLevel - 1];
              if (node && node.classList && node.classList.contains("ace_indent-guide"))
                node.classList.add("ace_indent-guide-active");
            }
          }
        };
        Text2.prototype.$renderHighlightIndentGuide = function() {
          if (!this.$lines)
            return;
          var cells = this.$lines.cells;
          this.$clearActiveIndentGuide();
          var indentLevel = this.$highlightIndentGuideMarker.indentLevel;
          if (indentLevel !== 0) {
            if (this.$highlightIndentGuideMarker.dir === 1) {
              for (var i = 0; i < cells.length; i++) {
                var cell = cells[i];
                if (this.$highlightIndentGuideMarker.end && cell.row >= this.$highlightIndentGuideMarker.start + 1) {
                  if (cell.row >= this.$highlightIndentGuideMarker.end)
                    break;
                  this.$setIndentGuideActive(cell, indentLevel);
                }
              }
            } else {
              for (var i = cells.length - 1; i >= 0; i--) {
                var cell = cells[i];
                if (this.$highlightIndentGuideMarker.end && cell.row < this.$highlightIndentGuideMarker.start) {
                  if (cell.row < this.$highlightIndentGuideMarker.end)
                    break;
                  this.$setIndentGuideActive(cell, indentLevel);
                }
              }
            }
          }
        };
        Text2.prototype.$createLineElement = function(parent) {
          var lineEl = this.dom.createElement("div");
          lineEl.className = "ace_line";
          lineEl.style.height = this.config.lineHeight + "px";
          return lineEl;
        };
        Text2.prototype.$renderWrappedLine = function(parent, tokens, splits) {
          var chars = 0;
          var split = 0;
          var splitChars = splits[0];
          var screenColumn = 0;
          var lineEl = this.$createLineElement();
          parent.appendChild(lineEl);
          for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
              chars = value.length;
              value = this.renderIndentGuide(lineEl, value, splitChars);
              if (!value)
                continue;
              chars -= value.length;
            }
            if (chars + value.length < splitChars) {
              screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
              chars += value.length;
            } else {
              while (chars + value.length >= splitChars) {
                screenColumn = this.$renderToken(lineEl, screenColumn, token, value.substring(0, splitChars - chars));
                value = value.substring(splitChars - chars);
                chars = splitChars;
                lineEl = this.$createLineElement();
                parent.appendChild(lineEl);
                var text = this.dom.createTextNode(lang.stringRepeat(" ", splits.indent), this.element);
                text["charCount"] = 0;
                lineEl.appendChild(text);
                split++;
                screenColumn = 0;
                splitChars = splits[split] || Number.MAX_VALUE;
              }
              if (value.length != 0) {
                chars += value.length;
                screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
              }
            }
          }
          if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)
            this.$renderOverflowMessage(lineEl, screenColumn, null, "", true);
        };
        Text2.prototype.$renderSimpleLine = function(parent, tokens) {
          var screenColumn = 0;
          for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
              value = this.renderIndentGuide(parent, value);
              if (!value)
                continue;
            }
            if (screenColumn + value.length > this.MAX_LINE_LENGTH)
              return this.$renderOverflowMessage(parent, screenColumn, token, value);
            screenColumn = this.$renderToken(parent, screenColumn, token, value);
          }
        };
        Text2.prototype.$renderOverflowMessage = function(parent, screenColumn, token, value, hide) {
          token && this.$renderToken(parent, screenColumn, token, value.slice(0, this.MAX_LINE_LENGTH - screenColumn));
          var overflowEl = this.dom.createElement("span");
          overflowEl.className = "ace_inline_button ace_keyword ace_toggle_wrap";
          overflowEl.textContent = hide ? "<hide>" : "<click to see more...>";
          parent.appendChild(overflowEl);
        };
        Text2.prototype.$renderLine = function(parent, row, foldLine) {
          if (!foldLine && foldLine != false)
            foldLine = this.session.getFoldLine(row);
          if (foldLine)
            var tokens = this.$getFoldLineTokens(row, foldLine);
          else
            var tokens = this.session.getTokens(row);
          var lastLineEl = parent;
          if (tokens.length) {
            var splits = this.session.getRowSplitData(row);
            if (splits && splits.length) {
              this.$renderWrappedLine(parent, tokens, splits);
              var lastLineEl = parent.lastChild;
            } else {
              var lastLineEl = parent;
              if (this.$useLineGroups()) {
                lastLineEl = this.$createLineElement();
                parent.appendChild(lastLineEl);
              }
              this.$renderSimpleLine(lastLineEl, tokens);
            }
          } else if (this.$useLineGroups()) {
            lastLineEl = this.$createLineElement();
            parent.appendChild(lastLineEl);
          }
          if (this.showEOL && lastLineEl) {
            if (foldLine)
              row = foldLine.end.row;
            var invisibleEl = this.dom.createElement("span");
            invisibleEl.className = "ace_invisible ace_invisible_eol";
            invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;
            lastLineEl.appendChild(invisibleEl);
          }
        };
        Text2.prototype.$getFoldLineTokens = function(row, foldLine) {
          var session = this.session;
          var renderTokens = [];
          function addTokens(tokens2, from, to) {
            var idx = 0, col = 0;
            while (col + tokens2[idx].value.length < from) {
              col += tokens2[idx].value.length;
              idx++;
              if (idx == tokens2.length)
                return;
            }
            if (col != from) {
              var value = tokens2[idx].value.substring(from - col);
              if (value.length > to - from)
                value = value.substring(0, to - from);
              renderTokens.push({
                type: tokens2[idx].type,
                value
              });
              col = from + value.length;
              idx += 1;
            }
            while (col < to && idx < tokens2.length) {
              var value = tokens2[idx].value;
              if (value.length + col > to) {
                renderTokens.push({
                  type: tokens2[idx].type,
                  value: value.substring(0, to - col)
                });
              } else
                renderTokens.push(tokens2[idx]);
              col += value.length;
              idx += 1;
            }
          }
          var tokens = session.getTokens(row);
          foldLine.walk(function(placeholder, row2, column, lastColumn, isNewRow) {
            if (placeholder != null) {
              renderTokens.push({
                type: "fold",
                value: placeholder
              });
            } else {
              if (isNewRow)
                tokens = session.getTokens(row2);
              if (tokens.length)
                addTokens(tokens, lastColumn, column);
            }
          }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
          return renderTokens;
        };
        Text2.prototype.$useLineGroups = function() {
          return this.session.getUseWrapMode();
        };
        return Text2;
      }()
    );
    Text.prototype.EOF_CHAR = "¶";
    Text.prototype.EOL_CHAR_LF = "¬";
    Text.prototype.EOL_CHAR_CRLF = "¤";
    Text.prototype.EOL_CHAR = Text.prototype.EOL_CHAR_LF;
    Text.prototype.TAB_CHAR = "—";
    Text.prototype.SPACE_CHAR = "·";
    Text.prototype.$padding = 0;
    Text.prototype.MAX_LINE_LENGTH = 1e4;
    Text.prototype.showInvisibles = false;
    Text.prototype.showSpaces = false;
    Text.prototype.showTabs = false;
    Text.prototype.showEOL = false;
    Text.prototype.displayIndentGuides = true;
    Text.prototype.$highlightIndentGuides = true;
    Text.prototype.$tabStrings = [];
    Text.prototype.destroy = {};
    Text.prototype.onChangeTabSize = Text.prototype.$computeTabString;
    oop.implement(Text.prototype, EventEmitter);
    exports2.Text = Text;
  });
  ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports2, module2) {
    var dom = require2("../lib/dom");
    var Cursor = (
      /** @class */
      function() {
        function Cursor2(parentEl) {
          this.element = dom.createElement("div");
          this.element.className = "ace_layer ace_cursor-layer";
          parentEl.appendChild(this.element);
          this.isVisible = false;
          this.isBlinking = true;
          this.blinkInterval = 1e3;
          this.smoothBlinking = false;
          this.cursors = [];
          this.cursor = this.addCursor();
          dom.addCssClass(this.element, "ace_hidden-cursors");
          this.$updateCursors = this.$updateOpacity.bind(this);
        }
        Cursor2.prototype.$updateOpacity = function(val) {
          var cursors = this.cursors;
          for (var i = cursors.length; i--; )
            dom.setStyle(cursors[i].style, "opacity", val ? "" : "0");
        };
        Cursor2.prototype.$startCssAnimation = function() {
          var cursors = this.cursors;
          for (var i = cursors.length; i--; )
            cursors[i].style.animationDuration = this.blinkInterval + "ms";
          this.$isAnimating = true;
          setTimeout((function() {
            if (this.$isAnimating) {
              dom.addCssClass(this.element, "ace_animate-blinking");
            }
          }).bind(this));
        };
        Cursor2.prototype.$stopCssAnimation = function() {
          this.$isAnimating = false;
          dom.removeCssClass(this.element, "ace_animate-blinking");
        };
        Cursor2.prototype.setPadding = function(padding) {
          this.$padding = padding;
        };
        Cursor2.prototype.setSession = function(session) {
          this.session = session;
        };
        Cursor2.prototype.setBlinking = function(blinking) {
          if (blinking != this.isBlinking) {
            this.isBlinking = blinking;
            this.restartTimer();
          }
        };
        Cursor2.prototype.setBlinkInterval = function(blinkInterval) {
          if (blinkInterval != this.blinkInterval) {
            this.blinkInterval = blinkInterval;
            this.restartTimer();
          }
        };
        Cursor2.prototype.setSmoothBlinking = function(smoothBlinking) {
          if (smoothBlinking != this.smoothBlinking) {
            this.smoothBlinking = smoothBlinking;
            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
            this.$updateCursors(true);
            this.restartTimer();
          }
        };
        Cursor2.prototype.addCursor = function() {
          var el = dom.createElement("div");
          el.className = "ace_cursor";
          this.element.appendChild(el);
          this.cursors.push(el);
          return el;
        };
        Cursor2.prototype.removeCursor = function() {
          if (this.cursors.length > 1) {
            var el = this.cursors.pop();
            el.parentNode.removeChild(el);
            return el;
          }
        };
        Cursor2.prototype.hideCursor = function() {
          this.isVisible = false;
          dom.addCssClass(this.element, "ace_hidden-cursors");
          this.restartTimer();
        };
        Cursor2.prototype.showCursor = function() {
          this.isVisible = true;
          dom.removeCssClass(this.element, "ace_hidden-cursors");
          this.restartTimer();
        };
        Cursor2.prototype.restartTimer = function() {
          var update = this.$updateCursors;
          clearInterval(this.intervalId);
          clearTimeout(this.timeoutId);
          this.$stopCssAnimation();
          if (this.smoothBlinking) {
            this.$isSmoothBlinking = false;
            dom.removeCssClass(this.element, "ace_smooth-blinking");
          }
          update(true);
          if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
            this.$stopCssAnimation();
            return;
          }
          if (this.smoothBlinking) {
            this.$isSmoothBlinking = true;
            setTimeout((function() {
              if (this.$isSmoothBlinking) {
                dom.addCssClass(this.element, "ace_smooth-blinking");
              }
            }).bind(this));
          }
          if (dom.HAS_CSS_ANIMATION) {
            this.$startCssAnimation();
          } else {
            var blink = (
              /**@this{Cursor}*/
              (function() {
                this.timeoutId = setTimeout(function() {
                  update(false);
                }, 0.6 * this.blinkInterval);
              }).bind(this)
            );
            this.intervalId = setInterval(function() {
              update(true);
              blink();
            }, this.blinkInterval);
            blink();
          }
        };
        Cursor2.prototype.getPixelPosition = function(position, onScreen) {
          if (!this.config || !this.session)
            return { left: 0, top: 0 };
          if (!position)
            position = this.session.selection.getCursor();
          var pos = this.session.documentToScreenPosition(position);
          var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row) ? this.session.$bidiHandler.getPosLeft(pos.column) : pos.column * this.config.characterWidth);
          var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
          return { left: cursorLeft, top: cursorTop };
        };
        Cursor2.prototype.isCursorInView = function(pixelPos, config) {
          return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;
        };
        Cursor2.prototype.update = function(config) {
          this.config = config;
          var selections = this.session.$selectionMarkers;
          var i = 0, cursorIndex = 0;
          if (selections === void 0 || selections.length === 0) {
            selections = [{ cursor: null }];
          }
          for (var i = 0, n = selections.length; i < n; i++) {
            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
            if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i > 1) {
              continue;
            }
            var element = this.cursors[cursorIndex++] || this.addCursor();
            var style2 = element.style;
            if (!this.drawCursor) {
              if (!this.isCursorInView(pixelPos, config)) {
                dom.setStyle(style2, "display", "none");
              } else {
                dom.setStyle(style2, "display", "block");
                dom.translate(element, pixelPos.left, pixelPos.top);
                dom.setStyle(style2, "width", Math.round(config.characterWidth) + "px");
                dom.setStyle(style2, "height", config.lineHeight + "px");
              }
            } else {
              this.drawCursor(element, pixelPos, config, selections[i], this.session);
            }
          }
          while (this.cursors.length > cursorIndex)
            this.removeCursor();
          var overwrite = this.session.getOverwrite();
          this.$setOverwrite(overwrite);
          this.$pixelPos = pixelPos;
          this.restartTimer();
        };
        Cursor2.prototype.$setOverwrite = function(overwrite) {
          if (overwrite != this.overwrite) {
            this.overwrite = overwrite;
            if (overwrite)
              dom.addCssClass(this.element, "ace_overwrite-cursors");
            else
              dom.removeCssClass(this.element, "ace_overwrite-cursors");
          }
        };
        Cursor2.prototype.destroy = function() {
          clearInterval(this.intervalId);
          clearTimeout(this.timeoutId);
        };
        return Cursor2;
      }()
    );
    Cursor.prototype.$padding = 0;
    Cursor.prototype.drawCursor = null;
    exports2.Cursor = Cursor;
  });
  ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(require2, exports2, module2) {
    var __extends = this && this.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var oop = require2("./lib/oop");
    var dom = require2("./lib/dom");
    var event = require2("./lib/event");
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var MAX_SCROLL_H = 32768;
    var Scrollbar = (
      /** @class */
      function() {
        function Scrollbar2(parent, classSuffix) {
          this.element = dom.createElement("div");
          this.element.className = "ace_scrollbar ace_scrollbar" + classSuffix;
          this.inner = dom.createElement("div");
          this.inner.className = "ace_scrollbar-inner";
          this.inner.textContent = " ";
          this.element.appendChild(this.inner);
          parent.appendChild(this.element);
          this.setVisible(false);
          this.skipEvent = false;
          event.addListener(this.element, "scroll", this.onScroll.bind(this));
          event.addListener(this.element, "mousedown", event.preventDefault);
        }
        Scrollbar2.prototype.setVisible = function(isVisible) {
          this.element.style.display = isVisible ? "" : "none";
          this.isVisible = isVisible;
          this.coeff = 1;
        };
        return Scrollbar2;
      }()
    );
    oop.implement(Scrollbar.prototype, EventEmitter);
    var VScrollBar = (
      /** @class */
      function(_super) {
        __extends(VScrollBar2, _super);
        function VScrollBar2(parent, renderer) {
          var _this = _super.call(this, parent, "-v") || this;
          _this.scrollTop = 0;
          _this.scrollHeight = 0;
          renderer.$scrollbarWidth = _this.width = dom.scrollbarWidth(parent.ownerDocument);
          _this.inner.style.width = _this.element.style.width = (_this.width || 15) + 5 + "px";
          _this.$minWidth = 0;
          return _this;
        }
        VScrollBar2.prototype.onScroll = function() {
          if (!this.skipEvent) {
            this.scrollTop = this.element.scrollTop;
            if (this.coeff != 1) {
              var h = this.element.clientHeight / this.scrollHeight;
              this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
            }
            this._emit("scroll", { data: this.scrollTop });
          }
          this.skipEvent = false;
        };
        VScrollBar2.prototype.getWidth = function() {
          return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
        };
        VScrollBar2.prototype.setHeight = function(height) {
          this.element.style.height = height + "px";
        };
        VScrollBar2.prototype.setScrollHeight = function(height) {
          this.scrollHeight = height;
          if (height > MAX_SCROLL_H) {
            this.coeff = MAX_SCROLL_H / height;
            height = MAX_SCROLL_H;
          } else if (this.coeff != 1) {
            this.coeff = 1;
          }
          this.inner.style.height = height + "px";
        };
        VScrollBar2.prototype.setScrollTop = function(scrollTop) {
          if (this.scrollTop != scrollTop) {
            this.skipEvent = true;
            this.scrollTop = scrollTop;
            this.element.scrollTop = scrollTop * this.coeff;
          }
        };
        return VScrollBar2;
      }(Scrollbar)
    );
    VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
    var HScrollBar = (
      /** @class */
      function(_super) {
        __extends(HScrollBar2, _super);
        function HScrollBar2(parent, renderer) {
          var _this = _super.call(this, parent, "-h") || this;
          _this.scrollLeft = 0;
          _this.height = renderer.$scrollbarWidth;
          _this.inner.style.height = _this.element.style.height = (_this.height || 15) + 5 + "px";
          return _this;
        }
        HScrollBar2.prototype.onScroll = function() {
          if (!this.skipEvent) {
            this.scrollLeft = this.element.scrollLeft;
            this._emit("scroll", { data: this.scrollLeft });
          }
          this.skipEvent = false;
        };
        HScrollBar2.prototype.getHeight = function() {
          return this.isVisible ? this.height : 0;
        };
        HScrollBar2.prototype.setWidth = function(width) {
          this.element.style.width = width + "px";
        };
        HScrollBar2.prototype.setInnerWidth = function(width) {
          this.inner.style.width = width + "px";
        };
        HScrollBar2.prototype.setScrollWidth = function(width) {
          this.inner.style.width = width + "px";
        };
        HScrollBar2.prototype.setScrollLeft = function(scrollLeft) {
          if (this.scrollLeft != scrollLeft) {
            this.skipEvent = true;
            this.scrollLeft = this.element.scrollLeft = scrollLeft;
          }
        };
        return HScrollBar2;
      }(Scrollbar)
    );
    exports2.ScrollBar = VScrollBar;
    exports2.ScrollBarV = VScrollBar;
    exports2.ScrollBarH = HScrollBar;
    exports2.VScrollBar = VScrollBar;
    exports2.HScrollBar = HScrollBar;
  });
  ace.define("ace/scrollbar_custom", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(require2, exports2, module2) {
    var __extends = this && this.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var oop = require2("./lib/oop");
    var dom = require2("./lib/dom");
    var event = require2("./lib/event");
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    dom.importCssString(".ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{\n  position: absolute;\n  background: rgba(128, 128, 128, 0.6);\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border: 1px solid #bbb;\n  border-radius: 2px;\n  z-index: 8;\n}\n.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {\n  position: absolute;\n  z-index: 6;\n  background: none;\n  overflow: hidden!important;\n}\n.ace_editor>.ace_sb-v {\n  z-index: 6;\n  right: 0;\n  top: 0;\n  width: 12px;\n}\n.ace_editor>.ace_sb-v div {\n  z-index: 8;\n  right: 0;\n  width: 100%;\n}\n.ace_editor>.ace_sb-h {\n  bottom: 0;\n  left: 0;\n  height: 12px;\n}\n.ace_editor>.ace_sb-h div {\n  bottom: 0;\n  height: 100%;\n}\n.ace_editor>.ace_sb_grabbed {\n  z-index: 8;\n  background: #000;\n}", "ace_scrollbar.css", false);
    var ScrollBar = (
      /** @class */
      function() {
        function ScrollBar2(parent, classSuffix) {
          this.element = dom.createElement("div");
          this.element.className = "ace_sb" + classSuffix;
          this.inner = dom.createElement("div");
          this.inner.className = "";
          this.element.appendChild(this.inner);
          this.VScrollWidth = 12;
          this.HScrollHeight = 12;
          parent.appendChild(this.element);
          this.setVisible(false);
          this.skipEvent = false;
          event.addMultiMouseDownListener(this.element, [500, 300, 300], this, "onMouseDown");
        }
        ScrollBar2.prototype.setVisible = function(isVisible) {
          this.element.style.display = isVisible ? "" : "none";
          this.isVisible = isVisible;
          this.coeff = 1;
        };
        return ScrollBar2;
      }()
    );
    oop.implement(ScrollBar.prototype, EventEmitter);
    var VScrollBar = (
      /** @class */
      function(_super) {
        __extends(VScrollBar2, _super);
        function VScrollBar2(parent, renderer) {
          var _this = _super.call(this, parent, "-v") || this;
          _this.scrollTop = 0;
          _this.scrollHeight = 0;
          _this.parent = parent;
          _this.width = _this.VScrollWidth;
          _this.renderer = renderer;
          _this.inner.style.width = _this.element.style.width = (_this.width || 15) + "px";
          _this.$minWidth = 0;
          return _this;
        }
        VScrollBar2.prototype.onMouseDown = function(eType, e) {
          if (eType !== "mousedown")
            return;
          if (event.getButton(e) !== 0 || e.detail === 2) {
            return;
          }
          if (e.target === this.inner) {
            var self2 = this;
            var mousePageY = e.clientY;
            var onMouseMove = function(e2) {
              mousePageY = e2.clientY;
            };
            var onMouseUp = function() {
              clearInterval(timerId);
            };
            var startY = e.clientY;
            var startTop = this.thumbTop;
            var onScrollInterval = function() {
              if (mousePageY === void 0)
                return;
              var scrollTop = self2.scrollTopFromThumbTop(startTop + mousePageY - startY);
              if (scrollTop === self2.scrollTop)
                return;
              self2._emit("scroll", { data: scrollTop });
            };
            event.capture(this.inner, onMouseMove, onMouseUp);
            var timerId = setInterval(onScrollInterval, 20);
            return event.preventDefault(e);
          }
          var top = e.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;
          this._emit("scroll", { data: this.scrollTopFromThumbTop(top) });
          return event.preventDefault(e);
        };
        VScrollBar2.prototype.getHeight = function() {
          return this.height;
        };
        VScrollBar2.prototype.scrollTopFromThumbTop = function(thumbTop) {
          var scrollTop = thumbTop * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);
          scrollTop = scrollTop >> 0;
          if (scrollTop < 0) {
            scrollTop = 0;
          } else if (scrollTop > this.pageHeight - this.viewHeight) {
            scrollTop = this.pageHeight - this.viewHeight;
          }
          return scrollTop;
        };
        VScrollBar2.prototype.getWidth = function() {
          return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
        };
        VScrollBar2.prototype.setHeight = function(height) {
          this.height = Math.max(0, height);
          this.slideHeight = this.height;
          this.viewHeight = this.height;
          this.setScrollHeight(this.pageHeight, true);
        };
        VScrollBar2.prototype.setScrollHeight = function(height, force) {
          if (this.pageHeight === height && !force)
            return;
          this.pageHeight = height;
          this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight;
          if (this.thumbHeight > this.slideHeight)
            this.thumbHeight = this.slideHeight;
          if (this.thumbHeight < 15)
            this.thumbHeight = 15;
          this.inner.style.height = this.thumbHeight + "px";
          if (this.scrollTop > this.pageHeight - this.viewHeight) {
            this.scrollTop = this.pageHeight - this.viewHeight;
            if (this.scrollTop < 0)
              this.scrollTop = 0;
            this._emit("scroll", { data: this.scrollTop });
          }
        };
        VScrollBar2.prototype.setScrollTop = function(scrollTop) {
          this.scrollTop = scrollTop;
          if (scrollTop < 0)
            scrollTop = 0;
          this.thumbTop = scrollTop * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight);
          this.inner.style.top = this.thumbTop + "px";
        };
        return VScrollBar2;
      }(ScrollBar)
    );
    VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
    var HScrollBar = (
      /** @class */
      function(_super) {
        __extends(HScrollBar2, _super);
        function HScrollBar2(parent, renderer) {
          var _this = _super.call(this, parent, "-h") || this;
          _this.scrollLeft = 0;
          _this.scrollWidth = 0;
          _this.height = _this.HScrollHeight;
          _this.inner.style.height = _this.element.style.height = (_this.height || 12) + "px";
          _this.renderer = renderer;
          return _this;
        }
        HScrollBar2.prototype.onMouseDown = function(eType, e) {
          if (eType !== "mousedown")
            return;
          if (event.getButton(e) !== 0 || e.detail === 2) {
            return;
          }
          if (e.target === this.inner) {
            var self2 = this;
            var mousePageX = e.clientX;
            var onMouseMove = function(e2) {
              mousePageX = e2.clientX;
            };
            var onMouseUp = function() {
              clearInterval(timerId);
            };
            var startX = e.clientX;
            var startLeft = this.thumbLeft;
            var onScrollInterval = function() {
              if (mousePageX === void 0)
                return;
              var scrollLeft = self2.scrollLeftFromThumbLeft(startLeft + mousePageX - startX);
              if (scrollLeft === self2.scrollLeft)
                return;
              self2._emit("scroll", { data: scrollLeft });
            };
            event.capture(this.inner, onMouseMove, onMouseUp);
            var timerId = setInterval(onScrollInterval, 20);
            return event.preventDefault(e);
          }
          var left = e.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;
          this._emit("scroll", { data: this.scrollLeftFromThumbLeft(left) });
          return event.preventDefault(e);
        };
        HScrollBar2.prototype.getHeight = function() {
          return this.isVisible ? this.height : 0;
        };
        HScrollBar2.prototype.scrollLeftFromThumbLeft = function(thumbLeft) {
          var scrollLeft = thumbLeft * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);
          scrollLeft = scrollLeft >> 0;
          if (scrollLeft < 0) {
            scrollLeft = 0;
          } else if (scrollLeft > this.pageWidth - this.viewWidth) {
            scrollLeft = this.pageWidth - this.viewWidth;
          }
          return scrollLeft;
        };
        HScrollBar2.prototype.setWidth = function(width) {
          this.width = Math.max(0, width);
          this.element.style.width = this.width + "px";
          this.slideWidth = this.width;
          this.viewWidth = this.width;
          this.setScrollWidth(this.pageWidth, true);
        };
        HScrollBar2.prototype.setScrollWidth = function(width, force) {
          if (this.pageWidth === width && !force)
            return;
          this.pageWidth = width;
          this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth;
          if (this.thumbWidth > this.slideWidth)
            this.thumbWidth = this.slideWidth;
          if (this.thumbWidth < 15)
            this.thumbWidth = 15;
          this.inner.style.width = this.thumbWidth + "px";
          if (this.scrollLeft > this.pageWidth - this.viewWidth) {
            this.scrollLeft = this.pageWidth - this.viewWidth;
            if (this.scrollLeft < 0)
              this.scrollLeft = 0;
            this._emit("scroll", { data: this.scrollLeft });
          }
        };
        HScrollBar2.prototype.setScrollLeft = function(scrollLeft) {
          this.scrollLeft = scrollLeft;
          if (scrollLeft < 0)
            scrollLeft = 0;
          this.thumbLeft = scrollLeft * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth);
          this.inner.style.left = this.thumbLeft + "px";
        };
        return HScrollBar2;
      }(ScrollBar)
    );
    HScrollBar.prototype.setInnerWidth = HScrollBar.prototype.setScrollWidth;
    exports2.ScrollBar = VScrollBar;
    exports2.ScrollBarV = VScrollBar;
    exports2.ScrollBarH = HScrollBar;
    exports2.VScrollBar = VScrollBar;
    exports2.HScrollBar = HScrollBar;
  });
  ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function(require2, exports2, module2) {
    var event = require2("./lib/event");
    var RenderLoop = (
      /** @class */
      function() {
        function RenderLoop2(onRender, win) {
          this.onRender = onRender;
          this.pending = false;
          this.changes = 0;
          this.$recursionLimit = 2;
          this.window = win || window;
          var _self = this;
          this._flush = function(ts) {
            _self.pending = false;
            var changes = _self.changes;
            if (changes) {
              event.blockIdle(100);
              _self.changes = 0;
              _self.onRender(changes);
            }
            if (_self.changes) {
              if (_self.$recursionLimit-- < 0)
                return;
              _self.schedule();
            } else {
              _self.$recursionLimit = 2;
            }
          };
        }
        RenderLoop2.prototype.schedule = function(change) {
          this.changes = this.changes | change;
          if (this.changes && !this.pending) {
            event.nextFrame(this._flush);
            this.pending = true;
          }
        };
        RenderLoop2.prototype.clear = function(change) {
          var changes = this.changes;
          this.changes = 0;
          return changes;
        };
        return RenderLoop2;
      }()
    );
    exports2.RenderLoop = RenderLoop;
  });
  ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/event", "ace/lib/useragent", "ace/lib/event_emitter"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var dom = require2("../lib/dom");
    var lang = require2("../lib/lang");
    var event = require2("../lib/event");
    var useragent = require2("../lib/useragent");
    var EventEmitter = require2("../lib/event_emitter").EventEmitter;
    var CHAR_COUNT = 512;
    var USE_OBSERVER = typeof ResizeObserver == "function";
    var L = 200;
    var FontMetrics = (
      /** @class */
      function() {
        function FontMetrics2(parentEl) {
          this.el = dom.createElement("div");
          this.$setMeasureNodeStyles(this.el.style, true);
          this.$main = dom.createElement("div");
          this.$setMeasureNodeStyles(this.$main.style);
          this.$measureNode = dom.createElement("div");
          this.$setMeasureNodeStyles(this.$measureNode.style);
          this.el.appendChild(this.$main);
          this.el.appendChild(this.$measureNode);
          parentEl.appendChild(this.el);
          this.$measureNode.textContent = lang.stringRepeat("X", CHAR_COUNT);
          this.$characterSize = { width: 0, height: 0 };
          if (USE_OBSERVER)
            this.$addObserver();
          else
            this.checkForSizeChanges();
        }
        FontMetrics2.prototype.$setMeasureNodeStyles = function(style2, isRoot) {
          style2.width = style2.height = "auto";
          style2.left = style2.top = "0px";
          style2.visibility = "hidden";
          style2.position = "absolute";
          style2.whiteSpace = "pre";
          if (useragent.isIE < 8) {
            style2["font-family"] = "inherit";
          } else {
            style2.font = "inherit";
          }
          style2.overflow = isRoot ? "hidden" : "visible";
        };
        FontMetrics2.prototype.checkForSizeChanges = function(size) {
          if (size === void 0)
            size = this.$measureSizes();
          if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
            this.$measureNode.style.fontWeight = "bold";
            var boldSize = this.$measureSizes();
            this.$measureNode.style.fontWeight = "";
            this.$characterSize = size;
            this.charSizes = /* @__PURE__ */ Object.create(null);
            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
            this._emit("changeCharacterSize", { data: size });
          }
        };
        FontMetrics2.prototype.$addObserver = function() {
          var self2 = this;
          this.$observer = new window.ResizeObserver(function(e) {
            self2.checkForSizeChanges();
          });
          this.$observer.observe(this.$measureNode);
        };
        FontMetrics2.prototype.$pollSizeChanges = function() {
          if (this.$pollSizeChangesTimer || this.$observer)
            return this.$pollSizeChangesTimer;
          var self2 = this;
          return this.$pollSizeChangesTimer = event.onIdle(function cb() {
            self2.checkForSizeChanges();
            event.onIdle(cb, 500);
          }, 500);
        };
        FontMetrics2.prototype.setPolling = function(val) {
          if (val) {
            this.$pollSizeChanges();
          } else if (this.$pollSizeChangesTimer) {
            clearInterval(this.$pollSizeChangesTimer);
            this.$pollSizeChangesTimer = 0;
          }
        };
        FontMetrics2.prototype.$measureSizes = function(node) {
          var size = {
            height: (node || this.$measureNode).clientHeight,
            width: (node || this.$measureNode).clientWidth / CHAR_COUNT
          };
          if (size.width === 0 || size.height === 0)
            return null;
          return size;
        };
        FontMetrics2.prototype.$measureCharWidth = function(ch) {
          this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);
          var rect = this.$main.getBoundingClientRect();
          return rect.width / CHAR_COUNT;
        };
        FontMetrics2.prototype.getCharacterWidth = function(ch) {
          var w = this.charSizes[ch];
          if (w === void 0) {
            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
          }
          return w;
        };
        FontMetrics2.prototype.destroy = function() {
          clearInterval(this.$pollSizeChangesTimer);
          if (this.$observer)
            this.$observer.disconnect();
          if (this.el && this.el.parentNode)
            this.el.parentNode.removeChild(this.el);
        };
        FontMetrics2.prototype.$getZoom = function(element) {
          if (!element || !element.parentElement)
            return 1;
          return (Number(window.getComputedStyle(element)["zoom"]) || 1) * this.$getZoom(element.parentElement);
        };
        FontMetrics2.prototype.$initTransformMeasureNodes = function() {
          var t = function(t2, l) {
            return ["div", {
              style: "position: absolute;top:" + t2 + "px;left:" + l + "px;"
            }];
          };
          this.els = dom.buildDom([t(0, 0), t(L, 0), t(0, L), t(L, L)], this.el);
        };
        FontMetrics2.prototype.transformCoordinates = function(clientPos, elPos) {
          if (clientPos) {
            var zoom = this.$getZoom(this.el);
            clientPos = mul(1 / zoom, clientPos);
          }
          function solve(l1, l2, r) {
            var det = l1[1] * l2[0] - l1[0] * l2[1];
            return [
              (-l2[1] * r[0] + l2[0] * r[1]) / det,
              (+l1[1] * r[0] - l1[0] * r[1]) / det
            ];
          }
          function sub(a2, b2) {
            return [a2[0] - b2[0], a2[1] - b2[1]];
          }
          function add(a2, b2) {
            return [a2[0] + b2[0], a2[1] + b2[1]];
          }
          function mul(a2, b2) {
            return [a2 * b2[0], a2 * b2[1]];
          }
          if (!this.els)
            this.$initTransformMeasureNodes();
          function p(el) {
            var r = el.getBoundingClientRect();
            return [r.left, r.top];
          }
          var a = p(this.els[0]);
          var b = p(this.els[1]);
          var c = p(this.els[2]);
          var d = p(this.els[3]);
          var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));
          var m1 = mul(1 + h[0], sub(b, a));
          var m2 = mul(1 + h[1], sub(c, a));
          if (elPos) {
            var x = elPos;
            var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;
            var ut = add(mul(x[0], m1), mul(x[1], m2));
            return add(mul(1 / k / L, ut), a);
          }
          var u = sub(clientPos, a);
          var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);
          return mul(L, f);
        };
        return FontMetrics2;
      }()
    );
    FontMetrics.prototype.$characterSize = { width: 0, height: 0 };
    oop.implement(FontMetrics.prototype, EventEmitter);
    exports2.FontMetrics = FontMetrics;
  });
  ace.define("ace/css/editor-css", ["require", "exports", "module"], function(require2, exports2, module2) {
    module2.exports = `
.ace_br1 {border-top-left-radius    : 3px;}
.ace_br2 {border-top-right-radius   : 3px;}
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}
.ace_br4 {border-bottom-right-radius: 3px;}
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}
.ace_br8 {border-bottom-left-radius : 3px;}
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}


.ace_editor {
    position: relative;
    overflow: hidden;
    padding: 0;
    font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Source Code Pro', 'source-code-pro', monospace;
    direction: ltr;
    text-align: left;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    forced-color-adjust: none;
}

.ace_scroller {
    position: absolute;
    overflow: hidden;
    top: 0;
    bottom: 0;
    background-color: inherit;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: text;
}

.ace_content {
    position: absolute;
    box-sizing: border-box;
    min-width: 100%;
    contain: style size layout;
    font-variant-ligatures: no-common-ligatures;
}
.ace_invisible {
    font-variant-ligatures: none;
}

.ace_keyboard-focus:focus {
    box-shadow: inset 0 0 0 2px #5E9ED6;
    outline: none;
}

.ace_dragging .ace_scroller:before{
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    content: '';
    background: rgba(250, 250, 250, 0.01);
    z-index: 1000;
}
.ace_dragging.ace_dark .ace_scroller:before{
    background: rgba(0, 0, 0, 0.01);
}

.ace_gutter {
    position: absolute;
    overflow : hidden;
    width: auto;
    top: 0;
    bottom: 0;
    left: 0;
    cursor: default;
    z-index: 4;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    contain: style size layout;
}

.ace_gutter-active-line {
    position: absolute;
    left: 0;
    right: 0;
}

.ace_scroller.ace_scroll-left:after {
    content: "";
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;
    pointer-events: none;
}

.ace_gutter-cell, .ace_gutter-cell_svg-icons {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding-left: 19px;
    padding-right: 6px;
    background-repeat: no-repeat;
}

.ace_gutter-cell_svg-icons .ace_gutter_annotation {
    margin-left: -14px;
    float: left;
}

.ace_gutter-cell .ace_gutter_annotation {
    margin-left: -19px;
    float: left;
}

.ace_gutter-cell.ace_error, .ace_icon.ace_error, .ace_icon.ace_error_fold, .ace_gutter-cell.ace_security, .ace_icon.ace_security, .ace_icon.ace_security_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_warning, .ace_icon.ace_warning, .ace_icon.ace_warning_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_info, .ace_icon.ace_info, .ace_gutter-cell.ace_hint, .ace_icon.ace_hint {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_dark .ace_gutter-cell.ace_info, .ace_dark .ace_icon.ace_info, .ace_dark .ace_gutter-cell.ace_hint, .ace_dark .ace_icon.ace_hint {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");
}

.ace_icon_svg.ace_error {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJyZWQiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KPGNpcmNsZSBmaWxsPSJub25lIiBjeD0iOCIgY3k9IjgiIHI9IjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPGxpbmUgeDE9IjExIiB5MT0iNSIgeDI9IjUiIHkyPSIxMSIvPgo8bGluZSB4MT0iMTEiIHkxPSIxMSIgeDI9IjUiIHkyPSI1Ii8+CjwvZz4KPC9zdmc+");
    background-color: crimson;
}
.ace_icon_svg.ace_security {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0iZGFya29yYW5nZSIgZmlsbD0ibm9uZSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgogICAgICAgIDxwYXRoIGNsYXNzPSJzdHJva2UtbGluZWpvaW4tcm91bmQiIGQ9Ik04IDE0LjgzMDdDOCAxNC44MzA3IDIgMTIuOTA0NyAyIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOEM3Ljk4OTk5IDEuMzQ5MTggMTAuNjkgMy4yNjU0OCAxNCAzLjI2NTQ4VjguMDg5OTJDMTQgMTIuOTA0NyA4IDE0LjgzMDcgOCAxNC44MzA3WiIvPgogICAgICAgIDxwYXRoIGQ9Ik0yIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOCIvPgogICAgICAgIDxwYXRoIGQ9Ik0xMy45OSA4LjA4OTkyVjMuMjY1NDhDMTAuNjggMy4yNjU0OCA4IDEuMzQ5MTggOCAxLjM0OTE4Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggNFY5Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggMTBWMTIiLz4KICAgIDwvZz4KPC9zdmc+");
    background-color: crimson;
}
.ace_icon_svg.ace_warning {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJkYXJrb3JhbmdlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+Cjxwb2x5Z29uIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiIHBvaW50cz0iOCAxIDE1IDE1IDEgMTUgOCAxIi8+CjxyZWN0IHg9IjgiIHk9IjEyIiB3aWR0aD0iMC4wMSIgaGVpZ2h0PSIwLjAxIi8+CjxsaW5lIHgxPSI4IiB5MT0iNiIgeDI9IjgiIHkyPSIxMCIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: darkorange;
}
.ace_icon_svg.ace_info {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJibHVlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CjxjaXJjbGUgZmlsbD0ibm9uZSIgY3g9IjgiIGN5PSI4IiByPSI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjxwb2x5bGluZSBwb2ludHM9IjggMTEgOCA4Ii8+Cjxwb2x5bGluZSBwb2ludHM9IjkgOCA2IDgiLz4KPGxpbmUgeDE9IjEwIiB5MT0iMTEiIHgyPSI2IiB5Mj0iMTEiLz4KPHJlY3QgeD0iOCIgeT0iNSIgd2lkdGg9IjAuMDEiIGhlaWdodD0iMC4wMSIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: royalblue;
}
.ace_icon_svg.ace_hint {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0ic2lsdmVyIiBmaWxsPSJub25lIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTYgMTRIMTAiLz4KICAgICAgICA8cGF0aCBkPSJNOCAxMUg5QzkgOS40NzAwMiAxMiA4LjU0MDAyIDEyIDUuNzYwMDJDMTIuMDIgNC40MDAwMiAxMS4zOSAzLjM2MDAyIDEwLjQzIDIuNjcwMDJDOSAxLjY0MDAyIDcuMDAwMDEgMS42NDAwMiA1LjU3MDAxIDIuNjcwMDJDNC42MTAwMSAzLjM2MDAyIDMuOTggNC40MDAwMiA0IDUuNzYwMDJDNCA4LjU0MDAyIDcuMDAwMDEgOS40NzAwMiA3LjAwMDAxIDExSDhaIi8+CiAgICA8L2c+Cjwvc3ZnPg==");
    background-color: silver;
}

.ace_icon_svg.ace_error_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSI+CiAgPHBhdGggZD0ibSAxOC45Mjk4NTEsNy44Mjk4MDc2IGMgMC4xNDYzNTMsNi4zMzc0NjA0IC02LjMyMzE0Nyw3Ljc3Nzg0NDQgLTcuNDc3OTEyLDcuNzc3ODQ0NCAtMi4xMDcyNzI2LC0wLjEyODc1IDUuMTE3Njc4LDAuMzU2MjQ5IDUuMDUxNjk4LC03Ljg3MDA2MTggLTAuNjA0NjcyLC04LjAwMzk3MzQ5IC03LjA3NzI3MDYsLTcuNTYzMTE4OSAtNC44NTczLC03LjQzMDM5NTU2IDEuNjA2LC0wLjExNTE0MjI1IDYuODk3NDg1LDEuMjYyNTQ1OTYgNy4yODM1MTQsNy41MjI2MTI5NiB6IiBmaWxsPSJjcmltc29uIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibSA4LjExNDc1NjIsMi4wNTI5ODI4IGMgMy4zNDkxNjk4LDAgNi4wNjQxMzI4LDIuNjc2ODYyNyA2LjA2NDEzMjgsNS45Nzg5NTMgMCwzLjMwMjExMjIgLTIuNzE0OTYzLDUuOTc4OTIwMiAtNi4wNjQxMzI4LDUuOTc4OTIwMiAtMy4zNDkxNDczLDAgLTYuMDY0MTc3MiwtMi42NzY4MDggLTYuMDY0MTc3MiwtNS45Nzg5MjAyIDAuMDA1MzksLTMuMjk5ODg2MSAyLjcxNzI2NTYsLTUuOTczNjQwOCA2LjA2NDE3NzIsLTUuOTc4OTUzIHogbSAwLC0xLjczNTgyNzE5IGMgLTQuMzIxNDgzNiwwIC03LjgyNDc0MDM4LDMuNDU0MDE4NDkgLTcuODI0NzQwMzgsNy43MTQ3ODAxOSAwLDQuMjYwNzI4MiAzLjUwMzI1Njc4LDcuNzE0NzQ1MiA3LjgyNDc0MDM4LDcuNzE0NzQ1MiA0LjMyMTQ0OTgsMCA3LjgyNDY5OTgsLTMuNDU0MDE3IDcuODI0Njk5OCwtNy43MTQ3NDUyIDAsLTIuMDQ2MDkxNCAtMC44MjQzOTIsLTQuMDA4MzY3MiAtMi4yOTE3NTYsLTUuNDU1MTc0NiBDIDEyLjE4MDIyNSwxLjEyOTk2NDggMTAuMTkwMDEzLDAuMzE3MTU1NjEgOC4xMTQ3NTYyLDAuMzE3MTU1NjEgWiBNIDYuOTM3NDU2Myw4LjI0MDU5ODUgNC42NzE4Njg1LDEwLjQ4NTg1MiA2LjAwODY4MTQsMTEuODc2NzI4IDguMzE3MDAzNSw5LjYwMDc5MTEgMTAuNjI1MzM3LDExLjg3NjcyOCAxMS45NjIxMzgsMTAuNDg1ODUyIDkuNjk2NTUwOCw4LjI0MDU5ODUgMTEuOTYyMTM4LDYuMDA2ODA2NiAxMC41NzMyNDYsNC42Mzc0MzM1IDguMzE3MDAzNSw2Ljg3MzQyOTcgNi4wNjA3NjA3LDQuNjM3NDMzNSA0LjY3MTg2ODUsNi4wMDY4MDY2IFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");
    background-color: crimson;
}
.ace_icon_svg.ace_security_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMTcgMTQiIGZpbGw9Im5vbmUiPgogICAgPHBhdGggZD0iTTEwLjAwMDEgMTMuNjk5MkMxMC4wMDAxIDEzLjY5OTIgMTEuOTI0MSAxMy40NzYzIDEzIDEyLjY5OTJDMTQuNDEzOSAxMS42NzgxIDE2IDEwLjUgMTYuMTI1MSA2LjgxMTI2VjIuNTg5ODdDMTYuMTI1MSAyLjU0NzY4IDE2LjEyMjEgMi41MDYxOSAxNi4xMTY0IDIuNDY1NTlWMS43MTQ4NUgxNS4yNDE0TDE1LjIzMDcgMS43MTQ4NEwxNC42MjUxIDEuNjk5MjJWNi44MTEyM0MxNC42MjUxIDguNTEwNjEgMTQuNjI1MSA5LjQ2NDYxIDEyLjc4MjQgMTEuNzIxQzEyLjE1ODYgMTIuNDg0OCAxMC4wMDAxIDEzLjY5OTIgMTAuMDAwMSAxMy42OTkyWiIgZmlsbD0iY3JpbXNvbiIgc3Ryb2tlLXdpZHRoPSIyIi8+CiAgICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTcuMzM2MDkgMC4zNjc0NzVDNy4wMzIxNCAwLjE1MjY1MiA2LjYyNTQ4IDAuMTUzNjE0IDYuMzIyNTMgMC4zNjk5OTdMNi4zMDg2OSAwLjM3OTU1NEM2LjI5NTUzIDAuMzg4NTg4IDYuMjczODggMC40MDMyNjYgNi4yNDQxNyAwLjQyMjc4OUM2LjE4NDcxIDAuNDYxODYgNi4wOTMyMSAwLjUyMDE3MSA1Ljk3MzEzIDAuNTkxMzczQzUuNzMyNTEgMC43MzQwNTkgNS4zNzk5IDAuOTI2ODY0IDQuOTQyNzkgMS4xMjAwOUM0LjA2MTQ0IDEuNTA5NyAyLjg3NTQxIDEuODgzNzcgMS41ODk4NCAxLjg4Mzc3SDAuNzE0ODQ0VjIuNzU4NzdWNi45ODAxNUMwLjcxNDg0NCA5LjQ5Mzc0IDIuMjg4NjYgMTEuMTk3MyAzLjcwMjU0IDEyLjIxODVDNC40MTg0NSAxMi43MzU1IDUuMTI4NzQgMTMuMTA1MyA1LjY1NzMzIDEzLjM0NTdDNS45MjI4NCAxMy40NjY0IDYuMTQ1NjYgMTMuNTU1OSA2LjMwNDY1IDEzLjYxNjFDNi4zODQyMyAxMy42NDYyIDYuNDQ4MDUgMTMuNjY5IDYuNDkzNDkgMTMuNjg0OEM2LjUxNjIyIDEzLjY5MjcgNi41MzQzOCAxMy42OTg5IDYuNTQ3NjQgMTMuNzAzM0w2LjU2MzgyIDEzLjcwODdMNi41NjkwOCAxMy43MTA0TDYuNTcwOTkgMTMuNzExTDYuODM5ODQgMTMuNzUzM0w2LjU3MjQyIDEzLjcxMTVDNi43NDYzMyAxMy43NjczIDYuOTMzMzUgMTMuNzY3MyA3LjEwNzI3IDEzLjcxMTVMNy4xMDg3IDEzLjcxMUw3LjExMDYxIDEzLjcxMDRMNy4xMTU4NyAxMy43MDg3TDcuMTMyMDUgMTMuNzAzM0M3LjE0NTMxIDEzLjY5ODkgNy4xNjM0NiAxMy42OTI3IDcuMTg2MTkgMTMuNjg0OEM3LjIzMTY0IDEzLjY2OSA3LjI5NTQ2IDEzLjY0NjIgNy4zNzUwMyAxMy42MTYxQzcuNTM0MDMgMTMuNTU1OSA3Ljc1Njg1IDEzLjQ2NjQgOC4wMjIzNiAxMy4zNDU3QzguNTUwOTUgMTMuMTA1MyA5LjI2MTIzIDEyLjczNTUgOS45NzcxNSAxMi4yMTg1QzExLjM5MSAxMS4xOTczIDEyLjk2NDggOS40OTM3NyAxMi45NjQ4IDYuOTgwMThWMi43NTg4QzEyLjk2NDggMi43MTY2IDEyLjk2MTkgMi42NzUxMSAxMi45NTYxIDIuNjM0NTFWMS44ODM3N0gxMi4wODExQzEyLjA3NzUgMS44ODM3NyAxMi4wNzQgMS44ODM3NyAxMi4wNzA0IDEuODgzNzdDMTAuNzk3OSAxLjg4MDA0IDkuNjE5NjIgMS41MTEwMiA4LjczODk0IDEuMTI0ODZDOC43MzUzNCAxLjEyMzI3IDguNzMxNzQgMS4xMjE2OCA4LjcyODE0IDEuMTIwMDlDOC4yOTEwMyAwLjkyNjg2NCA3LjkzODQyIDAuNzM0MDU5IDcuNjk3NzkgMC41OTEzNzNDNy41Nzc3MiAwLjUyMDE3MSA3LjQ4NjIyIDAuNDYxODYgNy40MjY3NiAwLjQyMjc4OUM3LjM5NzA1IDAuNDAzMjY2IDcuMzc1MzkgMC4zODg1ODggNy4zNjIyNCAwLjM3OTU1NEw3LjM0ODk2IDAuMzcwMzVDNy4zNDg5NiAwLjM3MDM1IDcuMzQ4NDcgMC4zNzAwMiA3LjM0NTYzIDAuMzc0MDU0TDcuMzM3NzkgMC4zNjg2NTlMNy4zMzYwOSAwLjM2NzQ3NVpNOC4wMzQ3MSAyLjcyNjkxQzguODYwNCAzLjA5MDYzIDkuOTYwNjYgMy40NjMwOSAxMS4yMDYxIDMuNTg5MDdWNi45ODAxNUgxMS4yMTQ4QzExLjIxNDggOC42Nzk1MyAxMC4xNjM3IDkuOTI1MDcgOC45NTI1NCAxMC43OTk4QzguMzU1OTUgMTEuMjMwNiA3Ljc1Mzc0IDExLjU0NTQgNy4yOTc5NiAxMS43NTI3QzcuMTE2NzEgMTEuODM1MSA2Ljk2MDYyIDExLjg5OTYgNi44Mzk4NCAxMS45NDY5QzYuNzE5MDYgMTEuODk5NiA2LjU2Mjk3IDExLjgzNTEgNi4zODE3MyAxMS43NTI3QzUuOTI1OTUgMTEuNTQ1NCA1LjMyMzczIDExLjIzMDYgNC43MjcxNSAxMC43OTk4QzMuNTE2MDMgOS45MjUwNyAyLjQ2NDg0IDguNjc5NTUgMi40NjQ4NCA2Ljk4MDE4VjMuNTg5MDlDMy43MTczOCAzLjQ2MjM5IDQuODIzMDggMy4wODYzOSA1LjY1MDMzIDIuNzIwNzFDNi4xNDIyOCAyLjUwMzI0IDYuNTQ0ODUgMi4yODUzNyA2LjgzMjU0IDIuMTE2MjRDNy4xMjE4MSAyLjI4NTM1IDcuNTI3IDIuNTAzNTIgOC4wMjE5NiAyLjcyMTMxQzguMDI2MiAyLjcyMzE3IDguMDMwNDUgMi43MjUwNCA4LjAzNDcxIDIuNzI2OTFaTTUuOTY0ODQgMy40MDE0N1Y3Ljc3NjQ3SDcuNzE0ODRWMy40MDE0N0g1Ljk2NDg0Wk01Ljk2NDg0IDEwLjQwMTVWOC42NTE0N0g3LjcxNDg0VjEwLjQwMTVINS45NjQ4NFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");
    background-color: crimson;
}
.ace_icon_svg.ace_warning_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC43NzY5IDE0LjczMzdMOC42NTE5MiAyLjQ4MzY5QzguMzI5NDYgMS44Mzg3NyA3LjQwOTEzIDEuODM4NzcgNy4wODY2NyAyLjQ4MzY5TDAuOTYxNjY5IDE0LjczMzdDMC42NzA3NzUgMTUuMzE1NSAxLjA5MzgzIDE2IDEuNzQ0MjkgMTZIMTMuOTk0M0MxNC42NDQ4IDE2IDE1LjA2NzggMTUuMzE1NSAxNC43NzY5IDE0LjczMzdaTTMuMTYwMDcgMTQuMjVMNy44NjkyOSA0LjgzMTU2TDEyLjU3ODUgMTQuMjVIMy4xNjAwN1pNOC43NDQyOSAxMS42MjVWMTMuMzc1SDYuOTk0MjlWMTEuNjI1SDguNzQ0MjlaTTYuOTk0MjkgMTAuNzVWNy4yNUg4Ljc0NDI5VjEwLjc1SDYuOTk0MjlaIiBmaWxsPSIjRUM3MjExIi8+CjxwYXRoIGQ9Ik0xMS4xOTkxIDIuOTUyMzhDMTAuODgwOSAyLjMxNDY3IDEwLjM1MzcgMS44MDUyNiA5LjcwNTUgMS41MDlMMTEuMDQxIDEuMDY5NzhDMTEuNjg4MyAwLjk0OTgxNCAxMi4zMzcgMS4yNzI2MyAxMi42MzE3IDEuODYxNDFMMTcuNjEzNiAxMS44MTYxQzE4LjM1MjcgMTMuMjkyOSAxNy41OTM4IDE1LjA4MDQgMTYuMDE4IDE1LjU3NDVDMTYuNDA0NCAxNC40NTA3IDE2LjMyMzEgMTMuMjE4OCAxNS43OTI0IDEyLjE1NTVMMTEuMTk5MSAyLjk1MjM4WiIgZmlsbD0iI0VDNzIxMSIvPgo8L3N2Zz4=");
    background-color: darkorange;
}

.ace_scrollbar {
    contain: strict;
    position: absolute;
    right: 0;
    bottom: 0;
    z-index: 6;
}

.ace_scrollbar-inner {
    position: absolute;
    cursor: text;
    left: 0;
    top: 0;
}

.ace_scrollbar-v{
    overflow-x: hidden;
    overflow-y: scroll;
    top: 0;
}

.ace_scrollbar-h {
    overflow-x: scroll;
    overflow-y: hidden;
    left: 0;
}

.ace_print-margin {
    position: absolute;
    height: 100%;
}

.ace_text-input {
    position: absolute;
    z-index: 0;
    width: 0.5em;
    height: 1em;
    opacity: 0;
    background: transparent;
    -moz-appearance: none;
    appearance: none;
    border: none;
    resize: none;
    outline: none;
    overflow: hidden;
    font: inherit;
    padding: 0 1px;
    margin: 0 -1px;
    contain: strict;
    -ms-user-select: text;
    -moz-user-select: text;
    -webkit-user-select: text;
    user-select: text;
    /*with \`pre-line\` chrome inserts &nbsp; instead of space*/
    white-space: pre!important;
}
.ace_text-input.ace_composition {
    background: transparent;
    color: inherit;
    z-index: 1000;
    opacity: 1;
}
.ace_composition_placeholder { color: transparent }
.ace_composition_marker { 
    border-bottom: 1px solid;
    position: absolute;
    border-radius: 0;
    margin-top: 1px;
}

[ace_nocontext=true] {
    transform: none!important;
    filter: none!important;
    clip-path: none!important;
    mask : none!important;
    contain: none!important;
    perspective: none!important;
    mix-blend-mode: initial!important;
    z-index: auto;
}

.ace_layer {
    z-index: 1;
    position: absolute;
    overflow: hidden;
    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/
    word-wrap: normal;
    white-space: pre;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
    /* setting pointer-events: auto; on node under the mouse, which changes
        during scroll, will break mouse wheel scrolling in Safari */
    pointer-events: none;
}

.ace_gutter-layer {
    position: relative;
    width: auto;
    text-align: right;
    pointer-events: auto;
    height: 1000000px;
    contain: style size layout;
}

.ace_text-layer {
    font: inherit !important;
    position: absolute;
    height: 1000000px;
    width: 1000000px;
    contain: style size layout;
}

.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {
    contain: style size layout;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
}

.ace_hidpi .ace_text-layer,
.ace_hidpi .ace_gutter-layer,
.ace_hidpi .ace_content,
.ace_hidpi .ace_gutter {
    contain: strict;
}
.ace_hidpi .ace_text-layer > .ace_line, 
.ace_hidpi .ace_text-layer > .ace_line_group {
    contain: strict;
}

.ace_cjk {
    display: inline-block;
    text-align: center;
}

.ace_cursor-layer {
    z-index: 4;
}

.ace_cursor {
    z-index: 4;
    position: absolute;
    box-sizing: border-box;
    border-left: 2px solid;
    /* workaround for smooth cursor repaintng whole screen in chrome */
    transform: translatez(0);
}

.ace_multiselect .ace_cursor {
    border-left-width: 1px;
}

.ace_slim-cursors .ace_cursor {
    border-left-width: 1px;
}

.ace_overwrite-cursors .ace_cursor {
    border-left-width: 0;
    border-bottom: 1px solid;
}

.ace_hidden-cursors .ace_cursor {
    opacity: 0.2;
}

.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {
    opacity: 0;
}

.ace_smooth-blinking .ace_cursor {
    transition: opacity 0.18s;
}

.ace_animate-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: step-end;
    animation-name: blink-ace-animate;
    animation-iteration-count: infinite;
}

.ace_animate-blinking.ace_smooth-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: ease-in-out;
    animation-name: blink-ace-animate-smooth;
}
    
@keyframes blink-ace-animate {
    from, to { opacity: 1; }
    60% { opacity: 0; }
}

@keyframes blink-ace-animate-smooth {
    from, to { opacity: 1; }
    45% { opacity: 1; }
    60% { opacity: 0; }
    85% { opacity: 0; }
}

.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {
    position: absolute;
    z-index: 3;
}

.ace_marker-layer .ace_selection {
    position: absolute;
    z-index: 5;
}

.ace_marker-layer .ace_bracket {
    position: absolute;
    z-index: 6;
}

.ace_marker-layer .ace_error_bracket {
    position: absolute;
    border-bottom: 1px solid #DE5555;
    border-radius: 0;
}

.ace_marker-layer .ace_active-line {
    position: absolute;
    z-index: 2;
}

.ace_marker-layer .ace_selected-word {
    position: absolute;
    z-index: 4;
    box-sizing: border-box;
}

.ace_line .ace_fold {
    box-sizing: border-box;

    display: inline-block;
    height: 11px;
    margin-top: -2px;
    vertical-align: middle;

    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");
    background-repeat: no-repeat, repeat-x;
    background-position: center center, top left;
    color: transparent;

    border: 1px solid black;
    border-radius: 2px;

    cursor: pointer;
    pointer-events: auto;
}

.ace_dark .ace_fold {
}

.ace_fold:hover{
    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");
}

.ace_tooltip {
    background-color: #f5f5f5;
    border: 1px solid gray;
    border-radius: 1px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    color: black;
    padding: 3px 4px;
    position: absolute;
    z-index: 999999;
    box-sizing: border-box;
    cursor: default;
    white-space: pre-wrap;
    word-wrap: break-word;
    line-height: normal;
    font-style: normal;
    font-weight: normal;
    letter-spacing: normal;
    pointer-events: none;
    overflow: auto;
    max-width: min(33em, 66vw);
    overscroll-behavior: contain;
}
.ace_tooltip pre {
    white-space: pre-wrap;
}

.ace_tooltip.ace_dark {
    background-color: #636363;
    color: #fff;
}

.ace_tooltip:focus {
    outline: 1px solid #5E9ED6;
}

.ace_icon {
    display: inline-block;
    width: 18px;
    vertical-align: top;
}

.ace_icon_svg {
    display: inline-block;
    width: 12px;
    vertical-align: top;
    -webkit-mask-repeat: no-repeat;
    -webkit-mask-size: 12px;
    -webkit-mask-position: center;
}

.ace_folding-enabled > .ace_gutter-cell, .ace_folding-enabled > .ace_gutter-cell_svg-icons {
    padding-right: 13px;
}

.ace_fold-widget, .ace_custom-widget {
    box-sizing: border-box;

    margin: 0 -12px 0 1px;
    display: none;
    width: 11px;
    vertical-align: top;

    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: center;

    border-radius: 3px;
    
    border: 1px solid transparent;
    cursor: pointer;
    pointer-events: auto;
}

.ace_custom-widget {
    background: none;
}

.ace_folding-enabled .ace_fold-widget {
    display: inline-block;   
}

.ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");
}

.ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");
}

.ace_fold-widget:hover {
    border: 1px solid rgba(0, 0, 0, 0.3);
    background-color: rgba(255, 255, 255, 0.2);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);
}

.ace_fold-widget:active {
    border: 1px solid rgba(0, 0, 0, 0.4);
    background-color: rgba(0, 0, 0, 0.05);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
}
/**
 * Dark version for fold widgets
 */
.ace_dark .ace_fold-widget {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");
}
.ace_dark .ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget:hover {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
    background-color: rgba(255, 255, 255, 0.1);
}
.ace_dark .ace_fold-widget:active {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
}

.ace_inline_button {
    border: 1px solid lightgray;
    display: inline-block;
    margin: -1px 8px;
    padding: 0 5px;
    pointer-events: auto;
    cursor: pointer;
}
.ace_inline_button:hover {
    border-color: gray;
    background: rgba(200,200,200,0.2);
    display: inline-block;
    pointer-events: auto;
}

.ace_fold-widget.ace_invalid {
    background-color: #FFB4B4;
    border-color: #DE5555;
}

.ace_fade-fold-widgets .ace_fold-widget {
    transition: opacity 0.4s ease 0.05s;
    opacity: 0;
}

.ace_fade-fold-widgets:hover .ace_fold-widget {
    transition: opacity 0.05s ease 0.05s;
    opacity:1;
}

.ace_underline {
    text-decoration: underline;
}

.ace_bold {
    font-weight: bold;
}

.ace_nobold .ace_bold {
    font-weight: normal;
}

.ace_italic {
    font-style: italic;
}


.ace_error-marker {
    background-color: rgba(255, 0, 0,0.2);
    position: absolute;
    z-index: 9;
}

.ace_highlight-marker {
    background-color: rgba(255, 255, 0,0.2);
    position: absolute;
    z-index: 8;
}

.ace_mobile-menu {
    position: absolute;
    line-height: 1.5;
    border-radius: 4px;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    background: white;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #dcdcdc;
    color: black;
}
.ace_dark > .ace_mobile-menu {
    background: #333;
    color: #ccc;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #444;

}
.ace_mobile-button {
    padding: 2px;
    cursor: pointer;
    overflow: hidden;
}
.ace_mobile-button:hover {
    background-color: #eee;
    opacity:1;
}
.ace_mobile-button:active {
    background-color: #ddd;
}

.ace_placeholder {
    position: relative;
    font-family: arial;
    transform: scale(0.9);
    transform-origin: left;
    white-space: pre;
    opacity: 0.7;
    margin: 0 10px;
    z-index: 1;
}

.ace_ghost_text {
    opacity: 0.5;
    font-style: italic;
}

.ace_ghost_text_container > div {
    white-space: pre;
}

.ghost_text_line_wrapped::after {
    content: "↩";
    position: absolute;
}

.ace_lineWidgetContainer.ace_ghost_text {
    margin: 0px 4px
}

.ace_screenreader-only {
    position:absolute;
    left:-10000px;
    top:auto;
    width:1px;
    height:1px;
    overflow:hidden;
}

.ace_hidden_token {
    display: none;
}`;
  });
  ace.define("ace/layer/decorators", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports2, module2) {
    var dom = require2("../lib/dom");
    var oop = require2("../lib/oop");
    var EventEmitter = require2("../lib/event_emitter").EventEmitter;
    var Decorator = (
      /** @class */
      function() {
        function Decorator2(scrollbarV, renderer) {
          this.renderer = renderer;
          this.pixelRatio = 1;
          this.maxHeight = renderer.layerConfig.maxHeight;
          this.lineHeight = renderer.layerConfig.lineHeight;
          this.minDecorationHeight = 2 * this.pixelRatio | 0;
          this.halfMinDecorationHeight = this.minDecorationHeight / 2 | 0;
          this.colors = {};
          this.colors.dark = {
            "error": "rgba(255, 18, 18, 1)",
            "warning": "rgba(18, 136, 18, 1)",
            "info": "rgba(18, 18, 136, 1)"
          };
          this.colors.light = {
            "error": "rgb(255,51,51)",
            "warning": "rgb(32,133,72)",
            "info": "rgb(35,68,138)"
          };
          this.setScrollBarV(scrollbarV);
        }
        Decorator2.prototype.$createCanvas = function() {
          this.canvas = dom.createElement("canvas");
          this.canvas.style.top = "0px";
          this.canvas.style.right = "0px";
          this.canvas.style.zIndex = "7";
          this.canvas.style.position = "absolute";
        };
        Decorator2.prototype.setScrollBarV = function(scrollbarV) {
          this.$createCanvas();
          this.scrollbarV = scrollbarV;
          scrollbarV.element.appendChild(this.canvas);
          this.setDimensions();
        };
        Decorator2.prototype.$updateDecorators = function(config) {
          if (typeof this.canvas.getContext !== "function") {
            return;
          }
          var colors = this.renderer.theme.isDark === true ? this.colors.dark : this.colors.light;
          this.setDimensions(config);
          var ctx = this.canvas.getContext("2d");
          function compare(a, b) {
            if (a.priority < b.priority)
              return -1;
            if (a.priority > b.priority)
              return 1;
            return 0;
          }
          var annotations = this.renderer.session.$annotations;
          ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          if (annotations) {
            var priorities = {
              "info": 1,
              "warning": 2,
              "error": 3
            };
            annotations.forEach(function(item2) {
              item2["priority"] = priorities[item2.type] || null;
            });
            annotations = annotations.sort(compare);
            for (var i = 0; i < annotations.length; i++) {
              var row = annotations[i].row;
              var offset1 = this.getVerticalOffsetForRow(row);
              var offset2 = offset1 + this.lineHeight;
              var y1 = Math.round(this.heightRatio * offset1);
              var y2 = Math.round(this.heightRatio * offset2);
              var ycenter = Math.round((y1 + y2) / 2);
              var halfHeight = y2 - ycenter;
              if (halfHeight < this.halfMinDecorationHeight) {
                halfHeight = this.halfMinDecorationHeight;
              }
              if (ycenter - halfHeight < 0) {
                ycenter = halfHeight;
              }
              if (ycenter + halfHeight > this.canvasHeight) {
                ycenter = this.canvasHeight - halfHeight;
              }
              var from = ycenter - halfHeight;
              var to = ycenter + halfHeight;
              var zoneHeight = to - from;
              ctx.fillStyle = colors[annotations[i].type] || null;
              ctx.fillRect(0, from, Math.round(this.oneZoneWidth - 1), zoneHeight);
            }
          }
          var cursor = this.renderer.session.selection.getCursor();
          if (cursor) {
            var currentY = Math.round(this.getVerticalOffsetForRow(cursor.row) * this.heightRatio);
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(0, currentY, this.canvasWidth, 2);
          }
        };
        Decorator2.prototype.getVerticalOffsetForRow = function(row) {
          row = row | 0;
          var offset = this.renderer.session.documentToScreenRow(row, 0) * this.lineHeight;
          return offset;
        };
        Decorator2.prototype.setDimensions = function(config) {
          config = config || this.renderer.layerConfig;
          this.maxHeight = config.maxHeight;
          this.lineHeight = config.lineHeight;
          this.canvasHeight = config.height;
          this.canvasWidth = this.scrollbarV.width || this.canvasWidth;
          this.setZoneWidth();
          this.canvas.width = this.canvasWidth;
          this.canvas.height = this.canvasHeight;
          if (this.maxHeight < this.canvasHeight) {
            this.heightRatio = 1;
          } else {
            this.heightRatio = this.canvasHeight / this.maxHeight;
          }
        };
        Decorator2.prototype.setZoneWidth = function() {
          this.oneZoneWidth = this.canvasWidth;
        };
        Decorator2.prototype.destroy = function() {
          this.canvas.parentNode.removeChild(this.canvas);
        };
        return Decorator2;
      }()
    );
    oop.implement(Decorator.prototype, EventEmitter);
    exports2.Decorator = Decorator;
  });
  ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/config", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/scrollbar_custom", "ace/scrollbar_custom", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter", "ace/css/editor-css", "ace/layer/decorators", "ace/lib/useragent", "ace/layer/text_util"], function(require2, exports2, module2) {
    var oop = require2("./lib/oop");
    var dom = require2("./lib/dom");
    var lang = require2("./lib/lang");
    var config = require2("./config");
    var GutterLayer = require2("./layer/gutter").Gutter;
    var MarkerLayer = require2("./layer/marker").Marker;
    var TextLayer = require2("./layer/text").Text;
    var CursorLayer = require2("./layer/cursor").Cursor;
    var HScrollBar = require2("./scrollbar").HScrollBar;
    var VScrollBar = require2("./scrollbar").VScrollBar;
    var HScrollBarCustom = require2("./scrollbar_custom").HScrollBar;
    var VScrollBarCustom = require2("./scrollbar_custom").VScrollBar;
    var RenderLoop = require2("./renderloop").RenderLoop;
    var FontMetrics = require2("./layer/font_metrics").FontMetrics;
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var editorCss = require2("./css/editor-css");
    var Decorator = require2("./layer/decorators").Decorator;
    var useragent = require2("./lib/useragent");
    var isTextToken = require2("./layer/text_util").isTextToken;
    dom.importCssString(editorCss, "ace_editor.css", false);
    var VirtualRenderer = (
      /** @class */
      function() {
        function VirtualRenderer2(container2, theme) {
          var _self = this;
          this.container = container2 || dom.createElement("div");
          dom.addCssClass(this.container, "ace_editor");
          if (dom.HI_DPI)
            dom.addCssClass(this.container, "ace_hidpi");
          this.setTheme(theme);
          if (config.get("useStrictCSP") == null)
            config.set("useStrictCSP", false);
          this.$gutter = dom.createElement("div");
          this.$gutter.className = "ace_gutter";
          this.container.appendChild(this.$gutter);
          this.$gutter.setAttribute("aria-hidden", "true");
          this.scroller = dom.createElement("div");
          this.scroller.className = "ace_scroller";
          this.container.appendChild(this.scroller);
          this.content = dom.createElement("div");
          this.content.className = "ace_content";
          this.scroller.appendChild(this.content);
          this.$gutterLayer = new GutterLayer(this.$gutter);
          this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
          this.$markerBack = new MarkerLayer(this.content);
          var textLayer = this.$textLayer = new TextLayer(this.content);
          this.canvas = textLayer.element;
          this.$markerFront = new MarkerLayer(this.content);
          this.$cursorLayer = new CursorLayer(this.content);
          this.$horizScroll = false;
          this.$vScroll = false;
          this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
          this.scrollBarH = new HScrollBar(this.container, this);
          this.scrollBarV.on("scroll", function(e) {
            if (!_self.$scrollAnimation)
              _self.session.setScrollTop(e.data - _self.scrollMargin.top);
          });
          this.scrollBarH.on("scroll", function(e) {
            if (!_self.$scrollAnimation)
              _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
          });
          this.scrollTop = 0;
          this.scrollLeft = 0;
          this.cursorPos = {
            row: 0,
            column: 0
          };
          this.$fontMetrics = new FontMetrics(this.container);
          this.$textLayer.$setFontMetrics(this.$fontMetrics);
          this.$textLayer.on("changeCharacterSize", function(e) {
            _self.updateCharacterSize();
            _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
            _self._signal("changeCharacterSize", e);
          });
          this.$size = {
            width: 0,
            height: 0,
            scrollerHeight: 0,
            scrollerWidth: 0,
            $dirty: true
          };
          this.layerConfig = {
            width: 1,
            padding: 0,
            firstRow: 0,
            firstRowScreen: 0,
            lastRow: 0,
            lineHeight: 0,
            characterWidth: 0,
            minHeight: 1,
            maxHeight: 1,
            offset: 0,
            height: 1,
            gutterOffset: 1
          };
          this.scrollMargin = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            v: 0,
            h: 0
          };
          this.margin = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            v: 0,
            h: 0
          };
          this.$keepTextAreaAtCursor = !useragent.isIOS;
          this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
          this.$loop.schedule(this.CHANGE_FULL);
          this.updateCharacterSize();
          this.setPadding(4);
          this.$addResizeObserver();
          config.resetOptions(this);
          config._signal("renderer", this);
        }
        VirtualRenderer2.prototype.updateCharacterSize = function() {
          if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
            this.setStyle("ace_nobold", !this.$allowBoldFonts);
          }
          this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
          this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
          this.$updatePrintMargin();
          dom.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
        };
        VirtualRenderer2.prototype.setSession = function(session) {
          if (this.session)
            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
          this.session = session;
          if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
            session.setScrollTop(-this.scrollMargin.top);
          this.$cursorLayer.setSession(session);
          this.$markerBack.setSession(session);
          this.$markerFront.setSession(session);
          this.$gutterLayer.setSession(session);
          this.$textLayer.setSession(session);
          if (!session)
            return;
          this.$loop.schedule(this.CHANGE_FULL);
          this.session.$setFontMetrics(this.$fontMetrics);
          this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
          this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
          this.onChangeNewLineMode();
          this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
        };
        VirtualRenderer2.prototype.updateLines = function(firstRow, lastRow, force) {
          if (lastRow === void 0)
            lastRow = Infinity;
          if (!this.$changedLines) {
            this.$changedLines = {
              firstRow,
              lastRow
            };
          } else {
            if (this.$changedLines.firstRow > firstRow)
              this.$changedLines.firstRow = firstRow;
            if (this.$changedLines.lastRow < lastRow)
              this.$changedLines.lastRow = lastRow;
          }
          if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
            if (force)
              this.$changedLines.lastRow = this.layerConfig.lastRow;
            else
              return;
          }
          if (this.$changedLines.firstRow > this.layerConfig.lastRow)
            return;
          this.$loop.schedule(this.CHANGE_LINES);
        };
        VirtualRenderer2.prototype.onChangeNewLineMode = function() {
          this.$loop.schedule(this.CHANGE_TEXT);
          this.$textLayer.$updateEolChar();
          this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
        };
        VirtualRenderer2.prototype.onChangeTabSize = function() {
          this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
          this.$textLayer.onChangeTabSize();
        };
        VirtualRenderer2.prototype.updateText = function() {
          this.$loop.schedule(this.CHANGE_TEXT);
        };
        VirtualRenderer2.prototype.updateFull = function(force) {
          if (force)
            this.$renderChanges(this.CHANGE_FULL, true);
          else
            this.$loop.schedule(this.CHANGE_FULL);
        };
        VirtualRenderer2.prototype.updateFontSize = function() {
          this.$textLayer.checkForSizeChanges();
        };
        VirtualRenderer2.prototype.$updateSizeAsync = function() {
          if (this.$loop.pending)
            this.$size.$dirty = true;
          else
            this.onResize();
        };
        VirtualRenderer2.prototype.onResize = function(force, gutterWidth, width, height) {
          if (this.resizing > 2)
            return;
          else if (this.resizing > 0)
            this.resizing++;
          else
            this.resizing = force ? 1 : 0;
          var el = this.container;
          if (!height)
            height = el.clientHeight || el.scrollHeight;
          if (!height && this.$maxLines && this.lineHeight > 1) {
            if (!el.style.height || el.style.height == "0px") {
              el.style.height = "1px";
              height = el.clientHeight || el.scrollHeight;
            }
          }
          if (!width)
            width = el.clientWidth || el.scrollWidth;
          var changes = this.$updateCachedSize(force, gutterWidth, width, height);
          if (this.$resizeTimer)
            this.$resizeTimer.cancel();
          if (!this.$size.scrollerHeight || !width && !height)
            return this.resizing = 0;
          if (force)
            this.$gutterLayer.$padding = null;
          if (force)
            this.$renderChanges(changes | this.$changes, true);
          else
            this.$loop.schedule(changes | this.$changes);
          if (this.resizing)
            this.resizing = 0;
          this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
          if (this.$customScrollbar) {
            this.$updateCustomScrollbar(true);
          }
        };
        VirtualRenderer2.prototype.$updateCachedSize = function(force, gutterWidth, width, height) {
          height -= this.$extraHeight || 0;
          var changes = 0;
          var size = this.$size;
          var oldSize = {
            width: size.width,
            height: size.height,
            scrollerHeight: size.scrollerHeight,
            scrollerWidth: size.scrollerWidth
          };
          if (height && (force || size.height != height)) {
            size.height = height;
            changes |= this.CHANGE_SIZE;
            size.scrollerHeight = size.height;
            if (this.$horizScroll)
              size.scrollerHeight -= this.scrollBarH.getHeight();
            this.scrollBarV.setHeight(size.scrollerHeight);
            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
            changes = changes | this.CHANGE_SCROLL;
          }
          if (width && (force || size.width != width)) {
            changes |= this.CHANGE_SIZE;
            size.width = width;
            if (gutterWidth == null)
              gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
            this.gutterWidth = gutterWidth;
            dom.setStyle(this.scrollBarH.element.style, "left", gutterWidth + "px");
            dom.setStyle(this.scroller.style, "left", gutterWidth + this.margin.left + "px");
            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
            dom.setStyle(this.$gutter.style, "left", this.margin.left + "px");
            var right = this.scrollBarV.getWidth() + "px";
            dom.setStyle(this.scrollBarH.element.style, "right", right);
            dom.setStyle(this.scroller.style, "right", right);
            dom.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());
            this.scrollBarH.setWidth(size.scrollerWidth);
            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {
              changes |= this.CHANGE_FULL;
            }
          }
          size.$dirty = !width || !height;
          if (changes)
            this._signal("resize", oldSize);
          return changes;
        };
        VirtualRenderer2.prototype.onGutterResize = function(width) {
          var gutterWidth = this.$showGutter ? width : 0;
          if (gutterWidth != this.gutterWidth)
            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
          if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
            this.$loop.schedule(this.CHANGE_FULL);
          } else if (this.$size.$dirty) {
            this.$loop.schedule(this.CHANGE_FULL);
          } else {
            this.$computeLayerConfig();
          }
        };
        VirtualRenderer2.prototype.adjustWrapLimit = function() {
          var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
          var limit = Math.floor(availableWidth / this.characterWidth);
          return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
        };
        VirtualRenderer2.prototype.setAnimatedScroll = function(shouldAnimate) {
          this.setOption("animatedScroll", shouldAnimate);
        };
        VirtualRenderer2.prototype.getAnimatedScroll = function() {
          return this.$animatedScroll;
        };
        VirtualRenderer2.prototype.setShowInvisibles = function(showInvisibles) {
          this.setOption("showInvisibles", showInvisibles);
          this.session.$bidiHandler.setShowInvisibles(showInvisibles);
        };
        VirtualRenderer2.prototype.getShowInvisibles = function() {
          return this.getOption("showInvisibles");
        };
        VirtualRenderer2.prototype.getDisplayIndentGuides = function() {
          return this.getOption("displayIndentGuides");
        };
        VirtualRenderer2.prototype.setDisplayIndentGuides = function(display) {
          this.setOption("displayIndentGuides", display);
        };
        VirtualRenderer2.prototype.getHighlightIndentGuides = function() {
          return this.getOption("highlightIndentGuides");
        };
        VirtualRenderer2.prototype.setHighlightIndentGuides = function(highlight) {
          this.setOption("highlightIndentGuides", highlight);
        };
        VirtualRenderer2.prototype.setShowPrintMargin = function(showPrintMargin) {
          this.setOption("showPrintMargin", showPrintMargin);
        };
        VirtualRenderer2.prototype.getShowPrintMargin = function() {
          return this.getOption("showPrintMargin");
        };
        VirtualRenderer2.prototype.setPrintMarginColumn = function(printMarginColumn) {
          this.setOption("printMarginColumn", printMarginColumn);
        };
        VirtualRenderer2.prototype.getPrintMarginColumn = function() {
          return this.getOption("printMarginColumn");
        };
        VirtualRenderer2.prototype.getShowGutter = function() {
          return this.getOption("showGutter");
        };
        VirtualRenderer2.prototype.setShowGutter = function(show) {
          return this.setOption("showGutter", show);
        };
        VirtualRenderer2.prototype.getFadeFoldWidgets = function() {
          return this.getOption("fadeFoldWidgets");
        };
        VirtualRenderer2.prototype.setFadeFoldWidgets = function(show) {
          this.setOption("fadeFoldWidgets", show);
        };
        VirtualRenderer2.prototype.setHighlightGutterLine = function(shouldHighlight) {
          this.setOption("highlightGutterLine", shouldHighlight);
        };
        VirtualRenderer2.prototype.getHighlightGutterLine = function() {
          return this.getOption("highlightGutterLine");
        };
        VirtualRenderer2.prototype.$updatePrintMargin = function() {
          if (!this.$showPrintMargin && !this.$printMarginEl)
            return;
          if (!this.$printMarginEl) {
            var containerEl = dom.createElement("div");
            containerEl.className = "ace_layer ace_print-margin-layer";
            this.$printMarginEl = dom.createElement("div");
            this.$printMarginEl.className = "ace_print-margin";
            containerEl.appendChild(this.$printMarginEl);
            this.content.insertBefore(containerEl, this.content.firstChild);
          }
          var style2 = this.$printMarginEl.style;
          style2.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px";
          style2.visibility = this.$showPrintMargin ? "visible" : "hidden";
          if (this.session && this.session.$wrap == -1)
            this.adjustWrapLimit();
        };
        VirtualRenderer2.prototype.getContainerElement = function() {
          return this.container;
        };
        VirtualRenderer2.prototype.getMouseEventTarget = function() {
          return this.scroller;
        };
        VirtualRenderer2.prototype.getTextAreaContainer = function() {
          return this.container;
        };
        VirtualRenderer2.prototype.$moveTextAreaToCursor = function() {
          if (this.$isMousePressed)
            return;
          var style2 = this.textarea.style;
          var composition = this.$composition;
          if (!this.$keepTextAreaAtCursor && !composition) {
            dom.translate(this.textarea, -100, 0);
            return;
          }
          var pixelPos = this.$cursorLayer.$pixelPos;
          if (!pixelPos)
            return;
          if (composition && composition.markerRange)
            pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);
          var config2 = this.layerConfig;
          var posTop = pixelPos.top;
          var posLeft = pixelPos.left;
          posTop -= config2.offset;
          var h = composition && composition.useTextareaForIME || useragent.isMobile ? this.lineHeight : 1;
          if (posTop < 0 || posTop > config2.height - h) {
            dom.translate(this.textarea, 0, 0);
            return;
          }
          var w = 1;
          var maxTop = this.$size.height - h;
          if (!composition) {
            posTop += this.lineHeight;
          } else {
            if (composition.useTextareaForIME) {
              var val = this.textarea.value;
              w = this.characterWidth * this.session.$getStringScreenWidth(val)[0];
            } else {
              posTop += this.lineHeight + 2;
            }
          }
          posLeft -= this.scrollLeft;
          if (posLeft > this.$size.scrollerWidth - w)
            posLeft = this.$size.scrollerWidth - w;
          posLeft += this.gutterWidth + this.margin.left;
          dom.setStyle(style2, "height", h + "px");
          dom.setStyle(style2, "width", w + "px");
          dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, maxTop));
        };
        VirtualRenderer2.prototype.getFirstVisibleRow = function() {
          return this.layerConfig.firstRow;
        };
        VirtualRenderer2.prototype.getFirstFullyVisibleRow = function() {
          return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
        };
        VirtualRenderer2.prototype.getLastFullyVisibleRow = function() {
          var config2 = this.layerConfig;
          var lastRow = config2.lastRow;
          var top = this.session.documentToScreenRow(lastRow, 0) * config2.lineHeight;
          if (top - this.session.getScrollTop() > config2.height - config2.lineHeight)
            return lastRow - 1;
          return lastRow;
        };
        VirtualRenderer2.prototype.getLastVisibleRow = function() {
          return this.layerConfig.lastRow;
        };
        VirtualRenderer2.prototype.setPadding = function(padding) {
          this.$padding = padding;
          this.$textLayer.setPadding(padding);
          this.$cursorLayer.setPadding(padding);
          this.$markerFront.setPadding(padding);
          this.$markerBack.setPadding(padding);
          this.$loop.schedule(this.CHANGE_FULL);
          this.$updatePrintMargin();
        };
        VirtualRenderer2.prototype.setScrollMargin = function(top, bottom, left, right) {
          var sm = this.scrollMargin;
          sm.top = top | 0;
          sm.bottom = bottom | 0;
          sm.right = right | 0;
          sm.left = left | 0;
          sm.v = sm.top + sm.bottom;
          sm.h = sm.left + sm.right;
          if (sm.top && this.scrollTop <= 0 && this.session)
            this.session.setScrollTop(-sm.top);
          this.updateFull();
        };
        VirtualRenderer2.prototype.setMargin = function(top, bottom, left, right) {
          var sm = this.margin;
          sm.top = top | 0;
          sm.bottom = bottom | 0;
          sm.right = right | 0;
          sm.left = left | 0;
          sm.v = sm.top + sm.bottom;
          sm.h = sm.left + sm.right;
          this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
          this.updateFull();
        };
        VirtualRenderer2.prototype.getHScrollBarAlwaysVisible = function() {
          return this.$hScrollBarAlwaysVisible;
        };
        VirtualRenderer2.prototype.setHScrollBarAlwaysVisible = function(alwaysVisible) {
          this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
        };
        VirtualRenderer2.prototype.getVScrollBarAlwaysVisible = function() {
          return this.$vScrollBarAlwaysVisible;
        };
        VirtualRenderer2.prototype.setVScrollBarAlwaysVisible = function(alwaysVisible) {
          this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
        };
        VirtualRenderer2.prototype.$updateScrollBarV = function() {
          var scrollHeight = this.layerConfig.maxHeight;
          var scrollerHeight = this.$size.scrollerHeight;
          if (!this.$maxLines && this.$scrollPastEnd) {
            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
            if (this.scrollTop > scrollHeight - scrollerHeight) {
              scrollHeight = this.scrollTop + scrollerHeight;
              this.scrollBarV.scrollTop = null;
            }
          }
          this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
          this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
        };
        VirtualRenderer2.prototype.$updateScrollBarH = function() {
          this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
          this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
        };
        VirtualRenderer2.prototype.freeze = function() {
          this.$frozen = true;
        };
        VirtualRenderer2.prototype.unfreeze = function() {
          this.$frozen = false;
        };
        VirtualRenderer2.prototype.$renderChanges = function(changes, force) {
          if (this.$changes) {
            changes |= this.$changes;
            this.$changes = 0;
          }
          if (!this.session || !this.container.offsetWidth || this.$frozen || !changes && !force) {
            this.$changes |= changes;
            return;
          }
          if (this.$size.$dirty) {
            this.$changes |= changes;
            return this.onResize(true);
          }
          if (!this.lineHeight) {
            this.$textLayer.checkForSizeChanges();
          }
          this._signal("beforeRender", changes);
          if (this.session && this.session.$bidiHandler)
            this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
          var config2 = this.layerConfig;
          if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
            changes |= this.$computeLayerConfig() | this.$loop.clear();
            if (config2.firstRow != this.layerConfig.firstRow && config2.firstRowScreen == this.layerConfig.firstRowScreen) {
              var st = this.scrollTop + (config2.firstRow - Math.max(this.layerConfig.firstRow, 0)) * this.lineHeight;
              if (st > 0) {
                this.scrollTop = st;
                changes = changes | this.CHANGE_SCROLL;
                changes |= this.$computeLayerConfig() | this.$loop.clear();
              }
            }
            config2 = this.layerConfig;
            this.$updateScrollBarV();
            if (changes & this.CHANGE_H_SCROLL)
              this.$updateScrollBarH();
            dom.translate(this.content, -this.scrollLeft, -config2.offset);
            var width = config2.width + 2 * this.$padding + "px";
            var height = config2.minHeight + "px";
            dom.setStyle(this.content.style, "width", width);
            dom.setStyle(this.content.style, "height", height);
          }
          if (changes & this.CHANGE_H_SCROLL) {
            dom.translate(this.content, -this.scrollLeft, -config2.offset);
            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller " : "ace_scroller ace_scroll-left ";
            if (this.enableKeyboardAccessibility)
              this.scroller.className += this.keyboardFocusClassName;
          }
          if (changes & this.CHANGE_FULL) {
            this.$changedLines = null;
            this.$textLayer.update(config2);
            if (this.$showGutter)
              this.$gutterLayer.update(config2);
            if (this.$customScrollbar) {
              this.$scrollDecorator.$updateDecorators(config2);
            }
            this.$markerBack.update(config2);
            this.$markerFront.update(config2);
            this.$cursorLayer.update(config2);
            this.$moveTextAreaToCursor();
            this._signal("afterRender", changes);
            return;
          }
          if (changes & this.CHANGE_SCROLL) {
            this.$changedLines = null;
            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
              this.$textLayer.update(config2);
            else
              this.$textLayer.scrollLines(config2);
            if (this.$showGutter) {
              if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)
                this.$gutterLayer.update(config2);
              else
                this.$gutterLayer.scrollLines(config2);
            }
            if (this.$customScrollbar) {
              this.$scrollDecorator.$updateDecorators(config2);
            }
            this.$markerBack.update(config2);
            this.$markerFront.update(config2);
            this.$cursorLayer.update(config2);
            this.$moveTextAreaToCursor();
            this._signal("afterRender", changes);
            return;
          }
          if (changes & this.CHANGE_TEXT) {
            this.$changedLines = null;
            this.$textLayer.update(config2);
            if (this.$showGutter)
              this.$gutterLayer.update(config2);
            if (this.$customScrollbar) {
              this.$scrollDecorator.$updateDecorators(config2);
            }
          } else if (changes & this.CHANGE_LINES) {
            if (this.$updateLines() || changes & this.CHANGE_GUTTER && this.$showGutter)
              this.$gutterLayer.update(config2);
            if (this.$customScrollbar) {
              this.$scrollDecorator.$updateDecorators(config2);
            }
          } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
            if (this.$showGutter)
              this.$gutterLayer.update(config2);
            if (this.$customScrollbar) {
              this.$scrollDecorator.$updateDecorators(config2);
            }
          } else if (changes & this.CHANGE_CURSOR) {
            if (this.$highlightGutterLine)
              this.$gutterLayer.updateLineHighlight(config2);
            if (this.$customScrollbar) {
              this.$scrollDecorator.$updateDecorators(config2);
            }
          }
          if (changes & this.CHANGE_CURSOR) {
            this.$cursorLayer.update(config2);
            this.$moveTextAreaToCursor();
          }
          if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
            this.$markerFront.update(config2);
          }
          if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
            this.$markerBack.update(config2);
          }
          this._signal("afterRender", changes);
        };
        VirtualRenderer2.prototype.$autosize = function() {
          var height = this.session.getScreenLength() * this.lineHeight;
          var maxHeight = this.$maxLines * this.lineHeight;
          var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
          if (this.$horizScroll)
            desiredHeight += this.scrollBarH.getHeight();
          if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
            desiredHeight = this.$maxPixelHeight;
          var hideScrollbars = desiredHeight <= 2 * this.lineHeight;
          var vScroll = !hideScrollbars && height > maxHeight;
          if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
            if (vScroll != this.$vScroll) {
              this.$vScroll = vScroll;
              this.scrollBarV.setVisible(vScroll);
            }
            var w = this.container.clientWidth;
            this.container.style.height = desiredHeight + "px";
            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
            this.desiredHeight = desiredHeight;
            this._signal("autosize");
          }
        };
        VirtualRenderer2.prototype.$computeLayerConfig = function() {
          var session = this.session;
          var size = this.$size;
          var hideScrollbars = size.height <= 2 * this.lineHeight;
          var screenLines = this.session.getScreenLength();
          var maxHeight = screenLines * this.lineHeight;
          var longestLine = this.$getLongestLine();
          var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);
          var hScrollChanged = this.$horizScroll !== horizScroll;
          if (hScrollChanged) {
            this.$horizScroll = horizScroll;
            this.scrollBarH.setVisible(horizScroll);
          }
          var vScrollBefore = this.$vScroll;
          if (this.$maxLines && this.lineHeight > 1) {
            this.$autosize();
            hideScrollbars = size.height <= 2 * this.lineHeight;
          }
          var minHeight = size.scrollerHeight + this.lineHeight;
          var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
          maxHeight += scrollPastEnd;
          var sm = this.scrollMargin;
          this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));
          this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
          var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
          var vScrollChanged = vScrollBefore !== vScroll;
          if (vScrollChanged) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
          }
          var offset = this.scrollTop % this.lineHeight;
          var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
          var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
          var lastRow = firstRow + lineCount;
          var firstRowScreen, firstRowHeight;
          var lineHeight = this.lineHeight;
          firstRow = session.screenToDocumentRow(firstRow, 0);
          var foldLine = session.getFoldLine(firstRow);
          if (foldLine) {
            firstRow = foldLine.start.row;
          }
          firstRowScreen = session.documentToScreenRow(firstRow, 0);
          firstRowHeight = session.getRowLength(firstRow) * lineHeight;
          lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
          minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;
          offset = this.scrollTop - firstRowScreen * lineHeight;
          if (offset < 0 && firstRowScreen > 0) {
            firstRowScreen = Math.max(0, firstRowScreen + Math.floor(offset / lineHeight));
            offset = this.scrollTop - firstRowScreen * lineHeight;
          }
          var changes = 0;
          if (this.layerConfig.width != longestLine || hScrollChanged)
            changes = this.CHANGE_H_SCROLL;
          if (hScrollChanged || vScrollChanged) {
            changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
            this._signal("scrollbarVisibilityChanged");
            if (vScrollChanged)
              longestLine = this.$getLongestLine();
          }
          this.layerConfig = {
            width: longestLine,
            padding: this.$padding,
            firstRow,
            firstRowScreen,
            lastRow,
            lineHeight,
            characterWidth: this.characterWidth,
            minHeight,
            maxHeight,
            offset,
            gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
            height: this.$size.scrollerHeight
          };
          if (this.session.$bidiHandler)
            this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);
          return changes;
        };
        VirtualRenderer2.prototype.$updateLines = function() {
          if (!this.$changedLines)
            return;
          var firstRow = this.$changedLines.firstRow;
          var lastRow = this.$changedLines.lastRow;
          this.$changedLines = null;
          var layerConfig = this.layerConfig;
          if (firstRow > layerConfig.lastRow + 1) {
            return;
          }
          if (lastRow < layerConfig.firstRow) {
            return;
          }
          if (lastRow === Infinity) {
            if (this.$showGutter)
              this.$gutterLayer.update(layerConfig);
            this.$textLayer.update(layerConfig);
            return;
          }
          this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
          return true;
        };
        VirtualRenderer2.prototype.$getLongestLine = function() {
          var charCount = this.session.getScreenWidth();
          if (this.showInvisibles && !this.session.$useWrapMode)
            charCount += 1;
          if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)
            charCount = this.$textLayer.MAX_LINE_LENGTH + 30;
          return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
        };
        VirtualRenderer2.prototype.updateFrontMarkers = function() {
          this.$markerFront.setMarkers(this.session.getMarkers(true));
          this.$loop.schedule(this.CHANGE_MARKER_FRONT);
        };
        VirtualRenderer2.prototype.updateBackMarkers = function() {
          this.$markerBack.setMarkers(this.session.getMarkers());
          this.$loop.schedule(this.CHANGE_MARKER_BACK);
        };
        VirtualRenderer2.prototype.addGutterDecoration = function(row, className) {
          this.$gutterLayer.addGutterDecoration(row, className);
        };
        VirtualRenderer2.prototype.removeGutterDecoration = function(row, className) {
          this.$gutterLayer.removeGutterDecoration(row, className);
        };
        VirtualRenderer2.prototype.updateBreakpoints = function(rows) {
          this._rows = rows;
          this.$loop.schedule(this.CHANGE_GUTTER);
        };
        VirtualRenderer2.prototype.setAnnotations = function(annotations) {
          this.$gutterLayer.setAnnotations(annotations);
          this.$loop.schedule(this.CHANGE_GUTTER);
        };
        VirtualRenderer2.prototype.updateCursor = function() {
          this.$loop.schedule(this.CHANGE_CURSOR);
        };
        VirtualRenderer2.prototype.hideCursor = function() {
          this.$cursorLayer.hideCursor();
        };
        VirtualRenderer2.prototype.showCursor = function() {
          this.$cursorLayer.showCursor();
        };
        VirtualRenderer2.prototype.scrollSelectionIntoView = function(anchor, lead, offset) {
          this.scrollCursorIntoView(anchor, offset);
          this.scrollCursorIntoView(lead, offset);
        };
        VirtualRenderer2.prototype.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
          if (this.$size.scrollerHeight === 0)
            return;
          var pos = this.$cursorLayer.getPixelPosition(cursor);
          var newLeft = pos.left;
          var newTop = pos.top;
          var topMargin = $viewMargin && $viewMargin.top || 0;
          var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
          if (this.$scrollAnimation) {
            this.$stopAnimation = true;
          }
          var currentTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
          if (currentTop + topMargin > newTop) {
            if (offset && currentTop + topMargin > newTop + this.lineHeight)
              newTop -= offset * this.$size.scrollerHeight;
            if (newTop === 0)
              newTop = -this.scrollMargin.top;
            this.session.setScrollTop(newTop);
          } else if (currentTop + this.$size.scrollerHeight - bottomMargin < newTop + this.lineHeight) {
            if (offset && currentTop + this.$size.scrollerHeight - bottomMargin < newTop - this.lineHeight)
              newTop += offset * this.$size.scrollerHeight;
            this.session.setScrollTop(newTop + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
          }
          var currentLeft = this.scrollLeft;
          var twoCharsWidth = 2 * this.layerConfig.characterWidth;
          if (newLeft - twoCharsWidth < currentLeft) {
            newLeft -= twoCharsWidth;
            if (newLeft < this.$padding + twoCharsWidth) {
              newLeft = -this.scrollMargin.left;
            }
            this.session.setScrollLeft(newLeft);
          } else {
            newLeft += twoCharsWidth;
            if (currentLeft + this.$size.scrollerWidth < newLeft + this.characterWidth) {
              this.session.setScrollLeft(Math.round(newLeft + this.characterWidth - this.$size.scrollerWidth));
            } else if (currentLeft <= this.$padding && newLeft - currentLeft < this.characterWidth) {
              this.session.setScrollLeft(0);
            }
          }
        };
        VirtualRenderer2.prototype.getScrollTop = function() {
          return this.session.getScrollTop();
        };
        VirtualRenderer2.prototype.getScrollLeft = function() {
          return this.session.getScrollLeft();
        };
        VirtualRenderer2.prototype.getScrollTopRow = function() {
          return this.scrollTop / this.lineHeight;
        };
        VirtualRenderer2.prototype.getScrollBottomRow = function() {
          return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
        };
        VirtualRenderer2.prototype.scrollToRow = function(row) {
          this.session.setScrollTop(row * this.lineHeight);
        };
        VirtualRenderer2.prototype.alignCursor = function(cursor, alignment) {
          if (typeof cursor == "number")
            cursor = { row: cursor, column: 0 };
          var pos = this.$cursorLayer.getPixelPosition(cursor);
          var h = this.$size.scrollerHeight - this.lineHeight;
          var offset = pos.top - h * (alignment || 0);
          this.session.setScrollTop(offset);
          return offset;
        };
        VirtualRenderer2.prototype.$calcSteps = function(fromValue, toValue) {
          var i = 0;
          var l = this.STEPS;
          var steps = [];
          var func = function(t, x_min, dx) {
            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
          };
          for (i = 0; i < l; ++i)
            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
          return steps;
        };
        VirtualRenderer2.prototype.scrollToLine = function(line, center, animate, callback) {
          var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });
          var offset = pos.top;
          if (center)
            offset -= this.$size.scrollerHeight / 2;
          var initialScroll = this.scrollTop;
          this.session.setScrollTop(offset);
          if (animate !== false)
            this.animateScrolling(initialScroll, callback);
        };
        VirtualRenderer2.prototype.animateScrolling = function(fromValue, callback) {
          var toValue = this.scrollTop;
          if (!this.$animatedScroll)
            return;
          var _self = this;
          if (fromValue == toValue)
            return;
          if (this.$scrollAnimation) {
            var oldSteps = this.$scrollAnimation.steps;
            if (oldSteps.length) {
              fromValue = oldSteps[0];
              if (fromValue == toValue)
                return;
            }
          }
          var steps = _self.$calcSteps(fromValue, toValue);
          this.$scrollAnimation = { from: fromValue, to: toValue, steps };
          clearInterval(this.$timer);
          _self.session.setScrollTop(steps.shift());
          _self.session.$scrollTop = toValue;
          function endAnimation() {
            _self.$timer = clearInterval(_self.$timer);
            _self.$scrollAnimation = null;
            _self.$stopAnimation = false;
            callback && callback();
          }
          this.$timer = setInterval(function() {
            if (_self.$stopAnimation) {
              endAnimation();
              return;
            }
            if (!_self.session)
              return clearInterval(_self.$timer);
            if (steps.length) {
              _self.session.setScrollTop(steps.shift());
              _self.session.$scrollTop = toValue;
            } else if (toValue != null) {
              _self.session.$scrollTop = -1;
              _self.session.setScrollTop(toValue);
              toValue = null;
            } else {
              endAnimation();
            }
          }, 10);
        };
        VirtualRenderer2.prototype.scrollToY = function(scrollTop) {
          if (this.scrollTop !== scrollTop) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollTop = scrollTop;
          }
        };
        VirtualRenderer2.prototype.scrollToX = function(scrollLeft) {
          if (this.scrollLeft !== scrollLeft)
            this.scrollLeft = scrollLeft;
          this.$loop.schedule(this.CHANGE_H_SCROLL);
        };
        VirtualRenderer2.prototype.scrollTo = function(x, y) {
          this.session.setScrollTop(y);
          this.session.setScrollLeft(x);
        };
        VirtualRenderer2.prototype.scrollBy = function(deltaX, deltaY) {
          deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
          deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
        };
        VirtualRenderer2.prototype.isScrollableBy = function(deltaX, deltaY) {
          if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
            return true;
          if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
            return true;
          if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
            return true;
          if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right)
            return true;
        };
        VirtualRenderer2.prototype.pixelToScreenCoordinates = function(x, y) {
          var canvasPos;
          if (this.$hasCssTransforms) {
            canvasPos = { top: 0, left: 0 };
            var p = this.$fontMetrics.transformCoordinates([x, y]);
            x = p[1] - this.gutterWidth - this.margin.left;
            y = p[0];
          } else {
            canvasPos = this.scroller.getBoundingClientRect();
          }
          var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
          var offset = offsetX / this.characterWidth;
          var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
          var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
          return { row, column: col, side: offset - col > 0 ? 1 : -1, offsetX };
        };
        VirtualRenderer2.prototype.screenToTextCoordinates = function(x, y) {
          var canvasPos;
          if (this.$hasCssTransforms) {
            canvasPos = { top: 0, left: 0 };
            var p = this.$fontMetrics.transformCoordinates([x, y]);
            x = p[1] - this.gutterWidth - this.margin.left;
            y = p[0];
          } else {
            canvasPos = this.scroller.getBoundingClientRect();
          }
          var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
          var offset = offsetX / this.characterWidth;
          var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
          var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
          return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
        };
        VirtualRenderer2.prototype.textToScreenCoordinates = function(row, column) {
          var canvasPos = this.scroller.getBoundingClientRect();
          var pos = this.session.documentToScreenPosition(row, column);
          var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row) ? this.session.$bidiHandler.getPosLeft(pos.column) : Math.round(pos.column * this.characterWidth));
          var y = pos.row * this.lineHeight;
          return {
            pageX: canvasPos.left + x - this.scrollLeft,
            pageY: canvasPos.top + y - this.scrollTop
          };
        };
        VirtualRenderer2.prototype.visualizeFocus = function() {
          dom.addCssClass(this.container, "ace_focus");
        };
        VirtualRenderer2.prototype.visualizeBlur = function() {
          dom.removeCssClass(this.container, "ace_focus");
        };
        VirtualRenderer2.prototype.showComposition = function(composition) {
          this.$composition = composition;
          if (!composition.cssText) {
            composition.cssText = this.textarea.style.cssText;
          }
          if (composition.useTextareaForIME == void 0)
            composition.useTextareaForIME = this.$useTextareaForIME;
          if (this.$useTextareaForIME) {
            dom.addCssClass(this.textarea, "ace_composition");
            this.textarea.style.cssText = "";
            this.$moveTextAreaToCursor();
            this.$cursorLayer.element.style.display = "none";
          } else {
            composition.markerId = this.session.addMarker(composition.markerRange, "ace_composition_marker", "text");
          }
        };
        VirtualRenderer2.prototype.setCompositionText = function(text) {
          var cursor = this.session.selection.cursor;
          this.addToken(text, "composition_placeholder", cursor.row, cursor.column);
          this.$moveTextAreaToCursor();
        };
        VirtualRenderer2.prototype.hideComposition = function() {
          if (!this.$composition)
            return;
          if (this.$composition.markerId)
            this.session.removeMarker(this.$composition.markerId);
          dom.removeCssClass(this.textarea, "ace_composition");
          this.textarea.style.cssText = this.$composition.cssText;
          var cursor = this.session.selection.cursor;
          this.removeExtraToken(cursor.row, cursor.column);
          this.$composition = null;
          this.$cursorLayer.element.style.display = "";
        };
        VirtualRenderer2.prototype.setGhostText = function(text, position) {
          var cursor = this.session.selection.cursor;
          var insertPosition = position || { row: cursor.row, column: cursor.column };
          this.removeGhostText();
          var textChunks = this.$calculateWrappedTextChunks(text, insertPosition);
          this.addToken(textChunks[0].text, "ghost_text", insertPosition.row, insertPosition.column);
          this.$ghostText = {
            text,
            position: {
              row: insertPosition.row,
              column: insertPosition.column
            }
          };
          var widgetDiv = dom.createElement("div");
          if (textChunks.length > 1) {
            var hiddenTokens = this.hideTokensAfterPosition(insertPosition.row, insertPosition.column);
            var lastLineDiv;
            textChunks.slice(1).forEach(function(el2) {
              var chunkDiv = dom.createElement("div");
              var chunkSpan = dom.createElement("span");
              chunkSpan.className = "ace_ghost_text";
              if (el2.wrapped)
                chunkDiv.className = "ghost_text_line_wrapped";
              if (el2.text.length === 0)
                el2.text = " ";
              chunkSpan.appendChild(dom.createTextNode(el2.text));
              chunkDiv.appendChild(chunkSpan);
              widgetDiv.appendChild(chunkDiv);
              lastLineDiv = chunkDiv;
            });
            hiddenTokens.forEach(function(token) {
              var element = dom.createElement("span");
              if (!isTextToken(token.type))
                element.className = "ace_" + token.type.replace(/\./g, " ace_");
              element.appendChild(dom.createTextNode(token.value));
              lastLineDiv.appendChild(element);
            });
            this.$ghostTextWidget = {
              el: widgetDiv,
              row: insertPosition.row,
              column: insertPosition.column,
              className: "ace_ghost_text_container"
            };
            this.session.widgetManager.addLineWidget(this.$ghostTextWidget);
            var pixelPosition = this.$cursorLayer.getPixelPosition(insertPosition, true);
            var el = this.container;
            var height = el.getBoundingClientRect().height;
            var ghostTextHeight = textChunks.length * this.lineHeight;
            var fitsY = ghostTextHeight < height - pixelPosition.top;
            if (fitsY)
              return;
            if (ghostTextHeight < height) {
              this.scrollBy(0, (textChunks.length - 1) * this.lineHeight);
            } else {
              this.scrollToRow(insertPosition.row);
            }
          }
        };
        VirtualRenderer2.prototype.$calculateWrappedTextChunks = function(text, position) {
          var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
          var limit = Math.floor(availableWidth / this.characterWidth) - 2;
          limit = limit <= 0 ? 60 : limit;
          var textLines = text.split(/\r?\n/);
          var textChunks = [];
          for (var i = 0; i < textLines.length; i++) {
            var displayTokens = this.session.$getDisplayTokens(textLines[i], position.column);
            var wrapSplits = this.session.$computeWrapSplits(displayTokens, limit, this.session.$tabSize);
            if (wrapSplits.length > 0) {
              var start = 0;
              wrapSplits.push(textLines[i].length);
              for (var j = 0; j < wrapSplits.length; j++) {
                var textSlice = textLines[i].slice(start, wrapSplits[j]);
                textChunks.push({ text: textSlice, wrapped: true });
                start = wrapSplits[j];
              }
            } else {
              textChunks.push({ text: textLines[i], wrapped: false });
            }
          }
          return textChunks;
        };
        VirtualRenderer2.prototype.removeGhostText = function() {
          if (!this.$ghostText)
            return;
          var position = this.$ghostText.position;
          this.removeExtraToken(position.row, position.column);
          if (this.$ghostTextWidget) {
            this.session.widgetManager.removeLineWidget(this.$ghostTextWidget);
            this.$ghostTextWidget = null;
          }
          this.$ghostText = null;
        };
        VirtualRenderer2.prototype.addToken = function(text, type, row, column) {
          var session = this.session;
          session.bgTokenizer.lines[row] = null;
          var newToken = { type, value: text };
          var tokens = session.getTokens(row);
          if (column == null || !tokens.length) {
            tokens.push(newToken);
          } else {
            var l = 0;
            for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i];
              l += token.value.length;
              if (column <= l) {
                var diff = token.value.length - (l - column);
                var before = token.value.slice(0, diff);
                var after = token.value.slice(diff);
                tokens.splice(i, 1, { type: token.type, value: before }, newToken, { type: token.type, value: after });
                break;
              }
            }
          }
          this.updateLines(row, row);
        };
        VirtualRenderer2.prototype.hideTokensAfterPosition = function(row, column) {
          var tokens = this.session.getTokens(row);
          var l = 0;
          var hasPassedCursor = false;
          var hiddenTokens = [];
          for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            l += token.value.length;
            if (token.type === "ghost_text")
              continue;
            if (hasPassedCursor) {
              hiddenTokens.push({ type: token.type, value: token.value });
              token.type = "hidden_token";
              continue;
            }
            if (l === column) {
              hasPassedCursor = true;
            }
          }
          this.updateLines(row, row);
          return hiddenTokens;
        };
        VirtualRenderer2.prototype.removeExtraToken = function(row, column) {
          this.session.bgTokenizer.lines[row] = null;
          this.updateLines(row, row);
        };
        VirtualRenderer2.prototype.setTheme = function(theme, cb) {
          var _self = this;
          this.$themeId = theme;
          _self._dispatchEvent("themeChange", { theme });
          if (!theme || typeof theme == "string") {
            var moduleName = theme || this.$options.theme.initialValue;
            config.loadModule(["theme", moduleName], afterLoad);
          } else {
            afterLoad(theme);
          }
          function afterLoad(module3) {
            if (_self.$themeId != theme)
              return cb && cb();
            if (!module3 || !module3.cssClass)
              throw new Error("couldn't load module " + theme + " or it didn't call define");
            if (module3.$id)
              _self.$themeId = module3.$id;
            dom.importCssString(module3.cssText, module3.cssClass, _self.container);
            if (_self.theme)
              dom.removeCssClass(_self.container, _self.theme.cssClass);
            var padding = "padding" in module3 ? module3.padding : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
            if (_self.$padding && padding != _self.$padding)
              _self.setPadding(padding);
            _self.$theme = module3.cssClass;
            _self.theme = module3;
            dom.addCssClass(_self.container, module3.cssClass);
            dom.setCssClass(_self.container, "ace_dark", module3.isDark);
            if (_self.$size) {
              _self.$size.width = 0;
              _self.$updateSizeAsync();
            }
            _self._dispatchEvent("themeLoaded", { theme: module3 });
            cb && cb();
            if (useragent.isSafari && _self.scroller) {
              _self.scroller.style.background = "red";
              _self.scroller.style.background = "";
            }
          }
        };
        VirtualRenderer2.prototype.getTheme = function() {
          return this.$themeId;
        };
        VirtualRenderer2.prototype.setStyle = function(style2, include) {
          dom.setCssClass(this.container, style2, include !== false);
        };
        VirtualRenderer2.prototype.unsetStyle = function(style2) {
          dom.removeCssClass(this.container, style2);
        };
        VirtualRenderer2.prototype.setCursorStyle = function(style2) {
          dom.setStyle(this.scroller.style, "cursor", style2);
        };
        VirtualRenderer2.prototype.setMouseCursor = function(cursorStyle) {
          dom.setStyle(this.scroller.style, "cursor", cursorStyle);
        };
        VirtualRenderer2.prototype.attachToShadowRoot = function() {
          dom.importCssString(editorCss, "ace_editor.css", this.container);
        };
        VirtualRenderer2.prototype.destroy = function() {
          this.freeze();
          this.$fontMetrics.destroy();
          this.$cursorLayer.destroy();
          this.removeAllListeners();
          this.container.textContent = "";
          this.setOption("useResizeObserver", false);
        };
        VirtualRenderer2.prototype.$updateCustomScrollbar = function(val) {
          var _self = this;
          this.$horizScroll = this.$vScroll = null;
          this.scrollBarV.element.remove();
          this.scrollBarH.element.remove();
          if (val === true) {
            this.scrollBarV = new VScrollBarCustom(this.container, this);
            this.scrollBarH = new HScrollBarCustom(this.container, this);
            this.scrollBarV.setHeight(this.$size.scrollerHeight);
            this.scrollBarH.setWidth(this.$size.scrollerWidth);
            this.scrollBarV.addEventListener("scroll", function(e) {
              if (!_self.$scrollAnimation)
                _self.session.setScrollTop(e.data - _self.scrollMargin.top);
            });
            this.scrollBarH.addEventListener("scroll", function(e) {
              if (!_self.$scrollAnimation)
                _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
            });
            if (!this.$scrollDecorator) {
              this.$scrollDecorator = new Decorator(this.scrollBarV, this);
              this.$scrollDecorator.$updateDecorators();
            } else {
              this.$scrollDecorator.setScrollBarV(this.scrollBarV);
              this.$scrollDecorator.$updateDecorators();
            }
          } else {
            this.scrollBarV = new VScrollBar(this.container, this);
            this.scrollBarH = new HScrollBar(this.container, this);
            this.scrollBarV.addEventListener("scroll", function(e) {
              if (!_self.$scrollAnimation)
                _self.session.setScrollTop(e.data - _self.scrollMargin.top);
            });
            this.scrollBarH.addEventListener("scroll", function(e) {
              if (!_self.$scrollAnimation)
                _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
            });
          }
        };
        VirtualRenderer2.prototype.$addResizeObserver = function() {
          if (!window.ResizeObserver || this.$resizeObserver)
            return;
          var self2 = this;
          this.$resizeTimer = lang.delayedCall(function() {
            if (!self2.destroyed)
              self2.onResize();
          }, 50);
          this.$resizeObserver = new window.ResizeObserver(function(e) {
            var w = e[0].contentRect.width;
            var h = e[0].contentRect.height;
            if (Math.abs(self2.$size.width - w) > 1 || Math.abs(self2.$size.height - h) > 1) {
              self2.$resizeTimer.delay();
            } else {
              self2.$resizeTimer.cancel();
            }
          });
          this.$resizeObserver.observe(this.container);
        };
        return VirtualRenderer2;
      }()
    );
    VirtualRenderer.prototype.CHANGE_CURSOR = 1;
    VirtualRenderer.prototype.CHANGE_MARKER = 2;
    VirtualRenderer.prototype.CHANGE_GUTTER = 4;
    VirtualRenderer.prototype.CHANGE_SCROLL = 8;
    VirtualRenderer.prototype.CHANGE_LINES = 16;
    VirtualRenderer.prototype.CHANGE_TEXT = 32;
    VirtualRenderer.prototype.CHANGE_SIZE = 64;
    VirtualRenderer.prototype.CHANGE_MARKER_BACK = 128;
    VirtualRenderer.prototype.CHANGE_MARKER_FRONT = 256;
    VirtualRenderer.prototype.CHANGE_FULL = 512;
    VirtualRenderer.prototype.CHANGE_H_SCROLL = 1024;
    VirtualRenderer.prototype.$changes = 0;
    VirtualRenderer.prototype.$padding = null;
    VirtualRenderer.prototype.$frozen = false;
    VirtualRenderer.prototype.STEPS = 8;
    oop.implement(VirtualRenderer.prototype, EventEmitter);
    config.defineOptions(VirtualRenderer.prototype, "renderer", {
      useResizeObserver: {
        set: function(value) {
          if (!value && this.$resizeObserver) {
            this.$resizeObserver.disconnect();
            this.$resizeTimer.cancel();
            this.$resizeTimer = this.$resizeObserver = null;
          } else if (value && !this.$resizeObserver) {
            this.$addResizeObserver();
          }
        }
      },
      animatedScroll: { initialValue: false },
      showInvisibles: {
        set: function(value) {
          if (this.$textLayer.setShowInvisibles(value))
            this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: false
      },
      showPrintMargin: {
        set: function() {
          this.$updatePrintMargin();
        },
        initialValue: true
      },
      printMarginColumn: {
        set: function() {
          this.$updatePrintMargin();
        },
        initialValue: 80
      },
      printMargin: {
        set: function(val) {
          if (typeof val == "number")
            this.$printMarginColumn = val;
          this.$showPrintMargin = !!val;
          this.$updatePrintMargin();
        },
        get: function() {
          return this.$showPrintMargin && this.$printMarginColumn;
        }
      },
      showGutter: {
        set: function(show) {
          this.$gutter.style.display = show ? "block" : "none";
          this.$loop.schedule(this.CHANGE_FULL);
          this.onGutterResize();
        },
        initialValue: true
      },
      useSvgGutterIcons: {
        set: function(value) {
          this.$gutterLayer.$useSvgGutterIcons = value;
        },
        initialValue: false
      },
      showFoldedAnnotations: {
        set: function(value) {
          this.$gutterLayer.$showFoldedAnnotations = value;
        },
        initialValue: false
      },
      fadeFoldWidgets: {
        set: function(show) {
          dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
        },
        initialValue: false
      },
      showFoldWidgets: {
        set: function(show) {
          this.$gutterLayer.setShowFoldWidgets(show);
          this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
      },
      displayIndentGuides: {
        set: function(show) {
          if (this.$textLayer.setDisplayIndentGuides(show))
            this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: true
      },
      highlightIndentGuides: {
        set: function(show) {
          if (this.$textLayer.setHighlightIndentGuides(show) == true) {
            this.$textLayer.$highlightIndentGuide();
          } else {
            this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);
          }
        },
        initialValue: true
      },
      highlightGutterLine: {
        set: function(shouldHighlight) {
          this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
          this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: true
      },
      hScrollBarAlwaysVisible: {
        set: function(val) {
          if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
            this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
      },
      vScrollBarAlwaysVisible: {
        set: function(val) {
          if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
            this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: false
      },
      fontSize: {
        set: function(size) {
          if (typeof size == "number")
            size = size + "px";
          this.container.style.fontSize = size;
          this.updateFontSize();
        },
        initialValue: 12
      },
      fontFamily: {
        set: function(name) {
          this.container.style.fontFamily = name;
          this.updateFontSize();
        }
      },
      maxLines: {
        set: function(val) {
          this.updateFull();
        }
      },
      minLines: {
        set: function(val) {
          if (!(this.$minLines < 562949953421311))
            this.$minLines = 0;
          this.updateFull();
        }
      },
      maxPixelHeight: {
        set: function(val) {
          this.updateFull();
        },
        initialValue: 0
      },
      scrollPastEnd: {
        set: function(val) {
          val = +val || 0;
          if (this.$scrollPastEnd == val)
            return;
          this.$scrollPastEnd = val;
          this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: 0,
        handlesSet: true
      },
      fixedWidthGutter: {
        set: function(val) {
          this.$gutterLayer.$fixedWidth = !!val;
          this.$loop.schedule(this.CHANGE_GUTTER);
        }
      },
      customScrollbar: {
        set: function(val) {
          this.$updateCustomScrollbar(val);
        },
        initialValue: false
      },
      theme: {
        set: function(val) {
          this.setTheme(val);
        },
        get: function() {
          return this.$themeId || this.theme;
        },
        initialValue: "./theme/textmate",
        handlesSet: true
      },
      hasCssTransforms: {},
      useTextareaForIME: {
        initialValue: !useragent.isMobile && !useragent.isIE
      }
    });
    exports2.VirtualRenderer = VirtualRenderer;
  });
  ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var net = require2("../lib/net");
    var EventEmitter = require2("../lib/event_emitter").EventEmitter;
    var config = require2("../config");
    function $workerBlob(workerUrl) {
      var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
      try {
        return new Blob([script], { "type": "application/javascript" });
      } catch (e) {
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        var blobBuilder = new BlobBuilder();
        blobBuilder.append(script);
        return blobBuilder.getBlob("application/javascript");
      }
    }
    function createWorker(workerUrl) {
      if (typeof Worker == "undefined")
        return { postMessage: function() {
        }, terminate: function() {
        } };
      if (config.get("loadWorkerFromBlob")) {
        var blob = $workerBlob(workerUrl);
        var URL2 = window.URL || window.webkitURL;
        var blobURL = URL2.createObjectURL(blob);
        return new Worker(blobURL);
      }
      return new Worker(workerUrl);
    }
    var WorkerClient = function(worker) {
      if (!worker.postMessage)
        worker = this.$createWorkerFromOldConfig.apply(this, arguments);
      this.$worker = worker;
      this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
      this.changeListener = this.changeListener.bind(this);
      this.onMessage = this.onMessage.bind(this);
      this.callbackId = 1;
      this.callbacks = {};
      this.$worker.onmessage = this.onMessage;
    };
    (function() {
      oop.implement(this, EventEmitter);
      this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {
        if (require2.nameToUrl && !require2.toUrl)
          require2.toUrl = require2.nameToUrl;
        if (config.get("packaged") || !require2.toUrl) {
          workerUrl = workerUrl || config.moduleUrl(mod, "worker");
        } else {
          var normalizePath = this.$normalizePath;
          workerUrl = workerUrl || normalizePath(require2.toUrl("ace/worker/worker.js", null, "_"));
          var tlns = {};
          topLevelNamespaces.forEach(function(ns) {
            tlns[ns] = normalizePath(require2.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
          });
        }
        this.$worker = createWorker(workerUrl);
        if (importScripts) {
          this.send("importScripts", importScripts);
        }
        this.$worker.postMessage({
          init: true,
          tlns,
          module: mod,
          classname
        });
        return this.$worker;
      };
      this.onMessage = function(e) {
        var msg = e.data;
        switch (msg.type) {
          case "event":
            this._signal(msg.name, { data: msg.data });
            break;
          case "call":
            var callback = this.callbacks[msg.id];
            if (callback) {
              callback(msg.data);
              delete this.callbacks[msg.id];
            }
            break;
          case "error":
            this.reportError(msg.data);
            break;
          case "log":
            window.console && console.log && console.log.apply(console, msg.data);
            break;
        }
      };
      this.reportError = function(err) {
        window.console && console.error && console.error(err);
      };
      this.$normalizePath = function(path) {
        return net.qualifyURL(path);
      };
      this.terminate = function() {
        this._signal("terminate", {});
        this.deltaQueue = null;
        this.$worker.terminate();
        this.$worker.onerror = function(e) {
          e.preventDefault();
        };
        this.$worker = null;
        if (this.$doc)
          this.$doc.off("change", this.changeListener);
        this.$doc = null;
      };
      this.send = function(cmd, args) {
        this.$worker.postMessage({ command: cmd, args });
      };
      this.call = function(cmd, args, callback) {
        if (callback) {
          var id2 = this.callbackId++;
          this.callbacks[id2] = callback;
          args.push(id2);
        }
        this.send(cmd, args);
      };
      this.emit = function(event, data) {
        try {
          if (data.data && data.data.err)
            data.data.err = { message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code };
          this.$worker && this.$worker.postMessage({ event, data: { data: data.data } });
        } catch (ex) {
          console.error(ex.stack);
        }
      };
      this.attachToDocument = function(doc) {
        if (this.$doc)
          this.terminate();
        this.$doc = doc;
        this.call("setValue", [doc.getValue()]);
        doc.on("change", this.changeListener, true);
      };
      this.changeListener = function(delta) {
        if (!this.deltaQueue) {
          this.deltaQueue = [];
          setTimeout(this.$sendDeltaQueue, 0);
        }
        if (delta.action == "insert")
          this.deltaQueue.push(delta.start, delta.lines);
        else
          this.deltaQueue.push(delta.start, delta.end);
      };
      this.$sendDeltaQueue = function() {
        var q = this.deltaQueue;
        if (!q) return;
        this.deltaQueue = null;
        if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
          this.call("setValue", [this.$doc.getValue()]);
        } else
          this.emit("change", { data: q });
      };
    }).call(WorkerClient.prototype);
    var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
      var main = null;
      var emitSync = false;
      var sender = Object.create(EventEmitter);
      var messageBuffer = [];
      var workerClient = new WorkerClient({
        messageBuffer,
        terminate: function() {
        },
        postMessage: function(e) {
          messageBuffer.push(e);
          if (!main) return;
          if (emitSync)
            setTimeout(processNext);
          else
            processNext();
        }
      });
      workerClient.setEmitSync = function(val) {
        emitSync = val;
      };
      var processNext = function() {
        var msg = messageBuffer.shift();
        if (msg.command)
          main[msg.command].apply(main, msg.args);
        else if (msg.event)
          sender._signal(msg.event, msg.data);
      };
      sender.postMessage = function(msg) {
        workerClient.onMessage({ data: msg });
      };
      sender.callback = function(data, callbackId) {
        this.postMessage({ type: "call", id: callbackId, data });
      };
      sender.emit = function(name, data) {
        this.postMessage({ type: "event", name, data });
      };
      config.loadModule(["worker", mod], function(Main) {
        main = new Main[classname](sender);
        while (messageBuffer.length)
          processNext();
      });
      return workerClient;
    };
    exports2.UIWorkerClient = UIWorkerClient;
    exports2.WorkerClient = WorkerClient;
    exports2.createWorker = createWorker;
  });
  ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function(require2, exports2, module2) {
    var Range = require2("./range").Range;
    var EventEmitter = require2("./lib/event_emitter").EventEmitter;
    var oop = require2("./lib/oop");
    var PlaceHolder = (
      /** @class */
      function() {
        function PlaceHolder2(session, length, pos, others, mainClass, othersClass) {
          var _self = this;
          this.length = length;
          this.session = session;
          this.doc = session.getDocument();
          this.mainClass = mainClass;
          this.othersClass = othersClass;
          this.$onUpdate = this.onUpdate.bind(this);
          this.doc.on("change", this.$onUpdate, true);
          this.$others = others;
          this.$onCursorChange = function() {
            setTimeout(function() {
              _self.onCursorChange();
            });
          };
          this.$pos = pos;
          var undoStack = session.getUndoManager().$undoStack || session.getUndoManager()["$undostack"] || { length: -1 };
          this.$undoStackDepth = undoStack.length;
          this.setup();
          session.selection.on("changeCursor", this.$onCursorChange);
        }
        PlaceHolder2.prototype.setup = function() {
          var _self = this;
          var doc = this.doc;
          var session = this.session;
          this.selectionBefore = session.selection.toJSON();
          if (session.selection.inMultiSelectMode)
            session.selection.toSingleRange();
          this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
          var pos = this.pos;
          pos.$insertRight = true;
          pos.detach();
          pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
          this.others = [];
          this.$others.forEach(function(other) {
            var anchor = doc.createAnchor(other.row, other.column);
            anchor.$insertRight = true;
            anchor.detach();
            _self.others.push(anchor);
          });
          session.setUndoSelect(false);
        };
        PlaceHolder2.prototype.showOtherMarkers = function() {
          if (this.othersActive)
            return;
          var session = this.session;
          var _self = this;
          this.othersActive = true;
          this.others.forEach(function(anchor) {
            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
          });
        };
        PlaceHolder2.prototype.hideOtherMarkers = function() {
          if (!this.othersActive)
            return;
          this.othersActive = false;
          for (var i = 0; i < this.others.length; i++) {
            this.session.removeMarker(this.others[i].markerId);
          }
        };
        PlaceHolder2.prototype.onUpdate = function(delta) {
          if (this.$updating)
            return this.updateAnchors(delta);
          var range = delta;
          if (range.start.row !== range.end.row)
            return;
          if (range.start.row !== this.pos.row)
            return;
          this.$updating = true;
          var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
          var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
          var distanceFromStart = range.start.column - this.pos.column;
          this.updateAnchors(delta);
          if (inMainRange)
            this.length += lengthDiff;
          if (inMainRange && !this.session.$fromUndo) {
            if (delta.action === "insert") {
              for (var i = this.others.length - 1; i >= 0; i--) {
                var otherPos = this.others[i];
                var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                this.doc.insertMergedLines(newPos, delta.lines);
              }
            } else if (delta.action === "remove") {
              for (var i = this.others.length - 1; i >= 0; i--) {
                var otherPos = this.others[i];
                var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
              }
            }
          }
          this.$updating = false;
          this.updateMarkers();
        };
        PlaceHolder2.prototype.updateAnchors = function(delta) {
          this.pos.onChange(delta);
          for (var i = this.others.length; i--; )
            this.others[i].onChange(delta);
          this.updateMarkers();
        };
        PlaceHolder2.prototype.updateMarkers = function() {
          if (this.$updating)
            return;
          var _self = this;
          var session = this.session;
          var updateMarker = function(pos, className) {
            session.removeMarker(pos.markerId);
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
          };
          updateMarker(this.pos, this.mainClass);
          for (var i = this.others.length; i--; )
            updateMarker(this.others[i], this.othersClass);
        };
        PlaceHolder2.prototype.onCursorChange = function(event) {
          if (this.$updating || !this.session)
            return;
          var pos = this.session.selection.getCursor();
          if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
            this.showOtherMarkers();
            this._emit("cursorEnter", event);
          } else {
            this.hideOtherMarkers();
            this._emit("cursorLeave", event);
          }
        };
        PlaceHolder2.prototype.detach = function() {
          this.session.removeMarker(this.pos && this.pos.markerId);
          this.hideOtherMarkers();
          this.doc.off("change", this.$onUpdate);
          this.session.selection.off("changeCursor", this.$onCursorChange);
          this.session.setUndoSelect(true);
          this.session = null;
        };
        PlaceHolder2.prototype.cancel = function() {
          if (this.$undoStackDepth === -1)
            return;
          var undoManager = this.session.getUndoManager();
          var undosRequired = (undoManager.$undoStack || undoManager["$undostack"]).length - this.$undoStackDepth;
          for (var i = 0; i < undosRequired; i++) {
            undoManager.undo(this.session, true);
          }
          if (this.selectionBefore)
            this.session.selection.fromJSON(this.selectionBefore);
        };
        return PlaceHolder2;
      }()
    );
    oop.implement(PlaceHolder.prototype, EventEmitter);
    exports2.PlaceHolder = PlaceHolder;
  });
  ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(require2, exports2, module2) {
    var event = require2("../lib/event");
    var useragent = require2("../lib/useragent");
    function isSamePoint(p1, p2) {
      return p1.row == p2.row && p1.column == p2.column;
    }
    function onMouseDown(e) {
      var ev = e.domEvent;
      var alt = ev.altKey;
      var shift = ev.shiftKey;
      var ctrl = ev.ctrlKey;
      var accel = e.getAccelKey();
      var button = e.getButton();
      if (ctrl && useragent.isMac)
        button = ev.button;
      if (e.editor.inMultiSelectMode && button == 2) {
        e.editor.textInput.onContextMenu(e.domEvent);
        return;
      }
      if (!ctrl && !alt && !accel) {
        if (button === 0 && e.editor.inMultiSelectMode)
          e.editor.exitMultiSelectMode();
        return;
      }
      if (button !== 0)
        return;
      var editor2 = e.editor;
      var selection = editor2.selection;
      var isMultiSelect = editor2.inMultiSelectMode;
      var pos = e.getDocumentPosition();
      var cursor = selection.getCursor();
      var inSelection = e.inSelection() || selection.isEmpty() && isSamePoint(pos, cursor);
      var mouseX = e.x, mouseY = e.y;
      var onMouseSelection = function(e2) {
        mouseX = e2.clientX;
        mouseY = e2.clientY;
      };
      var session = editor2.session;
      var screenAnchor = editor2.renderer.pixelToScreenCoordinates(mouseX, mouseY);
      var screenCursor = screenAnchor;
      var selectionMode;
      if (editor2.$mouseHandler.$enableJumpToDef) {
        if (ctrl && alt || accel && alt)
          selectionMode = shift ? "block" : "add";
        else if (alt && editor2.$blockSelectEnabled)
          selectionMode = "block";
      } else {
        if (accel && !alt) {
          selectionMode = "add";
          if (!isMultiSelect && shift)
            return;
        } else if (alt && editor2.$blockSelectEnabled) {
          selectionMode = "block";
        }
      }
      if (selectionMode && useragent.isMac && ev.ctrlKey) {
        editor2.$mouseHandler.cancelContextMenu();
      }
      if (selectionMode == "add") {
        if (!isMultiSelect && inSelection)
          return;
        if (!isMultiSelect) {
          var range = selection.toOrientedRange();
          editor2.addSelectionMarker(range);
        }
        var oldRange = selection.rangeList.rangeAtPoint(pos);
        editor2.inVirtualSelectionMode = true;
        if (shift) {
          oldRange = null;
          range = selection.ranges[0] || range;
          editor2.removeSelectionMarker(range);
        }
        editor2.once("mouseup", function() {
          var tmpSel = selection.toOrientedRange();
          if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
            selection.substractPoint(tmpSel.cursor);
          else {
            if (shift) {
              selection.substractPoint(range.cursor);
            } else if (range) {
              editor2.removeSelectionMarker(range);
              selection.addRange(range);
            }
            selection.addRange(tmpSel);
          }
          editor2.inVirtualSelectionMode = false;
        });
      } else if (selectionMode == "block") {
        e.stop();
        editor2.inVirtualSelectionMode = true;
        var initialRange;
        var rectSel = [];
        var blockSelect = function() {
          var newCursor = editor2.renderer.pixelToScreenCoordinates(mouseX, mouseY);
          var cursor2 = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);
          if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor2, selection.lead))
            return;
          screenCursor = newCursor;
          editor2.selection.moveToPosition(cursor2);
          editor2.renderer.scrollCursorIntoView();
          editor2.removeSelectionMarkers(rectSel);
          rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
          if (editor2.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
            rectSel[0] = editor2.$mouseHandler.$clickSelection.clone();
          rectSel.forEach(editor2.addSelectionMarker, editor2);
          editor2.updateSelectionMarkers();
        };
        if (isMultiSelect && !accel) {
          selection.toSingleRange();
        } else if (!isMultiSelect && accel) {
          initialRange = selection.toOrientedRange();
          editor2.addSelectionMarker(initialRange);
        }
        if (shift)
          screenAnchor = session.documentToScreenPosition(selection.lead);
        else
          selection.moveToPosition(pos);
        screenCursor = { row: -1, column: -1 };
        var onMouseSelectionEnd = function(e2) {
          blockSelect();
          clearInterval(timerId);
          editor2.removeSelectionMarkers(rectSel);
          if (!rectSel.length)
            rectSel = [selection.toOrientedRange()];
          if (initialRange) {
            editor2.removeSelectionMarker(initialRange);
            selection.toSingleRange(initialRange);
          }
          for (var i = 0; i < rectSel.length; i++)
            selection.addRange(rectSel[i]);
          editor2.inVirtualSelectionMode = false;
          editor2.$mouseHandler.$clickSelection = null;
        };
        var onSelectionInterval = blockSelect;
        event.capture(editor2.container, onMouseSelection, onMouseSelectionEnd);
        var timerId = setInterval(function() {
          onSelectionInterval();
        }, 20);
        return e.preventDefault();
      }
    }
    exports2.onMouseDown = onMouseDown;
  });
  ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function(require2, exports2, module2) {
    exports2.defaultCommands = [{
      name: "addCursorAbove",
      description: "Add cursor above",
      exec: function(editor2) {
        editor2.selectMoreLines(-1);
      },
      bindKey: { win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up" },
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "addCursorBelow",
      description: "Add cursor below",
      exec: function(editor2) {
        editor2.selectMoreLines(1);
      },
      bindKey: { win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down" },
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "addCursorAboveSkipCurrent",
      description: "Add cursor above (skip current)",
      exec: function(editor2) {
        editor2.selectMoreLines(-1, true);
      },
      bindKey: { win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up" },
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "addCursorBelowSkipCurrent",
      description: "Add cursor below (skip current)",
      exec: function(editor2) {
        editor2.selectMoreLines(1, true);
      },
      bindKey: { win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down" },
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "selectMoreBefore",
      description: "Select more before",
      exec: function(editor2) {
        editor2.selectMore(-1);
      },
      bindKey: { win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left" },
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "selectMoreAfter",
      description: "Select more after",
      exec: function(editor2) {
        editor2.selectMore(1);
      },
      bindKey: { win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right" },
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "selectNextBefore",
      description: "Select next before",
      exec: function(editor2) {
        editor2.selectMore(-1, true);
      },
      bindKey: { win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left" },
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "selectNextAfter",
      description: "Select next after",
      exec: function(editor2) {
        editor2.selectMore(1, true);
      },
      bindKey: { win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right" },
      scrollIntoView: "cursor",
      readOnly: true
    }, {
      name: "toggleSplitSelectionIntoLines",
      description: "Split selection into lines",
      exec: function(editor2) {
        if (editor2.multiSelect.rangeCount > 1)
          editor2.multiSelect.joinSelections();
        else
          editor2.multiSelect.splitIntoLines();
      },
      bindKey: { win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L" },
      readOnly: true
    }, {
      name: "splitSelectionIntoLines",
      description: "Split into lines",
      exec: function(editor2) {
        editor2.multiSelect.splitIntoLines();
      },
      readOnly: true
    }, {
      name: "alignCursors",
      description: "Align cursors",
      exec: function(editor2) {
        editor2.alignCursors();
      },
      bindKey: { win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A" },
      scrollIntoView: "cursor"
    }, {
      name: "findAll",
      description: "Find all",
      exec: function(editor2) {
        editor2.findAll();
      },
      bindKey: { win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G" },
      scrollIntoView: "cursor",
      readOnly: true
    }];
    exports2.multiSelectCommands = [{
      name: "singleSelection",
      description: "Single selection",
      bindKey: "esc",
      exec: function(editor2) {
        editor2.exitMultiSelectMode();
      },
      scrollIntoView: "cursor",
      readOnly: true,
      isAvailable: function(editor2) {
        return editor2 && editor2.inMultiSelectMode;
      }
    }];
    var HashHandler = require2("../keyboard/hash_handler").HashHandler;
    exports2.keyboardHandler = new HashHandler(exports2.multiSelectCommands);
  });
  ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function(require2, exports2, module2) {
    var RangeList = require2("./range_list").RangeList;
    var Range = require2("./range").Range;
    var Selection = require2("./selection").Selection;
    var onMouseDown = require2("./mouse/multi_select_handler").onMouseDown;
    var event = require2("./lib/event");
    var lang = require2("./lib/lang");
    var commands = require2("./commands/multi_select_commands");
    exports2.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
    var Search = require2("./search").Search;
    var search = new Search();
    function find(session, needle, dir) {
      search.$options.wrap = true;
      search.$options.needle = needle;
      search.$options.backwards = dir == -1;
      return search.find(session);
    }
    var EditSession = require2("./edit_session").EditSession;
    (function() {
      this.getSelectionMarkers = function() {
        return this.$selectionMarkers;
      };
    }).call(EditSession.prototype);
    (function() {
      this.ranges = null;
      this.rangeList = null;
      this.addRange = function(range, $blockChangeEvents) {
        if (!range)
          return;
        if (!this.inMultiSelectMode && this.rangeCount === 0) {
          var oldRange = this.toOrientedRange();
          this.rangeList.add(oldRange);
          this.rangeList.add(range);
          if (this.rangeList.ranges.length != 2) {
            this.rangeList.removeAll();
            return $blockChangeEvents || this.fromOrientedRange(range);
          }
          this.rangeList.removeAll();
          this.rangeList.add(oldRange);
          this.$onAddRange(oldRange);
        }
        if (!range.cursor)
          range.cursor = range.end;
        var removed = this.rangeList.add(range);
        this.$onAddRange(range);
        if (removed.length)
          this.$onRemoveRange(removed);
        if (this.rangeCount > 1 && !this.inMultiSelectMode) {
          this._signal("multiSelect");
          this.inMultiSelectMode = true;
          this.session.$undoSelect = false;
          this.rangeList.attach(this.session);
        }
        return $blockChangeEvents || this.fromOrientedRange(range);
      };
      this.toSingleRange = function(range) {
        range = range || this.ranges[0];
        var removed = this.rangeList.removeAll();
        if (removed.length)
          this.$onRemoveRange(removed);
        range && this.fromOrientedRange(range);
      };
      this.substractPoint = function(pos) {
        var removed = this.rangeList.substractPoint(pos);
        if (removed) {
          this.$onRemoveRange(removed);
          return removed[0];
        }
      };
      this.mergeOverlappingRanges = function() {
        var removed = this.rangeList.merge();
        if (removed.length)
          this.$onRemoveRange(removed);
      };
      this.$onAddRange = function(range) {
        this.rangeCount = this.rangeList.ranges.length;
        this.ranges.unshift(range);
        this._signal("addRange", { range });
      };
      this.$onRemoveRange = function(removed) {
        this.rangeCount = this.rangeList.ranges.length;
        if (this.rangeCount == 1 && this.inMultiSelectMode) {
          var lastRange = this.rangeList.ranges.pop();
          removed.push(lastRange);
          this.rangeCount = 0;
        }
        for (var i = removed.length; i--; ) {
          var index2 = this.ranges.indexOf(removed[i]);
          this.ranges.splice(index2, 1);
        }
        this._signal("removeRange", { ranges: removed });
        if (this.rangeCount === 0 && this.inMultiSelectMode) {
          this.inMultiSelectMode = false;
          this._signal("singleSelect");
          this.session.$undoSelect = true;
          this.rangeList.detach(this.session);
        }
        lastRange = lastRange || this.ranges[0];
        if (lastRange && !lastRange.isEqual(this.getRange()))
          this.fromOrientedRange(lastRange);
      };
      this.$initRangeList = function() {
        if (this.rangeList)
          return;
        this.rangeList = new RangeList();
        this.ranges = [];
        this.rangeCount = 0;
      };
      this.getAllRanges = function() {
        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
      };
      this.splitIntoLines = function() {
        var ranges = this.ranges.length ? this.ranges : [this.getRange()];
        var newRanges = [];
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          var row = range.start.row;
          var endRow = range.end.row;
          if (row === endRow) {
            newRanges.push(range.clone());
          } else {
            newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));
            while (++row < endRow)
              newRanges.push(this.getLineRange(row, true));
            newRanges.push(new Range(endRow, 0, endRow, range.end.column));
          }
          if (i == 0 && !this.isBackwards())
            newRanges = newRanges.reverse();
        }
        this.toSingleRange();
        for (var i = newRanges.length; i--; )
          this.addRange(newRanges[i]);
      };
      this.joinSelections = function() {
        var ranges = this.rangeList.ranges;
        var lastRange = ranges[ranges.length - 1];
        var range = Range.fromPoints(ranges[0].start, lastRange.end);
        this.toSingleRange();
        this.setSelectionRange(range, lastRange.cursor == lastRange.start);
      };
      this.toggleBlockSelection = function() {
        if (this.rangeCount > 1) {
          var ranges = this.rangeList.ranges;
          var lastRange = ranges[ranges.length - 1];
          var range = Range.fromPoints(ranges[0].start, lastRange.end);
          this.toSingleRange();
          this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        } else {
          var cursor = this.session.documentToScreenPosition(this.cursor);
          var anchor = this.session.documentToScreenPosition(this.anchor);
          var rectSel = this.rectangularRangeBlock(cursor, anchor);
          rectSel.forEach(this.addRange, this);
        }
      };
      this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
        var rectSel = [];
        var xBackwards = screenCursor.column < screenAnchor.column;
        if (xBackwards) {
          var startColumn = screenCursor.column;
          var endColumn = screenAnchor.column;
          var startOffsetX = screenCursor.offsetX;
          var endOffsetX = screenAnchor.offsetX;
        } else {
          var startColumn = screenAnchor.column;
          var endColumn = screenCursor.column;
          var startOffsetX = screenAnchor.offsetX;
          var endOffsetX = screenCursor.offsetX;
        }
        var yBackwards = screenCursor.row < screenAnchor.row;
        if (yBackwards) {
          var startRow = screenCursor.row;
          var endRow = screenAnchor.row;
        } else {
          var startRow = screenAnchor.row;
          var endRow = screenCursor.row;
        }
        if (startColumn < 0)
          startColumn = 0;
        if (startRow < 0)
          startRow = 0;
        if (startRow == endRow)
          includeEmptyLines = true;
        var docEnd;
        for (var row = startRow; row <= endRow; row++) {
          var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn, startOffsetX), this.session.screenToDocumentPosition(row, endColumn, endOffsetX));
          if (range.isEmpty()) {
            if (docEnd && isSamePoint(range.end, docEnd))
              break;
            docEnd = range.end;
          }
          range.cursor = xBackwards ? range.start : range.end;
          rectSel.push(range);
        }
        if (yBackwards)
          rectSel.reverse();
        if (!includeEmptyLines) {
          var end = rectSel.length - 1;
          while (rectSel[end].isEmpty() && end > 0)
            end--;
          if (end > 0) {
            var start = 0;
            while (rectSel[start].isEmpty())
              start++;
          }
          for (var i = end; i >= start; i--) {
            if (rectSel[i].isEmpty())
              rectSel.splice(i, 1);
          }
        }
        return rectSel;
      };
    }).call(Selection.prototype);
    var Editor2 = require2("./editor").Editor;
    (function() {
      this.updateSelectionMarkers = function() {
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
      };
      this.addSelectionMarker = function(orientedRange) {
        if (!orientedRange.cursor)
          orientedRange.cursor = orientedRange.end;
        var style2 = this.getSelectionStyle();
        orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style2);
        this.session.$selectionMarkers.push(orientedRange);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        return orientedRange;
      };
      this.removeSelectionMarker = function(range) {
        if (!range.marker)
          return;
        this.session.removeMarker(range.marker);
        var index2 = this.session.$selectionMarkers.indexOf(range);
        if (index2 != -1)
          this.session.$selectionMarkers.splice(index2, 1);
        this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
      };
      this.removeSelectionMarkers = function(ranges) {
        var markerList = this.session.$selectionMarkers;
        for (var i = ranges.length; i--; ) {
          var range = ranges[i];
          if (!range.marker)
            continue;
          this.session.removeMarker(range.marker);
          var index2 = markerList.indexOf(range);
          if (index2 != -1)
            markerList.splice(index2, 1);
        }
        this.session.selectionMarkerCount = markerList.length;
      };
      this.$onAddRange = function(e) {
        this.addSelectionMarker(e.range);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
      };
      this.$onRemoveRange = function(e) {
        this.removeSelectionMarkers(e.ranges);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
      };
      this.$onMultiSelect = function(e) {
        if (this.inMultiSelectMode)
          return;
        this.inMultiSelectMode = true;
        this.setStyle("ace_multiselect");
        this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
        this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
      };
      this.$onSingleSelect = function(e) {
        if (this.session.multiSelect.inVirtualMode)
          return;
        this.inMultiSelectMode = false;
        this.unsetStyle("ace_multiselect");
        this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
        this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
        this.renderer.updateCursor();
        this.renderer.updateBackMarkers();
        this._emit("changeSelection");
      };
      this.$onMultiSelectExec = function(e) {
        var command = e.command;
        var editor2 = e.editor;
        if (!editor2.multiSelect)
          return;
        if (!command.multiSelectAction) {
          var result = command.exec(editor2, e.args || {});
          editor2.multiSelect.addRange(editor2.multiSelect.toOrientedRange());
          editor2.multiSelect.mergeOverlappingRanges();
        } else if (command.multiSelectAction == "forEach") {
          result = editor2.forEachSelection(command, e.args);
        } else if (command.multiSelectAction == "forEachLine") {
          result = editor2.forEachSelection(command, e.args, true);
        } else if (command.multiSelectAction == "single") {
          editor2.exitMultiSelectMode();
          result = command.exec(editor2, e.args || {});
        } else {
          result = command.multiSelectAction(editor2, e.args || {});
        }
        return result;
      };
      this.forEachSelection = function(cmd, args, options) {
        if (this.inVirtualSelectionMode)
          return;
        var keepOrder = options && options.keepOrder;
        var $byLines = options == true || options && options.$byLines;
        var session = this.session;
        var selection = this.selection;
        var rangeList = selection.rangeList;
        var ranges = (keepOrder ? selection : rangeList).ranges;
        var result;
        if (!ranges.length)
          return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
        var reg = selection._eventRegistry;
        selection._eventRegistry = {};
        var tmpSel = new Selection(session);
        this.inVirtualSelectionMode = true;
        for (var i = ranges.length; i--; ) {
          if ($byLines) {
            while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
              i--;
          }
          tmpSel.fromOrientedRange(ranges[i]);
          tmpSel.index = i;
          this.selection = session.selection = tmpSel;
          var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
          if (!result && cmdResult !== void 0)
            result = cmdResult;
          tmpSel.toOrientedRange(ranges[i]);
        }
        tmpSel.detach();
        this.selection = session.selection = selection;
        this.inVirtualSelectionMode = false;
        selection._eventRegistry = reg;
        selection.mergeOverlappingRanges();
        if (selection.ranges[0])
          selection.fromOrientedRange(selection.ranges[0]);
        var anim = this.renderer.$scrollAnimation;
        this.onCursorChange();
        this.onSelectionChange();
        if (anim && anim.from == anim.to)
          this.renderer.animateScrolling(anim.from);
        return result;
      };
      this.exitMultiSelectMode = function() {
        if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
          return;
        this.multiSelect.toSingleRange();
      };
      this.getSelectedText = function() {
        var text = "";
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
          var ranges = this.multiSelect.rangeList.ranges;
          var buf = [];
          for (var i = 0; i < ranges.length; i++) {
            buf.push(this.session.getTextRange(ranges[i]));
          }
          var nl = this.session.getDocument().getNewLineCharacter();
          text = buf.join(nl);
          if (text.length == (buf.length - 1) * nl.length)
            text = "";
        } else if (!this.selection.isEmpty()) {
          text = this.session.getTextRange(this.getSelectionRange());
        }
        return text;
      };
      this.$checkMultiselectChange = function(e, anchor) {
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
          var range = this.multiSelect.ranges[0];
          if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
            return;
          var pos = anchor == this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
          if (pos.row != anchor.row || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
            this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
          else
            this.multiSelect.mergeOverlappingRanges();
        }
      };
      this.findAll = function(needle, options, additive) {
        options = options || {};
        options.needle = needle || options.needle;
        if (options.needle == void 0) {
          var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
          options.needle = this.session.getTextRange(range);
        }
        this.$search.set(options);
        var ranges = this.$search.findAll(this.session);
        if (!ranges.length)
          return 0;
        var selection = this.multiSelect;
        if (!additive)
          selection.toSingleRange(ranges[0]);
        for (var i = ranges.length; i--; )
          selection.addRange(ranges[i], true);
        if (range && selection.rangeList.rangeAtPoint(range.start))
          selection.addRange(range, true);
        return ranges.length;
      };
      this.selectMoreLines = function(dir, skip) {
        var range = this.selection.toOrientedRange();
        var isBackwards = range.cursor == range.end;
        var screenLead = this.session.documentToScreenPosition(range.cursor);
        if (this.selection.$desiredColumn)
          screenLead.column = this.selection.$desiredColumn;
        var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
        if (!range.isEmpty()) {
          var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
          var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
        } else {
          var anchor = lead;
        }
        if (isBackwards) {
          var newRange = Range.fromPoints(lead, anchor);
          newRange.cursor = newRange.start;
        } else {
          var newRange = Range.fromPoints(anchor, lead);
          newRange.cursor = newRange.end;
        }
        newRange.desiredColumn = screenLead.column;
        if (!this.selection.inMultiSelectMode) {
          this.selection.addRange(range);
        } else {
          if (skip)
            var toRemove = range.cursor;
        }
        this.selection.addRange(newRange);
        if (toRemove)
          this.selection.substractPoint(toRemove);
      };
      this.transposeSelections = function(dir) {
        var session = this.session;
        var sel = session.multiSelect;
        var all = sel.ranges;
        for (var i = all.length; i--; ) {
          var range = all[i];
          if (range.isEmpty()) {
            var tmp_1 = session.getWordRange(range.start.row, range.start.column);
            range.start.row = tmp_1.start.row;
            range.start.column = tmp_1.start.column;
            range.end.row = tmp_1.end.row;
            range.end.column = tmp_1.end.column;
          }
        }
        sel.mergeOverlappingRanges();
        var words = [];
        for (var i = all.length; i--; ) {
          var range = all[i];
          words.unshift(session.getTextRange(range));
        }
        if (dir < 0)
          words.unshift(words.pop());
        else
          words.push(words.shift());
        for (var i = all.length; i--; ) {
          var range = all[i];
          var tmp = range.clone();
          session.replace(range, words[i]);
          range.start.row = tmp.start.row;
          range.start.column = tmp.start.column;
        }
        sel.fromOrientedRange(sel.ranges[0]);
      };
      this.selectMore = function(dir, skip, stopAtFirst) {
        var session = this.session;
        var sel = session.multiSelect;
        var range = sel.toOrientedRange();
        if (range.isEmpty()) {
          range = session.getWordRange(range.start.row, range.start.column);
          range.cursor = dir == -1 ? range.start : range.end;
          this.multiSelect.addRange(range);
          if (stopAtFirst)
            return;
        }
        var needle = session.getTextRange(range);
        var newRange = find(session, needle, dir);
        if (newRange) {
          newRange.cursor = dir == -1 ? newRange.start : newRange.end;
          this.session.unfold(newRange);
          this.multiSelect.addRange(newRange);
          this.renderer.scrollCursorIntoView(null, 0.5);
        }
        if (skip)
          this.multiSelect.substractPoint(range.cursor);
      };
      this.alignCursors = function() {
        var session = this.session;
        var sel = session.multiSelect;
        var ranges = sel.ranges;
        var row = -1;
        var sameRowRanges = ranges.filter(function(r) {
          if (r.cursor.row == row)
            return true;
          row = r.cursor.row;
        });
        if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
          var range = this.selection.getRange();
          var fr = range.start.row, lr = range.end.row;
          var guessRange = fr == lr;
          if (guessRange) {
            var max = this.session.getLength();
            var line;
            do {
              line = this.session.getLine(lr);
            } while (/[=:]/.test(line) && ++lr < max);
            do {
              line = this.session.getLine(fr);
            } while (/[=:]/.test(line) && --fr > 0);
            if (fr < 0)
              fr = 0;
            if (lr >= max)
              lr = max - 1;
          }
          var lines = this.session.removeFullLines(fr, lr);
          lines = this.$reAlignText(lines, guessRange);
          this.session.insert({ row: fr, column: 0 }, lines.join("\n") + "\n");
          if (!guessRange) {
            range.start.column = 0;
            range.end.column = lines[lines.length - 1].length;
          }
          this.selection.setRange(range);
        } else {
          sameRowRanges.forEach(function(r) {
            sel.substractPoint(r.cursor);
          });
          var maxCol = 0;
          var minSpace = Infinity;
          var spaceOffsets = ranges.map(function(r) {
            var p = r.cursor;
            var line2 = session.getLine(p.row);
            var spaceOffset = line2.substr(p.column).search(/\S/g);
            if (spaceOffset == -1)
              spaceOffset = 0;
            if (p.column > maxCol)
              maxCol = p.column;
            if (spaceOffset < minSpace)
              minSpace = spaceOffset;
            return spaceOffset;
          });
          ranges.forEach(function(r, i) {
            var p = r.cursor;
            var l = maxCol - p.column;
            var d = spaceOffsets[i] - minSpace;
            if (l > d)
              session.insert(p, lang.stringRepeat(" ", l - d));
            else
              session.remove(new Range(p.row, p.column, p.row, p.column - l + d));
            r.start.column = r.end.column = maxCol;
            r.start.row = r.end.row = p.row;
            r.cursor = r.end;
          });
          sel.fromOrientedRange(ranges[0]);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        }
      };
      this.$reAlignText = function(lines, forceLeft) {
        var isLeftAligned = true, isRightAligned = true;
        var startW, textW, endW;
        return lines.map(function(line) {
          var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
          if (!m)
            return [line];
          if (startW == null) {
            startW = m[1].length;
            textW = m[2].length;
            endW = m[3].length;
            return m;
          }
          if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
            isRightAligned = false;
          if (startW != m[1].length)
            isLeftAligned = false;
          if (startW > m[1].length)
            startW = m[1].length;
          if (textW < m[2].length)
            textW = m[2].length;
          if (endW > m[3].length)
            endW = m[3].length;
          return m;
        }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
        function spaces(n) {
          return lang.stringRepeat(" ", n);
        }
        function alignLeft(m) {
          return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(textW - m[2].length + endW) + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function alignRight(m) {
          return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
        }
        function unAlign(m) {
          return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
        }
      };
    }).call(Editor2.prototype);
    function isSamePoint(p1, p2) {
      return p1.row == p2.row && p1.column == p2.column;
    }
    exports2.onSessionChange = function(e) {
      var session = e.session;
      if (session && !session.multiSelect) {
        session.$selectionMarkers = [];
        session.selection.$initRangeList();
        session.multiSelect = session.selection;
      }
      this.multiSelect = session && session.multiSelect;
      var oldSession = e.oldSession;
      if (oldSession) {
        oldSession.multiSelect.off("addRange", this.$onAddRange);
        oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
        oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
        oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
        oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
        oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
      }
      if (session) {
        session.multiSelect.on("addRange", this.$onAddRange);
        session.multiSelect.on("removeRange", this.$onRemoveRange);
        session.multiSelect.on("multiSelect", this.$onMultiSelect);
        session.multiSelect.on("singleSelect", this.$onSingleSelect);
        session.multiSelect.lead.on("change", this.$checkMultiselectChange);
        session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
      }
      if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
        if (session.selection.inMultiSelectMode)
          this.$onMultiSelect();
        else
          this.$onSingleSelect();
      }
    };
    function MultiSelect(editor2) {
      if (editor2.$multiselectOnSessionChange)
        return;
      editor2.$onAddRange = editor2.$onAddRange.bind(editor2);
      editor2.$onRemoveRange = editor2.$onRemoveRange.bind(editor2);
      editor2.$onMultiSelect = editor2.$onMultiSelect.bind(editor2);
      editor2.$onSingleSelect = editor2.$onSingleSelect.bind(editor2);
      editor2.$multiselectOnSessionChange = exports2.onSessionChange.bind(editor2);
      editor2.$checkMultiselectChange = editor2.$checkMultiselectChange.bind(editor2);
      editor2.$multiselectOnSessionChange(editor2);
      editor2.on("changeSession", editor2.$multiselectOnSessionChange);
      editor2.on("mousedown", onMouseDown);
      editor2.commands.addCommands(commands.defaultCommands);
      addAltCursorListeners(editor2);
    }
    function addAltCursorListeners(editor2) {
      if (!editor2.textInput)
        return;
      var el = editor2.textInput.getElement();
      var altCursor = false;
      event.addListener(el, "keydown", function(e) {
        var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
        if (editor2.$blockSelectEnabled && altDown) {
          if (!altCursor) {
            editor2.renderer.setMouseCursor("crosshair");
            altCursor = true;
          }
        } else if (altCursor) {
          reset();
        }
      }, editor2);
      event.addListener(el, "keyup", reset, editor2);
      event.addListener(el, "blur", reset, editor2);
      function reset(e) {
        if (altCursor) {
          editor2.renderer.setMouseCursor("");
          altCursor = false;
        }
      }
    }
    exports2.MultiSelect = MultiSelect;
    require2("./config").defineOptions(Editor2.prototype, "editor", {
      enableMultiselect: {
        set: function(val) {
          MultiSelect(this);
          if (val) {
            this.on("mousedown", onMouseDown);
          } else {
            this.off("mousedown", onMouseDown);
          }
        },
        value: true
      },
      enableBlockSelect: {
        set: function(val) {
          this.$blockSelectEnabled = val;
        },
        value: true
      }
    });
  });
  ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
    var Range = require2("../../range").Range;
    var FoldMode = exports2.FoldMode = function() {
    };
    (function() {
      this.foldingStartMarker = null;
      this.foldingStopMarker = null;
      this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.foldingStartMarker.test(line))
          return "start";
        if (foldStyle == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line))
          return "end";
        return "";
      };
      this.getFoldWidgetRange = function(session, foldStyle, row) {
        return null;
      };
      this.indentationBlock = function(session, row, column) {
        var re = /\S/;
        var line = session.getLine(row);
        var startLevel = line.search(re);
        if (startLevel == -1)
          return;
        var startColumn = column || line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;
        while (++row < maxRow) {
          var level = session.getLine(row).search(re);
          if (level == -1)
            continue;
          if (level <= startLevel) {
            var token = session.getTokenAt(row, 0);
            if (!token || token.type !== "string")
              break;
          }
          endRow = row;
        }
        if (endRow > startRow) {
          var endColumn = session.getLine(endRow).length;
          return new Range(startRow, startColumn, endRow, endColumn);
        }
      };
      this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
        var start = { row, column: column + 1 };
        var end = session.$findClosingBracket(bracket, start, typeRe);
        if (!end)
          return;
        var fw = session.foldWidgets[end.row];
        if (fw == null)
          fw = session.getFoldWidget(end.row);
        if (fw == "start" && end.row > start.row) {
          end.row--;
          end.column = session.getLine(end.row).length;
        }
        return Range.fromPoints(start, end);
      };
      this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
        var end = { row, column };
        var start = session.$findOpeningBracket(bracket, end);
        if (!start)
          return;
        start.column++;
        end.column--;
        return Range.fromPoints(start, end);
      };
    }).call(FoldMode.prototype);
  });
  ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/lib/dom", "ace/range", "ace/config"], function(require2, exports2, module2) {
    var dom = require2("../lib/dom");
    var Range = require2("../range").Range;
    var nls = require2("../config").nls;
    function binarySearch(array, needle, comparator) {
      var first = 0;
      var last = array.length - 1;
      while (first <= last) {
        var mid = first + last >> 1;
        var c = comparator(needle, array[mid]);
        if (c > 0)
          first = mid + 1;
        else if (c < 0)
          last = mid - 1;
        else
          return mid;
      }
      return -(first + 1);
    }
    function findAnnotations(session, row, dir) {
      var annotations = session.getAnnotations().sort(Range.comparePoints);
      if (!annotations.length)
        return;
      var i = binarySearch(annotations, { row, column: -1 }, Range.comparePoints);
      if (i < 0)
        i = -i - 1;
      if (i >= annotations.length)
        i = dir > 0 ? 0 : annotations.length - 1;
      else if (i === 0 && dir < 0)
        i = annotations.length - 1;
      var annotation = annotations[i];
      if (!annotation || !dir)
        return;
      if (annotation.row === row) {
        do {
          annotation = annotations[i += dir];
        } while (annotation && annotation.row === row);
        if (!annotation)
          return annotations.slice();
      }
      var matched = [];
      row = annotation.row;
      do {
        matched[dir < 0 ? "unshift" : "push"](annotation);
        annotation = annotations[i += dir];
      } while (annotation && annotation.row == row);
      return matched.length && matched;
    }
    exports2.showErrorMarker = function(editor2, dir) {
      var session = editor2.session;
      var pos = editor2.getCursorPosition();
      var row = pos.row;
      var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w2) {
        return w2.type == "errorMarker";
      })[0];
      if (oldWidget) {
        oldWidget.destroy();
      } else {
        row -= dir;
      }
      var annotations = findAnnotations(session, row, dir);
      var gutterAnno;
      if (annotations) {
        var annotation = annotations[0];
        pos.column = (annotation.pos && typeof annotation.column != "number" ? annotation.pos.sc : annotation.column) || 0;
        pos.row = annotation.row;
        gutterAnno = editor2.renderer.$gutterLayer.$annotations[pos.row];
      } else if (oldWidget) {
        return;
      } else {
        gutterAnno = {
          displayText: [nls("error-marker.good-state", "Looks good!")],
          className: "ace_ok"
        };
      }
      editor2.session.unfold(pos.row);
      editor2.selection.moveToPosition(pos);
      var w = {
        row: pos.row,
        fixedWidth: true,
        coverGutter: true,
        el: dom.createElement("div"),
        type: "errorMarker"
      };
      var el = w.el.appendChild(dom.createElement("div"));
      var arrow = w.el.appendChild(dom.createElement("div"));
      arrow.className = "error_widget_arrow " + gutterAnno.className;
      var left = editor2.renderer.$cursorLayer.getPixelPosition(pos).left;
      arrow.style.left = left + editor2.renderer.gutterWidth - 5 + "px";
      w.el.className = "error_widget_wrapper";
      el.className = "error_widget " + gutterAnno.className;
      gutterAnno.displayText.forEach(function(annoTextLine, i) {
        el.appendChild(dom.createTextNode(annoTextLine));
        if (i < gutterAnno.displayText.length - 1) {
          el.appendChild(dom.createElement("br"));
        }
      });
      el.appendChild(dom.createElement("div"));
      var kb = function(_, hashId, keyString) {
        if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
          w.destroy();
          return { command: "null" };
        }
      };
      w.destroy = function() {
        if (editor2.$mouseHandler.isMousePressed)
          return;
        editor2.keyBinding.removeKeyboardHandler(kb);
        session.widgetManager.removeLineWidget(w);
        editor2.off("changeSelection", w.destroy);
        editor2.off("changeSession", w.destroy);
        editor2.off("mouseup", w.destroy);
        editor2.off("change", w.destroy);
      };
      editor2.keyBinding.addKeyboardHandler(kb);
      editor2.on("changeSelection", w.destroy);
      editor2.on("changeSession", w.destroy);
      editor2.on("mouseup", w.destroy);
      editor2.on("change", w.destroy);
      editor2.session.widgetManager.addLineWidget(w);
      w.el.onmousedown = editor2.focus.bind(editor2);
      editor2.renderer.scrollCursorIntoView(null, 0.5, { bottom: w.el.offsetHeight });
    };
    dom.importCssString("\n    .error_widget_wrapper {\n        background: inherit;\n        color: inherit;\n        border:none\n    }\n    .error_widget {\n        border-top: solid 2px;\n        border-bottom: solid 2px;\n        margin: 5px 0;\n        padding: 10px 40px;\n        white-space: pre-wrap;\n    }\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\n        border-color: #ff5a5a\n    }\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\n        border-color: #F1D817\n    }\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\n        border-color: #5a5a5a\n    }\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\n        border-color: #5aaa5a\n    }\n    .error_widget_arrow {\n        position: absolute;\n        border: solid 5px;\n        border-top-color: transparent!important;\n        border-right-color: transparent!important;\n        border-left-color: transparent!important;\n        top: -5px;\n    }\n", "error_marker.css", false);
  });
  ace.define("ace/ace", ["require", "exports", "module", "ace/lib/dom", "ace/range", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config", "ace/loader_build"], function(require2, exports2, module2) {
    require2("./loader_build")(exports2);
    var dom = require2("./lib/dom");
    var Range = require2("./range").Range;
    var Editor2 = require2("./editor").Editor;
    var EditSession = require2("./edit_session").EditSession;
    var UndoManager = require2("./undomanager").UndoManager;
    var Renderer = require2("./virtual_renderer").VirtualRenderer;
    require2("./worker/worker_client");
    require2("./keyboard/hash_handler");
    require2("./placeholder");
    require2("./multi_select");
    require2("./mode/folding/fold_mode");
    require2("./theme/textmate");
    require2("./ext/error_marker");
    exports2.config = require2("./config");
    exports2.edit = function(el, options) {
      if (typeof el == "string") {
        var _id = el;
        el = document.getElementById(_id);
        if (!el)
          throw new Error("ace.edit can't find div #" + _id);
      }
      if (el && el.env && el.env.editor instanceof Editor2)
        return el.env.editor;
      var value = "";
      if (el && /input|textarea/i.test(el.tagName)) {
        var oldNode = el;
        value = oldNode.value;
        el = dom.createElement("pre");
        oldNode.parentNode.replaceChild(el, oldNode);
      } else if (el) {
        value = el.textContent;
        el.innerHTML = "";
      }
      var doc = exports2.createEditSession(value);
      var editor2 = new Editor2(new Renderer(el), doc, options);
      var env = {
        document: doc,
        editor: editor2,
        onResize: editor2.resize.bind(editor2, null)
      };
      if (oldNode)
        env.textarea = oldNode;
      editor2.on("destroy", function() {
        env.editor.container.env = null;
      });
      editor2.container.env = editor2.env = env;
      return editor2;
    };
    exports2.createEditSession = function(text, mode) {
      var doc = new EditSession(text, mode);
      doc.setUndoManager(new UndoManager());
      return doc;
    };
    exports2.Range = Range;
    exports2.Editor = Editor2;
    exports2.EditSession = EditSession;
    exports2.UndoManager = UndoManager;
    exports2.VirtualRenderer = Renderer;
    var version = exports2.config.version;
    exports2.version = version;
  });
  (function() {
    ace.require(["ace/ace"], function(a) {
      if (a) {
        a.config.init(true);
        a.define = ace.define;
      }
      var global = /* @__PURE__ */ function() {
        return this;
      }();
      if (!global && typeof window != "undefined") global = window;
      if (!global && typeof self != "undefined") global = self;
      if (!global.ace)
        global.ace = a;
      for (var key in a) if (a.hasOwnProperty(key))
        global.ace[key] = a[key];
      global.ace["default"] = global.ace;
      if (module) {
        module.exports = global.ace;
      }
    });
  })();
})(ace$1);
var aceExports = ace$1.exports;
const editor = "_editor_1odyu_1";
const classes$3 = {
  editor
};
function Editor({ mode, handle: handle2, theme, style: style2, stretch }) {
  const actualStyle = reactExports.useMemo(
    () => ({
      ...style2,
      ...stretch ? { width: "100%", height: "100%" } : {}
    }),
    [style2, stretch]
  );
  const containerRef = reactExports.useRef(null);
  const editorRef = reactExports.useRef(void 0);
  const getEditor = reactExports.useCallback(() => editorRef.current, []);
  reactExports.useLayoutEffect(() => {
    console.log("create ace");
    editorRef.current = aceExports.edit(containerRef.current);
  }, []);
  reactExports.useLayoutEffect(() => {
    if (theme) {
      editorRef.current.setTheme(theme);
    }
  }, [theme]);
  reactExports.useLayoutEffect(() => {
    if (mode) {
      editorRef.current.session.setMode(mode);
    }
  }, [mode]);
  reactExports.useLayoutEffect(() => {
    if (handle2) {
      handle2.current = {
        getEditor
      };
    }
  }, [handle2, getEditor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: containerRef, className: classes$3.editor, style: actualStyle });
}
const container$1 = "_container_1ioff_1";
const header = "_header_1ioff_6";
const headerButton = "_headerButton_1ioff_16";
const headerFreeSpace = "_headerFreeSpace_1ioff_35";
const tab$1 = "_tab_1ioff_41";
const classes$2 = {
  container: container$1,
  header,
  headerButton,
  headerFreeSpace,
  tab: tab$1
};
let id = 0;
function allocateTabId() {
  return String(id++);
}
function tab(opts, children) {
  return { ...opts, children };
}
function TabPanel({ className = "", style: style2, stretch, children }) {
  var _a;
  const prvTabsRef = reactExports.useRef({});
  const [showingTabId, setShowingTabId] = reactExports.useState((_a = children[0]) == null ? void 0 : _a.id);
  const tabs = reactExports.useMemo(() => {
    const tabs2 = {};
    for (const tab2 of children) {
      tabs2[tab2.id] = tab2;
    }
    return tabs2;
  }, [children]);
  const tabsRef = reactExports.useRef(tabs);
  tabsRef.current = tabs;
  reactExports.useLayoutEffect(() => {
    for (const id2 in tabs) {
      const tab2 = tabs[id2];
      const prvTab = prvTabsRef.current[id2];
      if (tab2.show && tab2.show !== (prvTab == null ? void 0 : prvTab.show)) {
        setShowingTabId(id2);
      }
    }
    prvTabsRef.current = tabs;
  }, [tabs]);
  reactExports.useLayoutEffect(() => {
    var _a2;
    const tab2 = tabsRef.current[showingTabId];
    if (tab2) {
      (_a2 = tab2.onShow) == null ? void 0 : _a2.call(tab2);
    }
  }, [showingTabId]);
  const actualStyle = reactExports.useMemo(
    () => ({
      ...style2,
      ...stretch ? { width: "100%", height: "100%" } : {}
    }),
    [style2, stretch]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${classes$2.container} ${className}`, style: actualStyle, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classes$2.header, children: [
      children.map((e, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: classes$2.headerButton,
          "data-selected": e.id === showingTabId,
          onClick: () => setShowingTabId(e.id),
          children: e.title
        },
        e.id
      )),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classes$2.headerFreeSpace })
    ] }),
    children.map((e, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classes$2.tab, style: { display: e.id === showingTabId ? "" : "none" }, children: e.children }, e.id))
  ] });
}
const runner = declareBeanInterface("Runner");
const overlay = "_overlay_z480g_1";
const classes$1 = {
  overlay
};
function Overlay() {
  return reactDomExports.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classes$1.overlay }), document.getElementById("overlay-div"));
}
const container = "_container_iwbts_1";
const item = "_item_iwbts_14";
const separator = "_separator_iwbts_26";
const handle = "_handle_iwbts_34";
const classes = {
  container,
  item,
  separator,
  handle
};
function resizePanelItem(opts, children) {
  return { ...opts, children };
}
function ResizePanel({ children, className = "", direction = "row" }) {
  const prvChildrenRef = reactExports.useRef(void 0);
  const itemNodesRef = reactExports.useRef({});
  const actualChildren = reactExports.useMemo(() => {
    const val = [];
    for (let i = 0; i < children.length; i++) {
      val.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: `${classes.item}`,
            "data-last": i == children.length - 1,
            ref: (node) => {
              itemNodesRef.current[i] = node;
              return () => {
                delete itemNodesRef.current[i];
              };
            },
            children: children[i].children
          },
          `${i}c`
        )
      );
      if (i < children.length - 1) {
        const index2 = i;
        const onMouseDown = (e) => {
          const initialCoord = e.clientX;
          const initialWidth = itemNodesRef.current[index2].clientWidth;
          const onMouseMove = (e2) => {
            let delta = e2.clientX - initialCoord;
            if (direction === "row-reverse") {
              delta = -delta;
            }
            itemNodesRef.current[index2].style.width = initialWidth + delta + "px";
          };
          const onMouseUp = () => {
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
          };
          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
        };
        val.push(
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classes.separator }, `${i}s`),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classes.handle, onMouseDown }, `${i}h`)
        );
      }
    }
    return val;
  }, [children, direction]);
  reactExports.useLayoutEffect(() => {
    var _a;
    for (let i = 0; i < children.length; i++) {
      const item2 = children[i];
      const prvItem = (_a = prvChildrenRef.current) == null ? void 0 : _a[i];
      const node = itemNodesRef.current[i];
      if (!node) {
        continue;
      }
      if (!prvItem || prvItem.initialSize !== item2.initialSize) {
        if (item2) {
          node.style.width = item2.initialSize + "px";
        }
      }
    }
    prvChildrenRef.current = children;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${classes.container} ${className}`, "data-direction": direction, children: actualChildren });
}
var modeJavascript = { exports: {} };
(function(module, exports) {
  ace.define("ace/mode/jsdoc_comment_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var TextHighlightRules = require2("./text_highlight_rules").TextHighlightRules;
    var JsDocCommentHighlightRules = function() {
      this.$rules = {
        "start": [
          {
            token: ["comment.doc.tag", "comment.doc.text", "lparen.doc"],
            regex: "(@(?:param|member|typedef|property|namespace|var|const|callback))(\\s*)({)",
            push: [
              {
                token: "lparen.doc",
                regex: "{",
                push: [
                  {
                    include: "doc-syntax"
                  },
                  {
                    token: "rparen.doc",
                    regex: "}|(?=$)",
                    next: "pop"
                  }
                ]
              },
              {
                token: ["rparen.doc", "text.doc", "variable.parameter.doc", "lparen.doc", "variable.parameter.doc", "rparen.doc"],
                regex: /(})(\s*)(?:([\w=:\/\.]+)|(?:(\[)([\w=:\/\.\-\'\" ]+)(\])))/,
                next: "pop"
              },
              {
                token: "rparen.doc",
                regex: "}|(?=$)",
                next: "pop"
              },
              {
                include: "doc-syntax"
              },
              {
                defaultToken: "text.doc"
              }
            ]
          },
          {
            token: ["comment.doc.tag", "text.doc", "lparen.doc"],
            regex: "(@(?:returns?|yields|type|this|suppress|public|protected|private|package|modifies|implements|external|exception|throws|enum|define|extends))(\\s*)({)",
            push: [
              {
                token: "lparen.doc",
                regex: "{",
                push: [
                  {
                    include: "doc-syntax"
                  },
                  {
                    token: "rparen.doc",
                    regex: "}|(?=$)",
                    next: "pop"
                  }
                ]
              },
              {
                token: "rparen.doc",
                regex: "}|(?=$)",
                next: "pop"
              },
              {
                include: "doc-syntax"
              },
              {
                defaultToken: "text.doc"
              }
            ]
          },
          {
            token: ["comment.doc.tag", "text.doc", "variable.parameter.doc"],
            regex: '(@(?:alias|memberof|instance|module|name|lends|namespace|external|this|template|requires|param|implements|function|extends|typedef|mixes|constructor|var|memberof\\!|event|listens|exports|class|constructs|interface|emits|fires|throws|const|callback|borrows|augments))(\\s+)(\\w[\\w#.:/~"\\-]*)?'
          },
          {
            token: ["comment.doc.tag", "text.doc", "variable.parameter.doc"],
            regex: "(@method)(\\s+)(\\w[\\w.\\(\\)]*)"
          },
          {
            token: "comment.doc.tag",
            regex: "@access\\s+(?:private|public|protected)"
          },
          {
            token: "comment.doc.tag",
            regex: "@kind\\s+(?:class|constant|event|external|file|function|member|mixin|module|namespace|typedef)"
          },
          {
            token: "comment.doc.tag",
            regex: "@\\w+(?=\\s|$)"
          },
          JsDocCommentHighlightRules.getTagRule(),
          {
            defaultToken: "comment.doc.body",
            caseInsensitive: true
          }
        ],
        "doc-syntax": [{
          token: "operator.doc",
          regex: /[|:]/
        }, {
          token: "paren.doc",
          regex: /[\[\]]/
        }]
      };
      this.normalizeRules();
    };
    oop.inherits(JsDocCommentHighlightRules, TextHighlightRules);
    JsDocCommentHighlightRules.getTagRule = function(start) {
      return {
        token: "comment.doc.tag.storage.type",
        regex: "\\b(?:TODO|FIXME|XXX|HACK)\\b"
      };
    };
    JsDocCommentHighlightRules.getStartRule = function(start) {
      return {
        token: "comment.doc",
        // doc comment
        regex: /\/\*\*(?!\/)/,
        next: start
      };
    };
    JsDocCommentHighlightRules.getEndRule = function(start) {
      return {
        token: "comment.doc",
        // closing comment
        regex: "\\*\\/",
        next: start
      };
    };
    exports2.JsDocCommentHighlightRules = JsDocCommentHighlightRules;
  });
  ace.define("ace/mode/javascript_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/jsdoc_comment_highlight_rules", "ace/mode/text_highlight_rules"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var DocCommentHighlightRules = require2("./jsdoc_comment_highlight_rules").JsDocCommentHighlightRules;
    var TextHighlightRules = require2("./text_highlight_rules").TextHighlightRules;
    var identifierRe = "[a-zA-Z\\$_¡-￿][a-zA-Z\\d\\$_¡-￿]*";
    var JavaScriptHighlightRules = function(options) {
      var keywords = {
        "variable.language": "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|Symbol|Namespace|QName|XML|XMLList|ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|SyntaxError|TypeError|URIError|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|isNaN|parseFloat|parseInt|JSON|Math|this|arguments|prototype|window|document",
        // Pseudo
        "keyword": "const|yield|import|get|set|async|await|break|case|catch|continue|default|delete|do|else|finally|for|if|in|of|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|__parent__|__count__|escape|unescape|with|__proto__|class|enum|extends|super|export|implements|private|public|interface|package|protected|static|constructor",
        "storage.type": "const|let|var|function",
        "constant.language": "null|Infinity|NaN|undefined",
        "support.function": "alert",
        "constant.language.boolean": "true|false"
      };
      var keywordMapper = this.createKeywordMapper(keywords, "identifier");
      var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";
      var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|u{[0-9a-fA-F]{1,6}}|[0-2][0-7]{0,2}|3[0-7][0-7]?|[4-7][0-7]?|.)";
      var anonymousFunctionRe = "(function)(\\s*)(\\*?)";
      var functionCallStartRule = {
        token: ["identifier", "text", "paren.lparen"],
        regex: "(\\b(?!" + Object.values(keywords).join("|") + "\\b)" + identifierRe + ")(\\s*)(\\()"
      };
      this.$rules = {
        "no_regex": [
          DocCommentHighlightRules.getStartRule("doc-start"),
          comments("no_regex"),
          functionCallStartRule,
          {
            token: "string",
            regex: "'(?=.)",
            next: "qstring"
          },
          {
            token: "string",
            regex: '"(?=.)',
            next: "qqstring"
          },
          {
            token: "constant.numeric",
            // hexadecimal, octal and binary
            regex: /0(?:[xX][0-9a-fA-F]+|[oO][0-7]+|[bB][01]+)\b/
          },
          {
            token: "constant.numeric",
            // decimal integers and floats
            regex: /(?:\d\d*(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+\b)?/
          },
          {
            token: [
              "entity.name.function",
              "text",
              "keyword.operator",
              "text",
              "storage.type",
              "text",
              "storage.type",
              "text",
              "paren.lparen"
            ],
            regex: "(" + identifierRe + ")(\\s*)(=)(\\s*)" + anonymousFunctionRe + "(\\s*)(\\()",
            next: "function_arguments"
          },
          {
            token: [
              "storage.type",
              "text",
              "storage.type",
              "text",
              "text",
              "entity.name.function",
              "text",
              "paren.lparen"
            ],
            regex: "(function)(?:(?:(\\s*)(\\*)(\\s*))|(\\s+))(" + identifierRe + ")(\\s*)(\\()",
            next: "function_arguments"
          },
          {
            token: [
              "entity.name.function",
              "text",
              "punctuation.operator",
              "text",
              "storage.type",
              "text",
              "storage.type",
              "text",
              "paren.lparen"
            ],
            regex: "(" + identifierRe + ")(\\s*)(:)(\\s*)" + anonymousFunctionRe + "(\\s*)(\\()",
            next: "function_arguments"
          },
          {
            token: [
              "text",
              "text",
              "storage.type",
              "text",
              "storage.type",
              "text",
              "paren.lparen"
            ],
            regex: "(:)(\\s*)" + anonymousFunctionRe + "(\\s*)(\\()",
            next: "function_arguments"
          },
          {
            token: "keyword",
            regex: `from(?=\\s*('|"))`
          },
          {
            token: "keyword",
            regex: "(?:" + kwBeforeRe + ")\\b",
            next: "start"
          },
          {
            token: "support.constant",
            regex: /that\b/
          },
          {
            token: ["storage.type", "punctuation.operator", "support.function.firebug"],
            regex: /(console)(\.)(warn|info|log|error|debug|time|trace|timeEnd|assert)\b/
          },
          {
            token: keywordMapper,
            regex: identifierRe
          },
          {
            token: "punctuation.operator",
            regex: /[.](?![.])/,
            next: "property"
          },
          {
            token: "storage.type",
            regex: /=>/,
            next: "start"
          },
          {
            token: "keyword.operator",
            regex: /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?:|[!$%&*+\-~\/^]=?/,
            next: "start"
          },
          {
            token: "punctuation.operator",
            regex: /[?:,;.]/,
            next: "start"
          },
          {
            token: "paren.lparen",
            regex: /[\[({]/,
            next: "start"
          },
          {
            token: "paren.rparen",
            regex: /[\])}]/
          },
          {
            token: "comment",
            regex: /^#!.*$/
          }
        ],
        property: [
          {
            token: "text",
            regex: "\\s+"
          },
          {
            token: "keyword.operator",
            regex: /=/
          },
          {
            token: [
              "storage.type",
              "text",
              "storage.type",
              "text",
              "paren.lparen"
            ],
            regex: anonymousFunctionRe + "(\\s*)(\\()",
            next: "function_arguments"
          },
          {
            token: [
              "storage.type",
              "text",
              "storage.type",
              "text",
              "text",
              "entity.name.function",
              "text",
              "paren.lparen"
            ],
            regex: "(function)(?:(?:(\\s*)(\\*)(\\s*))|(\\s+))(\\w+)(\\s*)(\\()",
            next: "function_arguments"
          },
          {
            token: "punctuation.operator",
            regex: /[.](?![.])/
          },
          {
            token: "support.function",
            regex: "prototype"
          },
          {
            token: "support.function",
            regex: /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|lter|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward|rEach)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
          },
          {
            token: "support.function.dom",
            regex: /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
          },
          {
            token: "support.constant",
            regex: /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
          },
          {
            token: "identifier",
            regex: identifierRe
          },
          {
            regex: "",
            token: "empty",
            next: "no_regex"
          }
        ],
        "start": [
          DocCommentHighlightRules.getStartRule("doc-start"),
          comments("start"),
          {
            token: "string.regexp",
            regex: "\\/",
            next: "regex"
          },
          {
            token: "text",
            regex: "\\s+|^$",
            next: "start"
          },
          {
            token: "empty",
            regex: "",
            next: "no_regex"
          }
        ],
        "regex": [
          {
            token: "regexp.keyword.operator",
            regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
          },
          {
            token: "string.regexp",
            regex: "/[sxngimy]*",
            next: "no_regex"
          },
          {
            token: "invalid",
            regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
          },
          {
            token: "constant.language.escape",
            regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
          },
          {
            token: "constant.language.delimiter",
            regex: /\|/
          },
          {
            token: "constant.language.escape",
            regex: /\[\^?/,
            next: "regex_character_class"
          },
          {
            token: "empty",
            regex: "$",
            next: "no_regex"
          },
          {
            defaultToken: "string.regexp"
          }
        ],
        "regex_character_class": [
          {
            token: "regexp.charclass.keyword.operator",
            regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
          },
          {
            token: "constant.language.escape",
            regex: "]",
            next: "regex"
          },
          {
            token: "constant.language.escape",
            regex: "-"
          },
          {
            token: "empty",
            regex: "$",
            next: "no_regex"
          },
          {
            defaultToken: "string.regexp.charachterclass"
          }
        ],
        "default_parameter": [
          {
            token: "string",
            regex: "'(?=.)",
            push: [
              {
                token: "string",
                regex: "'|$",
                next: "pop"
              },
              {
                include: "qstring"
              }
            ]
          },
          {
            token: "string",
            regex: '"(?=.)',
            push: [
              {
                token: "string",
                regex: '"|$',
                next: "pop"
              },
              {
                include: "qqstring"
              }
            ]
          },
          {
            token: "constant.language",
            regex: "null|Infinity|NaN|undefined"
          },
          {
            token: "constant.numeric",
            // hexadecimal, octal and binary
            regex: /0(?:[xX][0-9a-fA-F]+|[oO][0-7]+|[bB][01]+)\b/
          },
          {
            token: "constant.numeric",
            // decimal integers and floats
            regex: /(?:\d\d*(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+\b)?/
          },
          {
            token: "punctuation.operator",
            regex: ",",
            next: "function_arguments"
          },
          {
            token: "text",
            regex: "\\s+"
          },
          {
            token: "punctuation.operator",
            regex: "$"
          },
          {
            token: "empty",
            regex: "",
            next: "no_regex"
          }
        ],
        "function_arguments": [
          comments("function_arguments"),
          {
            token: "variable.parameter",
            regex: identifierRe
          },
          {
            token: "punctuation.operator",
            regex: ","
          },
          {
            token: "text",
            regex: "\\s+"
          },
          {
            token: "punctuation.operator",
            regex: "$"
          },
          {
            token: "empty",
            regex: "",
            next: "no_regex"
          }
        ],
        "qqstring": [
          {
            token: "constant.language.escape",
            regex: escapedRe
          },
          {
            token: "string",
            regex: "\\\\$",
            consumeLineEnd: true
          },
          {
            token: "string",
            regex: '"|$',
            next: "no_regex"
          },
          {
            defaultToken: "string"
          }
        ],
        "qstring": [
          {
            token: "constant.language.escape",
            regex: escapedRe
          },
          {
            token: "string",
            regex: "\\\\$",
            consumeLineEnd: true
          },
          {
            token: "string",
            regex: "'|$",
            next: "no_regex"
          },
          {
            defaultToken: "string"
          }
        ]
      };
      if (!options || !options.noES6) {
        this.$rules.no_regex.unshift({
          regex: "[{}]",
          onMatch: function(val, state, stack) {
            this.next = val == "{" ? this.nextState : "";
            if (val == "{" && stack.length) {
              stack.unshift("start", state);
            } else if (val == "}" && stack.length) {
              stack.shift();
              this.next = stack.shift();
              if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1)
                return "paren.quasi.end";
            }
            return val == "{" ? "paren.lparen" : "paren.rparen";
          },
          nextState: "start"
        }, {
          token: "string.quasi.start",
          regex: /`/,
          push: [{
            token: "constant.language.escape",
            regex: escapedRe
          }, {
            token: "paren.quasi.start",
            regex: /\${/,
            push: "start"
          }, {
            token: "string.quasi.end",
            regex: /`/,
            next: "pop"
          }, {
            defaultToken: "string.quasi"
          }]
        }, {
          token: ["variable.parameter", "text"],
          regex: "(" + identifierRe + ")(\\s*)(?=\\=>)"
        }, {
          token: "paren.lparen",
          regex: "(\\()(?=[^\\(]+\\s*=>)",
          next: "function_arguments"
        }, {
          token: "variable.language",
          regex: "(?:(?:(?:Weak)?(?:Set|Map))|Promise)\\b"
        });
        this.$rules["function_arguments"].unshift({
          token: "keyword.operator",
          regex: "=",
          next: "default_parameter"
        }, {
          token: "keyword.operator",
          regex: "\\.{3}"
        });
        this.$rules["property"].unshift({
          token: "support.function",
          regex: "(findIndex|repeat|startsWith|endsWith|includes|isSafeInteger|trunc|cbrt|log2|log10|sign|then|catch|finally|resolve|reject|race|any|all|allSettled|keys|entries|isInteger)\\b(?=\\()"
        }, {
          token: "constant.language",
          regex: "(?:MAX_SAFE_INTEGER|MIN_SAFE_INTEGER|EPSILON)\\b"
        });
        if (!options || options.jsx != false)
          JSX.call(this);
      }
      this.embedRules(DocCommentHighlightRules, "doc-", [DocCommentHighlightRules.getEndRule("no_regex")]);
      this.normalizeRules();
    };
    oop.inherits(JavaScriptHighlightRules, TextHighlightRules);
    function JSX() {
      var tagRegex = identifierRe.replace("\\d", "\\d\\-");
      var jsxTag = {
        onMatch: function(val, state, stack) {
          var offset = val.charAt(1) == "/" ? 2 : 1;
          if (offset == 1) {
            if (state != this.nextState)
              stack.unshift(this.next, this.nextState, 0);
            else
              stack.unshift(this.next);
            stack[2]++;
          } else if (offset == 2) {
            if (state == this.nextState) {
              stack[1]--;
              if (!stack[1] || stack[1] < 0) {
                stack.shift();
                stack.shift();
              }
            }
          }
          return [{
            type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
            value: val.slice(0, offset)
          }, {
            type: "meta.tag.tag-name.xml",
            value: val.substr(offset)
          }];
        },
        regex: "</?(?:" + tagRegex + "|(?=>))",
        next: "jsxAttributes",
        nextState: "jsx"
      };
      this.$rules.start.unshift(jsxTag);
      var jsxJsRule = {
        regex: "{",
        token: "paren.quasi.start",
        push: "start"
      };
      this.$rules.jsx = [
        jsxJsRule,
        jsxTag,
        { include: "reference" },
        { defaultToken: "string.xml" }
      ];
      this.$rules.jsxAttributes = [
        {
          token: "meta.tag.punctuation.tag-close.xml",
          regex: "/?>",
          onMatch: function(value, currentState, stack) {
            if (currentState == stack[0])
              stack.shift();
            if (value.length == 2) {
              if (stack[0] == this.nextState)
                stack[1]--;
              if (!stack[1] || stack[1] < 0) {
                stack.splice(0, 2);
              }
            }
            this.next = stack[0] || "start";
            return [{ type: this.token, value }];
          },
          nextState: "jsx"
        },
        jsxJsRule,
        comments("jsxAttributes"),
        {
          token: "entity.other.attribute-name.xml",
          regex: tagRegex
        },
        {
          token: "keyword.operator.attribute-equals.xml",
          regex: "="
        },
        {
          token: "text.tag-whitespace.xml",
          regex: "\\s+"
        },
        {
          token: "string.attribute-value.xml",
          regex: "'",
          stateName: "jsx_attr_q",
          push: [
            { token: "string.attribute-value.xml", regex: "'", next: "pop" },
            { include: "reference" },
            { defaultToken: "string.attribute-value.xml" }
          ]
        },
        {
          token: "string.attribute-value.xml",
          regex: '"',
          stateName: "jsx_attr_qq",
          push: [
            { token: "string.attribute-value.xml", regex: '"', next: "pop" },
            { include: "reference" },
            { defaultToken: "string.attribute-value.xml" }
          ]
        },
        jsxTag
      ];
      this.$rules.reference = [{
        token: "constant.language.escape.reference.xml",
        regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
      }];
    }
    function comments(next) {
      return [
        {
          token: "comment",
          // multi line comment
          regex: /\/\*/,
          next: [
            DocCommentHighlightRules.getTagRule(),
            { token: "comment", regex: "\\*\\/", next: next || "pop" },
            { defaultToken: "comment", caseInsensitive: true }
          ]
        },
        {
          token: "comment",
          regex: "\\/\\/",
          next: [
            DocCommentHighlightRules.getTagRule(),
            { token: "comment", regex: "$|^", next: next || "pop" },
            { defaultToken: "comment", caseInsensitive: true }
          ]
        }
      ];
    }
    exports2.JavaScriptHighlightRules = JavaScriptHighlightRules;
  });
  ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
    var Range = require2("../range").Range;
    var MatchingBraceOutdent = function() {
    };
    (function() {
      this.checkOutdent = function(line, input) {
        if (!/^\s+$/.test(line))
          return false;
        return /^\s*\}/.test(input);
      };
      this.autoOutdent = function(doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\})/);
        if (!match)
          return 0;
        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({ row, column });
        if (!openBracePos || openBracePos.row == row)
          return 0;
        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        doc.replace(new Range(row, 0, row, column - 1), indent);
      };
      this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
      };
    }).call(MatchingBraceOutdent.prototype);
    exports2.MatchingBraceOutdent = MatchingBraceOutdent;
  });
  ace.define("ace/mode/behaviour/xml", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator"], function(require2, exports2, module2) {
    var oop = require2("../../lib/oop");
    var Behaviour = require2("../behaviour").Behaviour;
    var TokenIterator = require2("../../token_iterator").TokenIterator;
    function is2(token, type) {
      return token && token.type.lastIndexOf(type + ".xml") > -1;
    }
    var XmlBehaviour = function() {
      this.add("string_dquotes", "insertion", function(state, action, editor2, session, text) {
        if (text == '"' || text == "'") {
          var quote = text;
          var selected = session.doc.getTextRange(editor2.getSelectionRange());
          if (selected !== "" && selected !== "'" && selected != '"' && editor2.getWrapBehavioursEnabled()) {
            return {
              text: quote + selected + quote,
              selection: false
            };
          }
          var cursor = editor2.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          var rightChar = line.substring(cursor.column, cursor.column + 1);
          var iterator = new TokenIterator(session, cursor.row, cursor.column);
          var token = iterator.getCurrentToken();
          if (rightChar == quote && (is2(token, "attribute-value") || is2(token, "string"))) {
            return {
              text: "",
              selection: [1, 1]
            };
          }
          if (!token)
            token = iterator.stepBackward();
          if (!token)
            return;
          while (is2(token, "tag-whitespace") || is2(token, "whitespace")) {
            token = iterator.stepBackward();
          }
          var rightSpace = !rightChar || rightChar.match(/\s/);
          if (is2(token, "attribute-equals") && (rightSpace || rightChar == ">") || is2(token, "decl-attribute-equals") && (rightSpace || rightChar == "?")) {
            return {
              text: quote + quote,
              selection: [1, 1]
            };
          }
        }
      });
      this.add("string_dquotes", "deletion", function(state, action, editor2, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
          var line = session.doc.getLine(range.start.row);
          var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
          if (rightChar == selected) {
            range.end.column++;
            return range;
          }
        }
      });
      this.add("autoclosing", "insertion", function(state, action, editor2, session, text) {
        if (text == ">") {
          var position = editor2.getSelectionRange().start;
          var iterator = new TokenIterator(session, position.row, position.column);
          var token = iterator.getCurrentToken() || iterator.stepBackward();
          if (!token || !(is2(token, "tag-name") || is2(token, "tag-whitespace") || is2(token, "attribute-name") || is2(token, "attribute-equals") || is2(token, "attribute-value")))
            return;
          if (is2(token, "reference.attribute-value"))
            return;
          if (is2(token, "attribute-value")) {
            var tokenEndColumn = iterator.getCurrentTokenColumn() + token.value.length;
            if (position.column < tokenEndColumn)
              return;
            if (position.column == tokenEndColumn) {
              var nextToken = iterator.stepForward();
              if (nextToken && is2(nextToken, "attribute-value"))
                return;
              iterator.stepBackward();
            }
          }
          if (/^\s*>/.test(session.getLine(position.row).slice(position.column)))
            return;
          while (!is2(token, "tag-name")) {
            token = iterator.stepBackward();
            if (token.value == "<") {
              token = iterator.stepForward();
              break;
            }
          }
          var tokenRow = iterator.getCurrentTokenRow();
          var tokenColumn = iterator.getCurrentTokenColumn();
          if (is2(iterator.stepBackward(), "end-tag-open"))
            return;
          var element = token.value;
          if (tokenRow == position.row)
            element = element.substring(0, position.column - tokenColumn);
          if (this.voidElements && this.voidElements.hasOwnProperty(element.toLowerCase()))
            return;
          return {
            text: "></" + element + ">",
            selection: [1, 1]
          };
        }
      });
      this.add("autoindent", "insertion", function(state, action, editor2, session, text) {
        if (text == "\n") {
          var cursor = editor2.getCursorPosition();
          var line = session.getLine(cursor.row);
          var iterator = new TokenIterator(session, cursor.row, cursor.column);
          var token = iterator.getCurrentToken();
          if (is2(token, "") && token.type.indexOf("tag-close") !== -1) {
            if (token.value == "/>")
              return;
            while (token && token.type.indexOf("tag-name") === -1) {
              token = iterator.stepBackward();
            }
            if (!token) {
              return;
            }
            var tag = token.value;
            var row = iterator.getCurrentTokenRow();
            token = iterator.stepBackward();
            if (!token || token.type.indexOf("end-tag") !== -1) {
              return;
            }
            if (this.voidElements && !this.voidElements[tag] || !this.voidElements) {
              var nextToken = session.getTokenAt(cursor.row, cursor.column + 1);
              var line = session.getLine(row);
              var nextIndent = this.$getIndent(line);
              var indent = nextIndent + session.getTabString();
              if (nextToken && nextToken.value === "</") {
                return {
                  text: "\n" + indent + "\n" + nextIndent,
                  selection: [1, indent.length, 1, indent.length]
                };
              } else {
                return {
                  text: "\n" + indent
                };
              }
            }
          }
        }
      });
    };
    oop.inherits(XmlBehaviour, Behaviour);
    exports2.XmlBehaviour = XmlBehaviour;
  });
  ace.define("ace/mode/behaviour/javascript", ["require", "exports", "module", "ace/lib/oop", "ace/token_iterator", "ace/mode/behaviour/cstyle", "ace/mode/behaviour/xml"], function(require2, exports2, module2) {
    var oop = require2("../../lib/oop");
    var TokenIterator = require2("../../token_iterator").TokenIterator;
    var CstyleBehaviour = require2("../behaviour/cstyle").CstyleBehaviour;
    var XmlBehaviour = require2("../behaviour/xml").XmlBehaviour;
    var JavaScriptBehaviour = function() {
      var xmlBehaviours = new XmlBehaviour({ closeCurlyBraces: true }).getBehaviours();
      this.addBehaviours(xmlBehaviours);
      this.inherit(CstyleBehaviour);
      this.add("autoclosing-fragment", "insertion", function(state, action, editor2, session, text) {
        if (text == ">") {
          var position = editor2.getSelectionRange().start;
          var iterator = new TokenIterator(session, position.row, position.column);
          var token = iterator.getCurrentToken() || iterator.stepBackward();
          if (!token)
            return;
          if (token.value == "<") {
            return {
              text: "></>",
              selection: [1, 1]
            };
          }
        }
      });
    };
    oop.inherits(JavaScriptBehaviour, CstyleBehaviour);
    exports2.JavaScriptBehaviour = JavaScriptBehaviour;
  });
  ace.define("ace/mode/folding/xml", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function(require2, exports2, module2) {
    var oop = require2("../../lib/oop");
    var Range = require2("../../range").Range;
    var BaseFoldMode = require2("./fold_mode").FoldMode;
    var FoldMode = exports2.FoldMode = function(voidElements, optionalEndTags) {
      BaseFoldMode.call(this);
      this.voidElements = voidElements || {};
      this.optionalEndTags = oop.mixin({}, this.voidElements);
      if (optionalEndTags)
        oop.mixin(this.optionalEndTags, optionalEndTags);
    };
    oop.inherits(FoldMode, BaseFoldMode);
    var Tag = function() {
      this.tagName = "";
      this.closing = false;
      this.selfClosing = false;
      this.start = { row: 0, column: 0 };
      this.end = { row: 0, column: 0 };
    };
    function is2(token, type) {
      return token && token.type && token.type.lastIndexOf(type + ".xml") > -1;
    }
    (function() {
      this.getFoldWidget = function(session, foldStyle, row) {
        var tag = this._getFirstTagInLine(session, row);
        if (!tag)
          return this.getCommentFoldWidget(session, row);
        if (tag.closing || !tag.tagName && tag.selfClosing)
          return foldStyle === "markbeginend" ? "end" : "";
        if (!tag.tagName || tag.selfClosing || this.voidElements.hasOwnProperty(tag.tagName.toLowerCase()))
          return "";
        if (this._findEndTagInLine(session, row, tag.tagName, tag.end.column))
          return "";
        return "start";
      };
      this.getCommentFoldWidget = function(session, row) {
        if (/comment/.test(session.getState(row)) && /<!-/.test(session.getLine(row)))
          return "start";
        return "";
      };
      this._getFirstTagInLine = function(session, row) {
        var tokens = session.getTokens(row);
        var tag = new Tag();
        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          if (is2(token, "tag-open")) {
            tag.end.column = tag.start.column + token.value.length;
            tag.closing = is2(token, "end-tag-open");
            token = tokens[++i];
            if (!token)
              return null;
            tag.tagName = token.value;
            if (token.value === "") {
              token = tokens[++i];
              if (!token)
                return null;
              tag.tagName = token.value;
            }
            tag.end.column += token.value.length;
            for (i++; i < tokens.length; i++) {
              token = tokens[i];
              tag.end.column += token.value.length;
              if (is2(token, "tag-close")) {
                tag.selfClosing = token.value == "/>";
                break;
              }
            }
            return tag;
          } else if (is2(token, "tag-close")) {
            tag.selfClosing = token.value == "/>";
            return tag;
          }
          tag.start.column += token.value.length;
        }
        return null;
      };
      this._findEndTagInLine = function(session, row, tagName, startColumn) {
        var tokens = session.getTokens(row);
        var column = 0;
        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          column += token.value.length;
          if (column < startColumn - 1)
            continue;
          if (is2(token, "end-tag-open")) {
            token = tokens[i + 1];
            if (is2(token, "tag-name") && token.value === "") {
              token = tokens[i + 2];
            }
            if (token && token.value == tagName)
              return true;
          }
        }
        return false;
      };
      this.getFoldWidgetRange = function(session, foldStyle, row) {
        var firstTag = this._getFirstTagInLine(session, row);
        if (!firstTag) {
          return this.getCommentFoldWidget(session, row) && session.getCommentFoldRange(row, session.getLine(row).length);
        }
        var tags = session.getMatchingTags({ row, column: 0 });
        if (tags) {
          return new Range(tags.openTag.end.row, tags.openTag.end.column, tags.closeTag.start.row, tags.closeTag.start.column);
        }
      };
    }).call(FoldMode.prototype);
  });
  ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function(require2, exports2, module2) {
    var oop = require2("../../lib/oop");
    var Range = require2("../../range").Range;
    var BaseFoldMode = require2("./fold_mode").FoldMode;
    var FoldMode = exports2.FoldMode = function(commentRegex) {
      if (commentRegex) {
        this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
        this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
      }
    };
    oop.inherits(FoldMode, BaseFoldMode);
    (function() {
      this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/;
      this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/;
      this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
      this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
      this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
      this._getFoldWidgetBase = this.getFoldWidget;
      this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.singleLineBlockCommentRe.test(line)) {
          if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
            return "";
        }
        var fw = this._getFoldWidgetBase(session, foldStyle, row);
        if (!fw && this.startRegionRe.test(line))
          return "start";
        return fw;
      };
      this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
        var line = session.getLine(row);
        if (this.startRegionRe.test(line))
          return this.getCommentRegionBlock(session, line, row);
        var match = line.match(this.foldingStartMarker);
        if (match) {
          var i = match.index;
          if (match[1])
            return this.openingBracketBlock(session, match[1], row, i);
          var range = session.getCommentFoldRange(row, i + match[0].length, 1);
          if (range && !range.isMultiLine()) {
            if (forceMultiline) {
              range = this.getSectionRange(session, row);
            } else if (foldStyle != "all")
              range = null;
          }
          return range;
        }
        if (foldStyle === "markbegin")
          return;
        var match = line.match(this.foldingStopMarker);
        if (match) {
          var i = match.index + match[0].length;
          if (match[1])
            return this.closingBracketBlock(session, match[1], row, i);
          return session.getCommentFoldRange(row, i, -1);
        }
      };
      this.getSectionRange = function(session, row) {
        var line = session.getLine(row);
        var startIndent = line.search(/\S/);
        var startRow = row;
        var startColumn = line.length;
        row = row + 1;
        var endRow = row;
        var maxRow = session.getLength();
        while (++row < maxRow) {
          line = session.getLine(row);
          var indent = line.search(/\S/);
          if (indent === -1)
            continue;
          if (startIndent > indent)
            break;
          var subRange = this.getFoldWidgetRange(session, "all", row);
          if (subRange) {
            if (subRange.start.row <= startRow) {
              break;
            } else if (subRange.isMultiLine()) {
              row = subRange.end.row;
            } else if (startIndent == indent) {
              break;
            }
          }
          endRow = row;
        }
        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
      };
      this.getCommentRegionBlock = function(session, line, row) {
        var startColumn = line.search(/\s*$/);
        var maxRow = session.getLength();
        var startRow = row;
        var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
        var depth = 1;
        while (++row < maxRow) {
          line = session.getLine(row);
          var m = re.exec(line);
          if (!m)
            continue;
          if (m[1])
            depth--;
          else
            depth++;
          if (!depth)
            break;
        }
        var endRow = row;
        if (endRow > startRow) {
          return new Range(startRow, startColumn, endRow, line.length);
        }
      };
    }).call(FoldMode.prototype);
  });
  ace.define("ace/mode/folding/javascript", ["require", "exports", "module", "ace/lib/oop", "ace/mode/folding/xml", "ace/mode/folding/cstyle"], function(require2, exports2, module2) {
    var oop = require2("../../lib/oop");
    var XmlFoldMode = require2("./xml").FoldMode;
    var CFoldMode = require2("./cstyle").FoldMode;
    var FoldMode = exports2.FoldMode = function(commentRegex) {
      if (commentRegex) {
        this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
        this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
      }
      this.xmlFoldMode = new XmlFoldMode();
    };
    oop.inherits(FoldMode, CFoldMode);
    (function() {
      this.getFoldWidgetRangeBase = this.getFoldWidgetRange;
      this.getFoldWidgetBase = this.getFoldWidget;
      this.getFoldWidget = function(session, foldStyle, row) {
        var fw = this.getFoldWidgetBase(session, foldStyle, row);
        if (!fw) {
          return this.xmlFoldMode.getFoldWidget(session, foldStyle, row);
        }
        return fw;
      };
      this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
        var range = this.getFoldWidgetRangeBase(session, foldStyle, row, forceMultiline);
        if (range)
          return range;
        return this.xmlFoldMode.getFoldWidgetRange(session, foldStyle, row);
      };
    }).call(FoldMode.prototype);
  });
  ace.define("ace/mode/javascript", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/javascript_highlight_rules", "ace/mode/matching_brace_outdent", "ace/worker/worker_client", "ace/mode/behaviour/javascript", "ace/mode/folding/javascript"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var TextMode = require2("./text").Mode;
    var JavaScriptHighlightRules = require2("./javascript_highlight_rules").JavaScriptHighlightRules;
    var MatchingBraceOutdent = require2("./matching_brace_outdent").MatchingBraceOutdent;
    var WorkerClient = require2("../worker/worker_client").WorkerClient;
    var JavaScriptBehaviour = require2("./behaviour/javascript").JavaScriptBehaviour;
    var JavaScriptFoldMode = require2("./folding/javascript").FoldMode;
    var Mode = function() {
      this.HighlightRules = JavaScriptHighlightRules;
      this.$outdent = new MatchingBraceOutdent();
      this.$behaviour = new JavaScriptBehaviour();
      this.foldingRules = new JavaScriptFoldMode();
    };
    oop.inherits(Mode, TextMode);
    (function() {
      this.lineCommentStart = "//";
      this.blockComment = { start: "/*", end: "*/" };
      this.$quotes = { '"': '"', "'": "'", "`": "`" };
      this.$pairQuotesAfter = {
        "`": /\w/
      };
      this.getNextLineIndent = function(state, line, tab2) {
        var indent = this.$getIndent(line);
        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
        var tokens = tokenizedLine.tokens;
        var endState = tokenizedLine.state;
        if (tokens.length && tokens[tokens.length - 1].type == "comment") {
          return indent;
        }
        if (state == "start" || state == "no_regex") {
          var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
          if (match) {
            indent += tab2;
          }
        } else if (state == "doc-start") {
          if (endState == "start" || endState == "no_regex") {
            return "";
          }
        }
        return indent;
      };
      this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
      };
      this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
      };
      this.createWorker = function(session) {
        var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
        worker.attachToDocument(session.getDocument());
        worker.on("annotate", function(results) {
          session.setAnnotations(results.data);
        });
        worker.on("terminate", function() {
          session.clearAnnotations();
        });
        return worker;
      };
      this.$id = "ace/mode/javascript";
      this.snippetFileId = "ace/snippets/javascript";
    }).call(Mode.prototype);
    exports2.Mode = Mode;
  });
  (function() {
    ace.require(["ace/mode/javascript"], function(m) {
      if (module) {
        module.exports = m;
      }
    });
  })();
})(modeJavascript);
var modeTypescript = { exports: {} };
(function(module, exports) {
  ace.define("ace/mode/jsdoc_comment_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var TextHighlightRules = require2("./text_highlight_rules").TextHighlightRules;
    var JsDocCommentHighlightRules = function() {
      this.$rules = {
        "start": [
          {
            token: ["comment.doc.tag", "comment.doc.text", "lparen.doc"],
            regex: "(@(?:param|member|typedef|property|namespace|var|const|callback))(\\s*)({)",
            push: [
              {
                token: "lparen.doc",
                regex: "{",
                push: [
                  {
                    include: "doc-syntax"
                  },
                  {
                    token: "rparen.doc",
                    regex: "}|(?=$)",
                    next: "pop"
                  }
                ]
              },
              {
                token: ["rparen.doc", "text.doc", "variable.parameter.doc", "lparen.doc", "variable.parameter.doc", "rparen.doc"],
                regex: /(})(\s*)(?:([\w=:\/\.]+)|(?:(\[)([\w=:\/\.\-\'\" ]+)(\])))/,
                next: "pop"
              },
              {
                token: "rparen.doc",
                regex: "}|(?=$)",
                next: "pop"
              },
              {
                include: "doc-syntax"
              },
              {
                defaultToken: "text.doc"
              }
            ]
          },
          {
            token: ["comment.doc.tag", "text.doc", "lparen.doc"],
            regex: "(@(?:returns?|yields|type|this|suppress|public|protected|private|package|modifies|implements|external|exception|throws|enum|define|extends))(\\s*)({)",
            push: [
              {
                token: "lparen.doc",
                regex: "{",
                push: [
                  {
                    include: "doc-syntax"
                  },
                  {
                    token: "rparen.doc",
                    regex: "}|(?=$)",
                    next: "pop"
                  }
                ]
              },
              {
                token: "rparen.doc",
                regex: "}|(?=$)",
                next: "pop"
              },
              {
                include: "doc-syntax"
              },
              {
                defaultToken: "text.doc"
              }
            ]
          },
          {
            token: ["comment.doc.tag", "text.doc", "variable.parameter.doc"],
            regex: '(@(?:alias|memberof|instance|module|name|lends|namespace|external|this|template|requires|param|implements|function|extends|typedef|mixes|constructor|var|memberof\\!|event|listens|exports|class|constructs|interface|emits|fires|throws|const|callback|borrows|augments))(\\s+)(\\w[\\w#.:/~"\\-]*)?'
          },
          {
            token: ["comment.doc.tag", "text.doc", "variable.parameter.doc"],
            regex: "(@method)(\\s+)(\\w[\\w.\\(\\)]*)"
          },
          {
            token: "comment.doc.tag",
            regex: "@access\\s+(?:private|public|protected)"
          },
          {
            token: "comment.doc.tag",
            regex: "@kind\\s+(?:class|constant|event|external|file|function|member|mixin|module|namespace|typedef)"
          },
          {
            token: "comment.doc.tag",
            regex: "@\\w+(?=\\s|$)"
          },
          JsDocCommentHighlightRules.getTagRule(),
          {
            defaultToken: "comment.doc.body",
            caseInsensitive: true
          }
        ],
        "doc-syntax": [{
          token: "operator.doc",
          regex: /[|:]/
        }, {
          token: "paren.doc",
          regex: /[\[\]]/
        }]
      };
      this.normalizeRules();
    };
    oop.inherits(JsDocCommentHighlightRules, TextHighlightRules);
    JsDocCommentHighlightRules.getTagRule = function(start) {
      return {
        token: "comment.doc.tag.storage.type",
        regex: "\\b(?:TODO|FIXME|XXX|HACK)\\b"
      };
    };
    JsDocCommentHighlightRules.getStartRule = function(start) {
      return {
        token: "comment.doc",
        // doc comment
        regex: /\/\*\*(?!\/)/,
        next: start
      };
    };
    JsDocCommentHighlightRules.getEndRule = function(start) {
      return {
        token: "comment.doc",
        // closing comment
        regex: "\\*\\/",
        next: start
      };
    };
    exports2.JsDocCommentHighlightRules = JsDocCommentHighlightRules;
  });
  ace.define("ace/mode/javascript_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/jsdoc_comment_highlight_rules", "ace/mode/text_highlight_rules"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var DocCommentHighlightRules = require2("./jsdoc_comment_highlight_rules").JsDocCommentHighlightRules;
    var TextHighlightRules = require2("./text_highlight_rules").TextHighlightRules;
    var identifierRe = "[a-zA-Z\\$_¡-￿][a-zA-Z\\d\\$_¡-￿]*";
    var JavaScriptHighlightRules = function(options) {
      var keywords = {
        "variable.language": "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|Symbol|Namespace|QName|XML|XMLList|ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|SyntaxError|TypeError|URIError|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|isNaN|parseFloat|parseInt|JSON|Math|this|arguments|prototype|window|document",
        // Pseudo
        "keyword": "const|yield|import|get|set|async|await|break|case|catch|continue|default|delete|do|else|finally|for|if|in|of|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|__parent__|__count__|escape|unescape|with|__proto__|class|enum|extends|super|export|implements|private|public|interface|package|protected|static|constructor",
        "storage.type": "const|let|var|function",
        "constant.language": "null|Infinity|NaN|undefined",
        "support.function": "alert",
        "constant.language.boolean": "true|false"
      };
      var keywordMapper = this.createKeywordMapper(keywords, "identifier");
      var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";
      var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|u{[0-9a-fA-F]{1,6}}|[0-2][0-7]{0,2}|3[0-7][0-7]?|[4-7][0-7]?|.)";
      var anonymousFunctionRe = "(function)(\\s*)(\\*?)";
      var functionCallStartRule = {
        token: ["identifier", "text", "paren.lparen"],
        regex: "(\\b(?!" + Object.values(keywords).join("|") + "\\b)" + identifierRe + ")(\\s*)(\\()"
      };
      this.$rules = {
        "no_regex": [
          DocCommentHighlightRules.getStartRule("doc-start"),
          comments("no_regex"),
          functionCallStartRule,
          {
            token: "string",
            regex: "'(?=.)",
            next: "qstring"
          },
          {
            token: "string",
            regex: '"(?=.)',
            next: "qqstring"
          },
          {
            token: "constant.numeric",
            // hexadecimal, octal and binary
            regex: /0(?:[xX][0-9a-fA-F]+|[oO][0-7]+|[bB][01]+)\b/
          },
          {
            token: "constant.numeric",
            // decimal integers and floats
            regex: /(?:\d\d*(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+\b)?/
          },
          {
            token: [
              "entity.name.function",
              "text",
              "keyword.operator",
              "text",
              "storage.type",
              "text",
              "storage.type",
              "text",
              "paren.lparen"
            ],
            regex: "(" + identifierRe + ")(\\s*)(=)(\\s*)" + anonymousFunctionRe + "(\\s*)(\\()",
            next: "function_arguments"
          },
          {
            token: [
              "storage.type",
              "text",
              "storage.type",
              "text",
              "text",
              "entity.name.function",
              "text",
              "paren.lparen"
            ],
            regex: "(function)(?:(?:(\\s*)(\\*)(\\s*))|(\\s+))(" + identifierRe + ")(\\s*)(\\()",
            next: "function_arguments"
          },
          {
            token: [
              "entity.name.function",
              "text",
              "punctuation.operator",
              "text",
              "storage.type",
              "text",
              "storage.type",
              "text",
              "paren.lparen"
            ],
            regex: "(" + identifierRe + ")(\\s*)(:)(\\s*)" + anonymousFunctionRe + "(\\s*)(\\()",
            next: "function_arguments"
          },
          {
            token: [
              "text",
              "text",
              "storage.type",
              "text",
              "storage.type",
              "text",
              "paren.lparen"
            ],
            regex: "(:)(\\s*)" + anonymousFunctionRe + "(\\s*)(\\()",
            next: "function_arguments"
          },
          {
            token: "keyword",
            regex: `from(?=\\s*('|"))`
          },
          {
            token: "keyword",
            regex: "(?:" + kwBeforeRe + ")\\b",
            next: "start"
          },
          {
            token: "support.constant",
            regex: /that\b/
          },
          {
            token: ["storage.type", "punctuation.operator", "support.function.firebug"],
            regex: /(console)(\.)(warn|info|log|error|debug|time|trace|timeEnd|assert)\b/
          },
          {
            token: keywordMapper,
            regex: identifierRe
          },
          {
            token: "punctuation.operator",
            regex: /[.](?![.])/,
            next: "property"
          },
          {
            token: "storage.type",
            regex: /=>/,
            next: "start"
          },
          {
            token: "keyword.operator",
            regex: /--|\+\+|\.{3}|===|==|=|!=|!==|<+=?|>+=?|!|&&|\|\||\?:|[!$%&*+\-~\/^]=?/,
            next: "start"
          },
          {
            token: "punctuation.operator",
            regex: /[?:,;.]/,
            next: "start"
          },
          {
            token: "paren.lparen",
            regex: /[\[({]/,
            next: "start"
          },
          {
            token: "paren.rparen",
            regex: /[\])}]/
          },
          {
            token: "comment",
            regex: /^#!.*$/
          }
        ],
        property: [
          {
            token: "text",
            regex: "\\s+"
          },
          {
            token: "keyword.operator",
            regex: /=/
          },
          {
            token: [
              "storage.type",
              "text",
              "storage.type",
              "text",
              "paren.lparen"
            ],
            regex: anonymousFunctionRe + "(\\s*)(\\()",
            next: "function_arguments"
          },
          {
            token: [
              "storage.type",
              "text",
              "storage.type",
              "text",
              "text",
              "entity.name.function",
              "text",
              "paren.lparen"
            ],
            regex: "(function)(?:(?:(\\s*)(\\*)(\\s*))|(\\s+))(\\w+)(\\s*)(\\()",
            next: "function_arguments"
          },
          {
            token: "punctuation.operator",
            regex: /[.](?![.])/
          },
          {
            token: "support.function",
            regex: "prototype"
          },
          {
            token: "support.function",
            regex: /(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|lter|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward|rEach)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
          },
          {
            token: "support.function.dom",
            regex: /(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName|ClassName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
          },
          {
            token: "support.constant",
            regex: /(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
          },
          {
            token: "identifier",
            regex: identifierRe
          },
          {
            regex: "",
            token: "empty",
            next: "no_regex"
          }
        ],
        "start": [
          DocCommentHighlightRules.getStartRule("doc-start"),
          comments("start"),
          {
            token: "string.regexp",
            regex: "\\/",
            next: "regex"
          },
          {
            token: "text",
            regex: "\\s+|^$",
            next: "start"
          },
          {
            token: "empty",
            regex: "",
            next: "no_regex"
          }
        ],
        "regex": [
          {
            token: "regexp.keyword.operator",
            regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
          },
          {
            token: "string.regexp",
            regex: "/[sxngimy]*",
            next: "no_regex"
          },
          {
            token: "invalid",
            regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
          },
          {
            token: "constant.language.escape",
            regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
          },
          {
            token: "constant.language.delimiter",
            regex: /\|/
          },
          {
            token: "constant.language.escape",
            regex: /\[\^?/,
            next: "regex_character_class"
          },
          {
            token: "empty",
            regex: "$",
            next: "no_regex"
          },
          {
            defaultToken: "string.regexp"
          }
        ],
        "regex_character_class": [
          {
            token: "regexp.charclass.keyword.operator",
            regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
          },
          {
            token: "constant.language.escape",
            regex: "]",
            next: "regex"
          },
          {
            token: "constant.language.escape",
            regex: "-"
          },
          {
            token: "empty",
            regex: "$",
            next: "no_regex"
          },
          {
            defaultToken: "string.regexp.charachterclass"
          }
        ],
        "default_parameter": [
          {
            token: "string",
            regex: "'(?=.)",
            push: [
              {
                token: "string",
                regex: "'|$",
                next: "pop"
              },
              {
                include: "qstring"
              }
            ]
          },
          {
            token: "string",
            regex: '"(?=.)',
            push: [
              {
                token: "string",
                regex: '"|$',
                next: "pop"
              },
              {
                include: "qqstring"
              }
            ]
          },
          {
            token: "constant.language",
            regex: "null|Infinity|NaN|undefined"
          },
          {
            token: "constant.numeric",
            // hexadecimal, octal and binary
            regex: /0(?:[xX][0-9a-fA-F]+|[oO][0-7]+|[bB][01]+)\b/
          },
          {
            token: "constant.numeric",
            // decimal integers and floats
            regex: /(?:\d\d*(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+\b)?/
          },
          {
            token: "punctuation.operator",
            regex: ",",
            next: "function_arguments"
          },
          {
            token: "text",
            regex: "\\s+"
          },
          {
            token: "punctuation.operator",
            regex: "$"
          },
          {
            token: "empty",
            regex: "",
            next: "no_regex"
          }
        ],
        "function_arguments": [
          comments("function_arguments"),
          {
            token: "variable.parameter",
            regex: identifierRe
          },
          {
            token: "punctuation.operator",
            regex: ","
          },
          {
            token: "text",
            regex: "\\s+"
          },
          {
            token: "punctuation.operator",
            regex: "$"
          },
          {
            token: "empty",
            regex: "",
            next: "no_regex"
          }
        ],
        "qqstring": [
          {
            token: "constant.language.escape",
            regex: escapedRe
          },
          {
            token: "string",
            regex: "\\\\$",
            consumeLineEnd: true
          },
          {
            token: "string",
            regex: '"|$',
            next: "no_regex"
          },
          {
            defaultToken: "string"
          }
        ],
        "qstring": [
          {
            token: "constant.language.escape",
            regex: escapedRe
          },
          {
            token: "string",
            regex: "\\\\$",
            consumeLineEnd: true
          },
          {
            token: "string",
            regex: "'|$",
            next: "no_regex"
          },
          {
            defaultToken: "string"
          }
        ]
      };
      if (!options || !options.noES6) {
        this.$rules.no_regex.unshift({
          regex: "[{}]",
          onMatch: function(val, state, stack) {
            this.next = val == "{" ? this.nextState : "";
            if (val == "{" && stack.length) {
              stack.unshift("start", state);
            } else if (val == "}" && stack.length) {
              stack.shift();
              this.next = stack.shift();
              if (this.next.indexOf("string") != -1 || this.next.indexOf("jsx") != -1)
                return "paren.quasi.end";
            }
            return val == "{" ? "paren.lparen" : "paren.rparen";
          },
          nextState: "start"
        }, {
          token: "string.quasi.start",
          regex: /`/,
          push: [{
            token: "constant.language.escape",
            regex: escapedRe
          }, {
            token: "paren.quasi.start",
            regex: /\${/,
            push: "start"
          }, {
            token: "string.quasi.end",
            regex: /`/,
            next: "pop"
          }, {
            defaultToken: "string.quasi"
          }]
        }, {
          token: ["variable.parameter", "text"],
          regex: "(" + identifierRe + ")(\\s*)(?=\\=>)"
        }, {
          token: "paren.lparen",
          regex: "(\\()(?=[^\\(]+\\s*=>)",
          next: "function_arguments"
        }, {
          token: "variable.language",
          regex: "(?:(?:(?:Weak)?(?:Set|Map))|Promise)\\b"
        });
        this.$rules["function_arguments"].unshift({
          token: "keyword.operator",
          regex: "=",
          next: "default_parameter"
        }, {
          token: "keyword.operator",
          regex: "\\.{3}"
        });
        this.$rules["property"].unshift({
          token: "support.function",
          regex: "(findIndex|repeat|startsWith|endsWith|includes|isSafeInteger|trunc|cbrt|log2|log10|sign|then|catch|finally|resolve|reject|race|any|all|allSettled|keys|entries|isInteger)\\b(?=\\()"
        }, {
          token: "constant.language",
          regex: "(?:MAX_SAFE_INTEGER|MIN_SAFE_INTEGER|EPSILON)\\b"
        });
        if (!options || options.jsx != false)
          JSX.call(this);
      }
      this.embedRules(DocCommentHighlightRules, "doc-", [DocCommentHighlightRules.getEndRule("no_regex")]);
      this.normalizeRules();
    };
    oop.inherits(JavaScriptHighlightRules, TextHighlightRules);
    function JSX() {
      var tagRegex = identifierRe.replace("\\d", "\\d\\-");
      var jsxTag = {
        onMatch: function(val, state, stack) {
          var offset = val.charAt(1) == "/" ? 2 : 1;
          if (offset == 1) {
            if (state != this.nextState)
              stack.unshift(this.next, this.nextState, 0);
            else
              stack.unshift(this.next);
            stack[2]++;
          } else if (offset == 2) {
            if (state == this.nextState) {
              stack[1]--;
              if (!stack[1] || stack[1] < 0) {
                stack.shift();
                stack.shift();
              }
            }
          }
          return [{
            type: "meta.tag.punctuation." + (offset == 1 ? "" : "end-") + "tag-open.xml",
            value: val.slice(0, offset)
          }, {
            type: "meta.tag.tag-name.xml",
            value: val.substr(offset)
          }];
        },
        regex: "</?(?:" + tagRegex + "|(?=>))",
        next: "jsxAttributes",
        nextState: "jsx"
      };
      this.$rules.start.unshift(jsxTag);
      var jsxJsRule = {
        regex: "{",
        token: "paren.quasi.start",
        push: "start"
      };
      this.$rules.jsx = [
        jsxJsRule,
        jsxTag,
        { include: "reference" },
        { defaultToken: "string.xml" }
      ];
      this.$rules.jsxAttributes = [
        {
          token: "meta.tag.punctuation.tag-close.xml",
          regex: "/?>",
          onMatch: function(value, currentState, stack) {
            if (currentState == stack[0])
              stack.shift();
            if (value.length == 2) {
              if (stack[0] == this.nextState)
                stack[1]--;
              if (!stack[1] || stack[1] < 0) {
                stack.splice(0, 2);
              }
            }
            this.next = stack[0] || "start";
            return [{ type: this.token, value }];
          },
          nextState: "jsx"
        },
        jsxJsRule,
        comments("jsxAttributes"),
        {
          token: "entity.other.attribute-name.xml",
          regex: tagRegex
        },
        {
          token: "keyword.operator.attribute-equals.xml",
          regex: "="
        },
        {
          token: "text.tag-whitespace.xml",
          regex: "\\s+"
        },
        {
          token: "string.attribute-value.xml",
          regex: "'",
          stateName: "jsx_attr_q",
          push: [
            { token: "string.attribute-value.xml", regex: "'", next: "pop" },
            { include: "reference" },
            { defaultToken: "string.attribute-value.xml" }
          ]
        },
        {
          token: "string.attribute-value.xml",
          regex: '"',
          stateName: "jsx_attr_qq",
          push: [
            { token: "string.attribute-value.xml", regex: '"', next: "pop" },
            { include: "reference" },
            { defaultToken: "string.attribute-value.xml" }
          ]
        },
        jsxTag
      ];
      this.$rules.reference = [{
        token: "constant.language.escape.reference.xml",
        regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
      }];
    }
    function comments(next) {
      return [
        {
          token: "comment",
          // multi line comment
          regex: /\/\*/,
          next: [
            DocCommentHighlightRules.getTagRule(),
            { token: "comment", regex: "\\*\\/", next: next || "pop" },
            { defaultToken: "comment", caseInsensitive: true }
          ]
        },
        {
          token: "comment",
          regex: "\\/\\/",
          next: [
            DocCommentHighlightRules.getTagRule(),
            { token: "comment", regex: "$|^", next: next || "pop" },
            { defaultToken: "comment", caseInsensitive: true }
          ]
        }
      ];
    }
    exports2.JavaScriptHighlightRules = JavaScriptHighlightRules;
  });
  ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
    var Range = require2("../range").Range;
    var MatchingBraceOutdent = function() {
    };
    (function() {
      this.checkOutdent = function(line, input) {
        if (!/^\s+$/.test(line))
          return false;
        return /^\s*\}/.test(input);
      };
      this.autoOutdent = function(doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\})/);
        if (!match)
          return 0;
        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({ row, column });
        if (!openBracePos || openBracePos.row == row)
          return 0;
        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        doc.replace(new Range(row, 0, row, column - 1), indent);
      };
      this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
      };
    }).call(MatchingBraceOutdent.prototype);
    exports2.MatchingBraceOutdent = MatchingBraceOutdent;
  });
  ace.define("ace/mode/behaviour/xml", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator"], function(require2, exports2, module2) {
    var oop = require2("../../lib/oop");
    var Behaviour = require2("../behaviour").Behaviour;
    var TokenIterator = require2("../../token_iterator").TokenIterator;
    function is2(token, type) {
      return token && token.type.lastIndexOf(type + ".xml") > -1;
    }
    var XmlBehaviour = function() {
      this.add("string_dquotes", "insertion", function(state, action, editor2, session, text) {
        if (text == '"' || text == "'") {
          var quote = text;
          var selected = session.doc.getTextRange(editor2.getSelectionRange());
          if (selected !== "" && selected !== "'" && selected != '"' && editor2.getWrapBehavioursEnabled()) {
            return {
              text: quote + selected + quote,
              selection: false
            };
          }
          var cursor = editor2.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          var rightChar = line.substring(cursor.column, cursor.column + 1);
          var iterator = new TokenIterator(session, cursor.row, cursor.column);
          var token = iterator.getCurrentToken();
          if (rightChar == quote && (is2(token, "attribute-value") || is2(token, "string"))) {
            return {
              text: "",
              selection: [1, 1]
            };
          }
          if (!token)
            token = iterator.stepBackward();
          if (!token)
            return;
          while (is2(token, "tag-whitespace") || is2(token, "whitespace")) {
            token = iterator.stepBackward();
          }
          var rightSpace = !rightChar || rightChar.match(/\s/);
          if (is2(token, "attribute-equals") && (rightSpace || rightChar == ">") || is2(token, "decl-attribute-equals") && (rightSpace || rightChar == "?")) {
            return {
              text: quote + quote,
              selection: [1, 1]
            };
          }
        }
      });
      this.add("string_dquotes", "deletion", function(state, action, editor2, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
          var line = session.doc.getLine(range.start.row);
          var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
          if (rightChar == selected) {
            range.end.column++;
            return range;
          }
        }
      });
      this.add("autoclosing", "insertion", function(state, action, editor2, session, text) {
        if (text == ">") {
          var position = editor2.getSelectionRange().start;
          var iterator = new TokenIterator(session, position.row, position.column);
          var token = iterator.getCurrentToken() || iterator.stepBackward();
          if (!token || !(is2(token, "tag-name") || is2(token, "tag-whitespace") || is2(token, "attribute-name") || is2(token, "attribute-equals") || is2(token, "attribute-value")))
            return;
          if (is2(token, "reference.attribute-value"))
            return;
          if (is2(token, "attribute-value")) {
            var tokenEndColumn = iterator.getCurrentTokenColumn() + token.value.length;
            if (position.column < tokenEndColumn)
              return;
            if (position.column == tokenEndColumn) {
              var nextToken = iterator.stepForward();
              if (nextToken && is2(nextToken, "attribute-value"))
                return;
              iterator.stepBackward();
            }
          }
          if (/^\s*>/.test(session.getLine(position.row).slice(position.column)))
            return;
          while (!is2(token, "tag-name")) {
            token = iterator.stepBackward();
            if (token.value == "<") {
              token = iterator.stepForward();
              break;
            }
          }
          var tokenRow = iterator.getCurrentTokenRow();
          var tokenColumn = iterator.getCurrentTokenColumn();
          if (is2(iterator.stepBackward(), "end-tag-open"))
            return;
          var element = token.value;
          if (tokenRow == position.row)
            element = element.substring(0, position.column - tokenColumn);
          if (this.voidElements && this.voidElements.hasOwnProperty(element.toLowerCase()))
            return;
          return {
            text: "></" + element + ">",
            selection: [1, 1]
          };
        }
      });
      this.add("autoindent", "insertion", function(state, action, editor2, session, text) {
        if (text == "\n") {
          var cursor = editor2.getCursorPosition();
          var line = session.getLine(cursor.row);
          var iterator = new TokenIterator(session, cursor.row, cursor.column);
          var token = iterator.getCurrentToken();
          if (is2(token, "") && token.type.indexOf("tag-close") !== -1) {
            if (token.value == "/>")
              return;
            while (token && token.type.indexOf("tag-name") === -1) {
              token = iterator.stepBackward();
            }
            if (!token) {
              return;
            }
            var tag = token.value;
            var row = iterator.getCurrentTokenRow();
            token = iterator.stepBackward();
            if (!token || token.type.indexOf("end-tag") !== -1) {
              return;
            }
            if (this.voidElements && !this.voidElements[tag] || !this.voidElements) {
              var nextToken = session.getTokenAt(cursor.row, cursor.column + 1);
              var line = session.getLine(row);
              var nextIndent = this.$getIndent(line);
              var indent = nextIndent + session.getTabString();
              if (nextToken && nextToken.value === "</") {
                return {
                  text: "\n" + indent + "\n" + nextIndent,
                  selection: [1, indent.length, 1, indent.length]
                };
              } else {
                return {
                  text: "\n" + indent
                };
              }
            }
          }
        }
      });
    };
    oop.inherits(XmlBehaviour, Behaviour);
    exports2.XmlBehaviour = XmlBehaviour;
  });
  ace.define("ace/mode/behaviour/javascript", ["require", "exports", "module", "ace/lib/oop", "ace/token_iterator", "ace/mode/behaviour/cstyle", "ace/mode/behaviour/xml"], function(require2, exports2, module2) {
    var oop = require2("../../lib/oop");
    var TokenIterator = require2("../../token_iterator").TokenIterator;
    var CstyleBehaviour = require2("../behaviour/cstyle").CstyleBehaviour;
    var XmlBehaviour = require2("../behaviour/xml").XmlBehaviour;
    var JavaScriptBehaviour = function() {
      var xmlBehaviours = new XmlBehaviour({ closeCurlyBraces: true }).getBehaviours();
      this.addBehaviours(xmlBehaviours);
      this.inherit(CstyleBehaviour);
      this.add("autoclosing-fragment", "insertion", function(state, action, editor2, session, text) {
        if (text == ">") {
          var position = editor2.getSelectionRange().start;
          var iterator = new TokenIterator(session, position.row, position.column);
          var token = iterator.getCurrentToken() || iterator.stepBackward();
          if (!token)
            return;
          if (token.value == "<") {
            return {
              text: "></>",
              selection: [1, 1]
            };
          }
        }
      });
    };
    oop.inherits(JavaScriptBehaviour, CstyleBehaviour);
    exports2.JavaScriptBehaviour = JavaScriptBehaviour;
  });
  ace.define("ace/mode/folding/xml", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function(require2, exports2, module2) {
    var oop = require2("../../lib/oop");
    var Range = require2("../../range").Range;
    var BaseFoldMode = require2("./fold_mode").FoldMode;
    var FoldMode = exports2.FoldMode = function(voidElements, optionalEndTags) {
      BaseFoldMode.call(this);
      this.voidElements = voidElements || {};
      this.optionalEndTags = oop.mixin({}, this.voidElements);
      if (optionalEndTags)
        oop.mixin(this.optionalEndTags, optionalEndTags);
    };
    oop.inherits(FoldMode, BaseFoldMode);
    var Tag = function() {
      this.tagName = "";
      this.closing = false;
      this.selfClosing = false;
      this.start = { row: 0, column: 0 };
      this.end = { row: 0, column: 0 };
    };
    function is2(token, type) {
      return token && token.type && token.type.lastIndexOf(type + ".xml") > -1;
    }
    (function() {
      this.getFoldWidget = function(session, foldStyle, row) {
        var tag = this._getFirstTagInLine(session, row);
        if (!tag)
          return this.getCommentFoldWidget(session, row);
        if (tag.closing || !tag.tagName && tag.selfClosing)
          return foldStyle === "markbeginend" ? "end" : "";
        if (!tag.tagName || tag.selfClosing || this.voidElements.hasOwnProperty(tag.tagName.toLowerCase()))
          return "";
        if (this._findEndTagInLine(session, row, tag.tagName, tag.end.column))
          return "";
        return "start";
      };
      this.getCommentFoldWidget = function(session, row) {
        if (/comment/.test(session.getState(row)) && /<!-/.test(session.getLine(row)))
          return "start";
        return "";
      };
      this._getFirstTagInLine = function(session, row) {
        var tokens = session.getTokens(row);
        var tag = new Tag();
        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          if (is2(token, "tag-open")) {
            tag.end.column = tag.start.column + token.value.length;
            tag.closing = is2(token, "end-tag-open");
            token = tokens[++i];
            if (!token)
              return null;
            tag.tagName = token.value;
            if (token.value === "") {
              token = tokens[++i];
              if (!token)
                return null;
              tag.tagName = token.value;
            }
            tag.end.column += token.value.length;
            for (i++; i < tokens.length; i++) {
              token = tokens[i];
              tag.end.column += token.value.length;
              if (is2(token, "tag-close")) {
                tag.selfClosing = token.value == "/>";
                break;
              }
            }
            return tag;
          } else if (is2(token, "tag-close")) {
            tag.selfClosing = token.value == "/>";
            return tag;
          }
          tag.start.column += token.value.length;
        }
        return null;
      };
      this._findEndTagInLine = function(session, row, tagName, startColumn) {
        var tokens = session.getTokens(row);
        var column = 0;
        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          column += token.value.length;
          if (column < startColumn - 1)
            continue;
          if (is2(token, "end-tag-open")) {
            token = tokens[i + 1];
            if (is2(token, "tag-name") && token.value === "") {
              token = tokens[i + 2];
            }
            if (token && token.value == tagName)
              return true;
          }
        }
        return false;
      };
      this.getFoldWidgetRange = function(session, foldStyle, row) {
        var firstTag = this._getFirstTagInLine(session, row);
        if (!firstTag) {
          return this.getCommentFoldWidget(session, row) && session.getCommentFoldRange(row, session.getLine(row).length);
        }
        var tags = session.getMatchingTags({ row, column: 0 });
        if (tags) {
          return new Range(tags.openTag.end.row, tags.openTag.end.column, tags.closeTag.start.row, tags.closeTag.start.column);
        }
      };
    }).call(FoldMode.prototype);
  });
  ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function(require2, exports2, module2) {
    var oop = require2("../../lib/oop");
    var Range = require2("../../range").Range;
    var BaseFoldMode = require2("./fold_mode").FoldMode;
    var FoldMode = exports2.FoldMode = function(commentRegex) {
      if (commentRegex) {
        this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
        this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
      }
    };
    oop.inherits(FoldMode, BaseFoldMode);
    (function() {
      this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/;
      this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/;
      this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/;
      this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/;
      this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/;
      this._getFoldWidgetBase = this.getFoldWidget;
      this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
        if (this.singleLineBlockCommentRe.test(line)) {
          if (!this.startRegionRe.test(line) && !this.tripleStarBlockCommentRe.test(line))
            return "";
        }
        var fw = this._getFoldWidgetBase(session, foldStyle, row);
        if (!fw && this.startRegionRe.test(line))
          return "start";
        return fw;
      };
      this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
        var line = session.getLine(row);
        if (this.startRegionRe.test(line))
          return this.getCommentRegionBlock(session, line, row);
        var match = line.match(this.foldingStartMarker);
        if (match) {
          var i = match.index;
          if (match[1])
            return this.openingBracketBlock(session, match[1], row, i);
          var range = session.getCommentFoldRange(row, i + match[0].length, 1);
          if (range && !range.isMultiLine()) {
            if (forceMultiline) {
              range = this.getSectionRange(session, row);
            } else if (foldStyle != "all")
              range = null;
          }
          return range;
        }
        if (foldStyle === "markbegin")
          return;
        var match = line.match(this.foldingStopMarker);
        if (match) {
          var i = match.index + match[0].length;
          if (match[1])
            return this.closingBracketBlock(session, match[1], row, i);
          return session.getCommentFoldRange(row, i, -1);
        }
      };
      this.getSectionRange = function(session, row) {
        var line = session.getLine(row);
        var startIndent = line.search(/\S/);
        var startRow = row;
        var startColumn = line.length;
        row = row + 1;
        var endRow = row;
        var maxRow = session.getLength();
        while (++row < maxRow) {
          line = session.getLine(row);
          var indent = line.search(/\S/);
          if (indent === -1)
            continue;
          if (startIndent > indent)
            break;
          var subRange = this.getFoldWidgetRange(session, "all", row);
          if (subRange) {
            if (subRange.start.row <= startRow) {
              break;
            } else if (subRange.isMultiLine()) {
              row = subRange.end.row;
            } else if (startIndent == indent) {
              break;
            }
          }
          endRow = row;
        }
        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
      };
      this.getCommentRegionBlock = function(session, line, row) {
        var startColumn = line.search(/\s*$/);
        var maxRow = session.getLength();
        var startRow = row;
        var re = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/;
        var depth = 1;
        while (++row < maxRow) {
          line = session.getLine(row);
          var m = re.exec(line);
          if (!m)
            continue;
          if (m[1])
            depth--;
          else
            depth++;
          if (!depth)
            break;
        }
        var endRow = row;
        if (endRow > startRow) {
          return new Range(startRow, startColumn, endRow, line.length);
        }
      };
    }).call(FoldMode.prototype);
  });
  ace.define("ace/mode/folding/javascript", ["require", "exports", "module", "ace/lib/oop", "ace/mode/folding/xml", "ace/mode/folding/cstyle"], function(require2, exports2, module2) {
    var oop = require2("../../lib/oop");
    var XmlFoldMode = require2("./xml").FoldMode;
    var CFoldMode = require2("./cstyle").FoldMode;
    var FoldMode = exports2.FoldMode = function(commentRegex) {
      if (commentRegex) {
        this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
        this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
      }
      this.xmlFoldMode = new XmlFoldMode();
    };
    oop.inherits(FoldMode, CFoldMode);
    (function() {
      this.getFoldWidgetRangeBase = this.getFoldWidgetRange;
      this.getFoldWidgetBase = this.getFoldWidget;
      this.getFoldWidget = function(session, foldStyle, row) {
        var fw = this.getFoldWidgetBase(session, foldStyle, row);
        if (!fw) {
          return this.xmlFoldMode.getFoldWidget(session, foldStyle, row);
        }
        return fw;
      };
      this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
        var range = this.getFoldWidgetRangeBase(session, foldStyle, row, forceMultiline);
        if (range)
          return range;
        return this.xmlFoldMode.getFoldWidgetRange(session, foldStyle, row);
      };
    }).call(FoldMode.prototype);
  });
  ace.define("ace/mode/javascript", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/javascript_highlight_rules", "ace/mode/matching_brace_outdent", "ace/worker/worker_client", "ace/mode/behaviour/javascript", "ace/mode/folding/javascript"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var TextMode = require2("./text").Mode;
    var JavaScriptHighlightRules = require2("./javascript_highlight_rules").JavaScriptHighlightRules;
    var MatchingBraceOutdent = require2("./matching_brace_outdent").MatchingBraceOutdent;
    var WorkerClient = require2("../worker/worker_client").WorkerClient;
    var JavaScriptBehaviour = require2("./behaviour/javascript").JavaScriptBehaviour;
    var JavaScriptFoldMode = require2("./folding/javascript").FoldMode;
    var Mode = function() {
      this.HighlightRules = JavaScriptHighlightRules;
      this.$outdent = new MatchingBraceOutdent();
      this.$behaviour = new JavaScriptBehaviour();
      this.foldingRules = new JavaScriptFoldMode();
    };
    oop.inherits(Mode, TextMode);
    (function() {
      this.lineCommentStart = "//";
      this.blockComment = { start: "/*", end: "*/" };
      this.$quotes = { '"': '"', "'": "'", "`": "`" };
      this.$pairQuotesAfter = {
        "`": /\w/
      };
      this.getNextLineIndent = function(state, line, tab2) {
        var indent = this.$getIndent(line);
        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
        var tokens = tokenizedLine.tokens;
        var endState = tokenizedLine.state;
        if (tokens.length && tokens[tokens.length - 1].type == "comment") {
          return indent;
        }
        if (state == "start" || state == "no_regex") {
          var match = line.match(/^.*(?:\bcase\b.*:|[\{\(\[])\s*$/);
          if (match) {
            indent += tab2;
          }
        } else if (state == "doc-start") {
          if (endState == "start" || endState == "no_regex") {
            return "";
          }
        }
        return indent;
      };
      this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
      };
      this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
      };
      this.createWorker = function(session) {
        var worker = new WorkerClient(["ace"], "ace/mode/javascript_worker", "JavaScriptWorker");
        worker.attachToDocument(session.getDocument());
        worker.on("annotate", function(results) {
          session.setAnnotations(results.data);
        });
        worker.on("terminate", function() {
          session.clearAnnotations();
        });
        return worker;
      };
      this.$id = "ace/mode/javascript";
      this.snippetFileId = "ace/snippets/javascript";
    }).call(Mode.prototype);
    exports2.Mode = Mode;
  });
  ace.define("ace/mode/typescript_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/javascript_highlight_rules"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var JavaScriptHighlightRules = require2("./javascript_highlight_rules").JavaScriptHighlightRules;
    var TypeScriptHighlightRules = function(options) {
      var tsRules = [
        {
          token: ["storage.type", "text", "entity.name.function.ts"],
          regex: "(function)(\\s+)([a-zA-Z0-9$_¡-￿][a-zA-Z0-9d$_¡-￿]*)"
        },
        {
          token: "keyword",
          regex: "(?:\\b(constructor|declare|interface|as|AS|public|private|extends|export|super|readonly|module|namespace|abstract|implements)\\b)"
        },
        {
          token: ["keyword", "storage.type.variable.ts"],
          regex: "(class|type)(\\s+[a-zA-Z0-9_?.$][\\w?.$]*)"
        },
        {
          token: "keyword",
          regex: "\\b(?:super|export|import|keyof|infer)\\b"
        },
        {
          token: ["storage.type.variable.ts"],
          regex: "(?:\\b(this\\.|string\\b|bool\\b|boolean\\b|number\\b|true\\b|false\\b|undefined\\b|any\\b|null\\b|(?:unique )?symbol\\b|object\\b|never\\b|enum\\b))"
        }
      ];
      var JSRules = new JavaScriptHighlightRules({ jsx: (options && options.jsx) == true }).getRules();
      JSRules.no_regex = tsRules.concat(JSRules.no_regex);
      this.$rules = JSRules;
    };
    oop.inherits(TypeScriptHighlightRules, JavaScriptHighlightRules);
    exports2.TypeScriptHighlightRules = TypeScriptHighlightRules;
  });
  ace.define("ace/mode/typescript", ["require", "exports", "module", "ace/lib/oop", "ace/mode/javascript", "ace/mode/typescript_highlight_rules", "ace/mode/folding/cstyle", "ace/mode/matching_brace_outdent"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var jsMode = require2("./javascript").Mode;
    var TypeScriptHighlightRules = require2("./typescript_highlight_rules").TypeScriptHighlightRules;
    var CStyleFoldMode = require2("./folding/cstyle").FoldMode;
    var MatchingBraceOutdent = require2("./matching_brace_outdent").MatchingBraceOutdent;
    var Mode = function() {
      this.HighlightRules = TypeScriptHighlightRules;
      this.$outdent = new MatchingBraceOutdent();
      this.$behaviour = this.$defaultBehaviour;
      this.foldingRules = new CStyleFoldMode();
    };
    oop.inherits(Mode, jsMode);
    (function() {
      this.createWorker = function(session) {
        return null;
      };
      this.$id = "ace/mode/typescript";
    }).call(Mode.prototype);
    exports2.Mode = Mode;
  });
  (function() {
    ace.require(["ace/mode/typescript"], function(m) {
      if (module) {
        module.exports = m;
      }
    });
  })();
})(modeTypescript);
var modeYaml = { exports: {} };
(function(module, exports) {
  ace.define("ace/mode/yaml_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var TextHighlightRules = require2("./text_highlight_rules").TextHighlightRules;
    var YamlHighlightRules = function() {
      this.$rules = {
        "start": [
          {
            token: "comment",
            regex: "#.*$"
          },
          {
            token: "list.markup",
            regex: /^(?:-{3}|\.{3})\s*(?=#|$)/
          },
          {
            token: "list.markup",
            regex: /^\s*[\-?](?:$|\s)/
          },
          {
            token: "constant",
            regex: "!![\\w//]+"
          },
          {
            token: "constant.language",
            regex: "[&\\*][a-zA-Z0-9-_]+"
          },
          {
            token: ["meta.tag", "keyword"],
            regex: /^(\s*\w[^\s:]*?)(:(?=\s|$))/
          },
          {
            token: ["meta.tag", "keyword"],
            regex: /(\w[^\s:]*?)(\s*:(?=\s|$))/
          },
          {
            token: "keyword.operator",
            regex: "<<\\w*:\\w*"
          },
          {
            token: "keyword.operator",
            regex: "-\\s*(?=[{])"
          },
          {
            token: "string",
            // single line
            regex: '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]'
          },
          {
            token: "string",
            // multi line string start
            regex: /[|>][-+\d]*(?:$|\s+(?:$|#))/,
            onMatch: function(val, state, stack, line) {
              line = line.replace(/ #.*/, "");
              var indent = /^ *((:\s*)?-(\s*[^|>])?)?/.exec(line)[0].replace(/\S\s*$/, "").length;
              var indentationIndicator = parseInt(/\d+[\s+-]*$/.exec(line));
              if (indentationIndicator) {
                indent += indentationIndicator - 1;
                this.next = "mlString";
              } else {
                this.next = "mlStringPre";
              }
              if (!stack.length) {
                stack.push(this.next);
                stack.push(indent);
              } else {
                stack[0] = this.next;
                stack[1] = indent;
              }
              return this.token;
            },
            next: "mlString"
          },
          {
            token: "string",
            // single quoted string
            regex: "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
          },
          {
            token: "constant.numeric",
            // float
            regex: /(\b|[+\-\.])[\d_]+(?:(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)(?=[^\d-\w]|$)$/
          },
          {
            token: "constant.numeric",
            // other number
            regex: /[+\-]?\.inf\b|NaN\b|0x[\dA-Fa-f_]+|0b[10_]+/
          },
          {
            token: "constant.language.boolean",
            regex: "\\b(?:true|false|TRUE|FALSE|True|False|yes|no)\\b"
          },
          {
            token: "paren.lparen",
            regex: "[[({]"
          },
          {
            token: "paren.rparen",
            regex: "[\\])}]"
          },
          {
            token: "text",
            regex: /[^\s,:\[\]\{\}]+/
          }
        ],
        "mlStringPre": [
          {
            token: "indent",
            regex: /^ *$/
          },
          {
            token: "indent",
            regex: /^ */,
            onMatch: function(val, state, stack) {
              var curIndent = stack[1];
              if (curIndent >= val.length) {
                this.next = "start";
                stack.shift();
                stack.shift();
              } else {
                stack[1] = val.length - 1;
                this.next = stack[0] = "mlString";
              }
              return this.token;
            },
            next: "mlString"
          },
          {
            defaultToken: "string"
          }
        ],
        "mlString": [
          {
            token: "indent",
            regex: /^ *$/
          },
          {
            token: "indent",
            regex: /^ */,
            onMatch: function(val, state, stack) {
              var curIndent = stack[1];
              if (curIndent >= val.length) {
                this.next = "start";
                stack.splice(0);
              } else {
                this.next = "mlString";
              }
              return this.token;
            },
            next: "mlString"
          },
          {
            token: "string",
            regex: ".+"
          }
        ]
      };
      this.normalizeRules();
    };
    oop.inherits(YamlHighlightRules, TextHighlightRules);
    exports2.YamlHighlightRules = YamlHighlightRules;
  });
  ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function(require2, exports2, module2) {
    var Range = require2("../range").Range;
    var MatchingBraceOutdent = function() {
    };
    (function() {
      this.checkOutdent = function(line, input) {
        if (!/^\s+$/.test(line))
          return false;
        return /^\s*\}/.test(input);
      };
      this.autoOutdent = function(doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\})/);
        if (!match)
          return 0;
        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({ row, column });
        if (!openBracePos || openBracePos.row == row)
          return 0;
        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        doc.replace(new Range(row, 0, row, column - 1), indent);
      };
      this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
      };
    }).call(MatchingBraceOutdent.prototype);
    exports2.MatchingBraceOutdent = MatchingBraceOutdent;
  });
  ace.define("ace/mode/folding/coffee", ["require", "exports", "module", "ace/lib/oop", "ace/mode/folding/fold_mode", "ace/range"], function(require2, exports2, module2) {
    var oop = require2("../../lib/oop");
    var BaseFoldMode = require2("./fold_mode").FoldMode;
    var Range = require2("../../range").Range;
    var FoldMode = exports2.FoldMode = function() {
    };
    oop.inherits(FoldMode, BaseFoldMode);
    (function() {
      this.commentBlock = function(session, row) {
        var re = /\S/;
        var line = session.getLine(row);
        var startLevel = line.search(re);
        if (startLevel == -1 || line[startLevel] != "#")
          return;
        var startColumn = line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;
        while (++row < maxRow) {
          line = session.getLine(row);
          var level = line.search(re);
          if (level == -1)
            continue;
          if (line[level] != "#")
            break;
          endRow = row;
        }
        if (endRow > startRow) {
          var endColumn = session.getLine(endRow).length;
          return new Range(startRow, startColumn, endRow, endColumn);
        }
      };
      this.getFoldWidgetRange = function(session, foldStyle, row) {
        var range = this.indentationBlock(session, row);
        if (range)
          return range;
        range = this.commentBlock(session, row);
        if (range)
          return range;
      };
      this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
        var indent = line.search(/\S/);
        var next = session.getLine(row + 1);
        var prev = session.getLine(row - 1);
        var prevIndent = prev.search(/\S/);
        var nextIndent = next.search(/\S/);
        if (indent == -1) {
          session.foldWidgets[row - 1] = prevIndent != -1 && prevIndent < nextIndent ? "start" : "";
          return "";
        }
        if (prevIndent == -1) {
          if (indent == nextIndent && line[indent] == "#" && next[indent] == "#") {
            session.foldWidgets[row - 1] = "";
            session.foldWidgets[row + 1] = "";
            return "start";
          }
        } else if (prevIndent == indent && line[indent] == "#" && prev[indent] == "#") {
          if (session.getLine(row - 2).search(/\S/) == -1) {
            session.foldWidgets[row - 1] = "start";
            session.foldWidgets[row + 1] = "";
            return "";
          }
        }
        if (prevIndent != -1 && prevIndent < indent)
          session.foldWidgets[row - 1] = "start";
        else
          session.foldWidgets[row - 1] = "";
        if (indent < nextIndent)
          return "start";
        else
          return "";
      };
    }).call(FoldMode.prototype);
  });
  ace.define("ace/mode/folding/yaml", ["require", "exports", "module", "ace/lib/oop", "ace/mode/folding/coffee", "ace/range"], function(require2, exports2, module2) {
    var oop = require2("../../lib/oop");
    var CoffeeFoldMode = require2("./coffee").FoldMode;
    var Range = require2("../../range").Range;
    var FoldMode = exports2.FoldMode = function() {
    };
    oop.inherits(FoldMode, CoffeeFoldMode);
    (function() {
      this.getFoldWidgetRange = function(session, foldStyle, row) {
        var re = /\S/;
        var line = session.getLine(row);
        var startLevel = line.search(re);
        var isCommentFold = line[startLevel] === "#";
        var isDashFold = line[startLevel] === "-";
        if (startLevel == -1)
          return;
        var startColumn = line.length;
        var maxRow = session.getLength();
        var startRow = row;
        var endRow = row;
        if (isCommentFold) {
          var range = this.commentBlock(session, row);
          if (range)
            return range;
        } else if (isDashFold) {
          var range = this.indentationBlock(session, row);
          if (range)
            return range;
        } else {
          while (++row < maxRow) {
            var line = session.getLine(row);
            var level = line.search(re);
            if (level == -1)
              continue;
            if (level <= startLevel && line[startLevel] !== "-") {
              var token = session.getTokenAt(row, 0);
              if (!token || token.type !== "string")
                break;
            }
            endRow = row;
          }
        }
        if (endRow > startRow) {
          var endColumn = session.getLine(endRow).length;
          return new Range(startRow, startColumn, endRow, endColumn);
        }
      };
      this.getFoldWidget = function(session, foldStyle, row) {
        var line = session.getLine(row);
        var indent = line.search(/\S/);
        var next = session.getLine(row + 1);
        var prev = session.getLine(row - 1);
        var prevIndent = prev.search(/\S/);
        var nextIndent = next.search(/\S/);
        var lineStartsWithDash = line[indent] === "-";
        if (indent == -1) {
          session.foldWidgets[row - 1] = prevIndent != -1 && prevIndent < nextIndent ? "start" : "";
          return "";
        }
        if (prevIndent == -1) {
          if (indent == nextIndent && line[indent] == "#" && next[indent] == "#") {
            session.foldWidgets[row - 1] = "";
            session.foldWidgets[row + 1] = "";
            return "start";
          }
        } else if (prevIndent == indent && line[indent] == "#" && prev[indent] == "#") {
          if (session.getLine(row - 2).search(/\S/) == -1) {
            session.foldWidgets[row - 1] = "start";
            session.foldWidgets[row + 1] = "";
            return "";
          }
        }
        if (prevIndent != -1 && prevIndent < indent) {
          session.foldWidgets[row - 1] = "start";
        } else if (prevIndent != -1 && (prevIndent == indent && lineStartsWithDash)) {
          session.foldWidgets[row - 1] = "start";
        } else {
          session.foldWidgets[row - 1] = "";
        }
        if (indent < nextIndent)
          return "start";
        else
          return "";
      };
    }).call(FoldMode.prototype);
  });
  ace.define("ace/mode/yaml", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/yaml_highlight_rules", "ace/mode/matching_brace_outdent", "ace/mode/folding/yaml", "ace/worker/worker_client"], function(require2, exports2, module2) {
    var oop = require2("../lib/oop");
    var TextMode = require2("./text").Mode;
    var YamlHighlightRules = require2("./yaml_highlight_rules").YamlHighlightRules;
    var MatchingBraceOutdent = require2("./matching_brace_outdent").MatchingBraceOutdent;
    var FoldMode = require2("./folding/yaml").FoldMode;
    var WorkerClient = require2("../worker/worker_client").WorkerClient;
    var Mode = function() {
      this.HighlightRules = YamlHighlightRules;
      this.$outdent = new MatchingBraceOutdent();
      this.foldingRules = new FoldMode();
      this.$behaviour = this.$defaultBehaviour;
    };
    oop.inherits(Mode, TextMode);
    (function() {
      this.lineCommentStart = ["#"];
      this.getNextLineIndent = function(state, line, tab2) {
        var indent = this.$getIndent(line);
        if (state == "start") {
          var match = line.match(/^.*[\{\(\[]\s*$/);
          if (match) {
            indent += tab2;
          }
        }
        return indent;
      };
      this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
      };
      this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
      };
      this.createWorker = function(session) {
        var worker = new WorkerClient(["ace"], "ace/mode/yaml_worker", "YamlWorker");
        worker.attachToDocument(session.getDocument());
        worker.on("annotate", function(results) {
          session.setAnnotations(results.data);
        });
        worker.on("terminate", function() {
          session.clearAnnotations();
        });
        return worker;
      };
      this.$id = "ace/mode/yaml";
    }).call(Mode.prototype);
    exports2.Mode = Mode;
  });
  (function() {
    ace.require(["ace/mode/yaml"], function(m) {
      if (module) {
        module.exports = m;
      }
    });
  })();
})(modeYaml);
var themeGithub_light_default = { exports: {} };
(function(module, exports) {
  ace.define("ace/theme/github_light_default-css", ["require", "exports", "module"], function(require2, exports2, module2) {
    module2.exports = '.ace-github-light-default .ace_gutter {\n    background: #ffffff;\n    color: rgba(27, 31, 35, 0.3);\n}\n\n.ace-github-light-default .ace_print-margin {\n    width: 1px;\n    background: #e8e8e8;\n}\n\n.ace-github-light-default {\n    background-color: #FFFFFF;\n    color: #24292E;\n}\n\n.ace-github-light-default .ace_cursor {\n    color: #044289;\n    background: none;\n}\n\n.ace-github-light-default .ace_marker-layer .ace_selection {\n    background: rgba(3, 102, 214, 0.14);\n}\n\n.ace-github-light-default.ace_multiselect .ace_selection.ace_start {\n    box-shadow: 0 0 3px 0px #FFFFFF;\n    border-radius: 2px;\n}\n\n.ace-github-light-default .ace_marker-layer .ace_step {\n    background: rgb(198, 219, 174);\n}\n\n.ace-github-light-default .ace_marker-layer .ace_bracket {\n    margin: -1px 0 0 -1px;\n    border: 1px solid rgba(52, 208, 88, 0);\n    background: rgba(52, 208, 88, 0.25);\n}\n\n.ace-github-light-default .ace_marker-layer .ace_active-line {\n    background: #f6f8fa;\n    border: 2px solid #eeeeee;\n}\n\n.ace-github-light-default .ace_gutter-active-line {\n    background-color: #f6f8fa;\n    color: #24292e\n}\n\n.ace-github-light-default .ace_marker-layer .ace_selected-word {\n    border: 1px solid rgba(3, 102, 214, 0.14);\n}\n\n.ace-github-light-default .ace_fold {\n    background-color: #D73A49;\n    border-color: #24292E;\n}\n\n.ace_tooltip.ace-github-light-default {\n    background-color: #f6f8fa !important;\n    color: #444d56 !important;\n    border: 1px solid #444d56\n}\n\n.ace-github-light-default .language_highlight_error {\n    border-bottom: dotted 1px #cb2431;\n    background: none;\n}\n\n.ace-github-light-default .language_highlight_warning {\n    border-bottom: solid 1px #f9c513;\n    background: none;\n}\n\n.ace-github-light-default .language_highlight_info {\n    border-bottom: dotted 1px #1a85ff;\n    background: none;\n}\n\n.ace-github-light-default .ace_keyword {\n    color: #D73A49;\n}\n\n.ace-github-light-default .ace_constant {\n    color: #005CC5;\n}\n\n.ace-github-light-default .ace_support {\n    color: #005CC5;\n}\n\n.ace-github-light-default .ace_support.ace_constant {\n    color: #005CC5;\n}\n\n.ace-github-light-default .ace_support.ace_type {\n    color: #D73A49;\n}\n\n.ace-github-light-default .ace_storage {\n    color: #D73A49;\n}\n\n.ace-github-light-default .ace_storage.ace_type {\n    color: #D73A49;\n}\n\n.ace-github-light-default .ace_invalid.ace_illegal {\n    font-style: italic;\n    color: #B31D28;\n}\n\n.ace-github-light-default .ace_invalid.ace_deprecated {\n    font-style: italic;\n    color: #B31D28;\n}\n\n.ace-github-light-default .ace_string {\n    color: #032F62;\n}\n\n.ace-github-light-default .ace_string.ace_regexp {\n    color: #032F62;\n}\n\n.ace-github-light-default .ace_comment {\n    color: #6A737D;\n}\n\n.ace-github-light-default .ace_variable {\n    color: #E36209;\n}\n\n.ace-github-light-default .ace_variable.ace_language {\n    color: #005CC5;\n}\n\n.ace-github-light-default .ace_entity.ace_name {\n    color: #6F42C1;\n}\n\n.ace-github-light-default .ace_entity {\n    color: #6F42C1;\n}\n\n.ace-github-light-default .ace_entity.ace_name.ace_tag {\n    color: #22863A;\n}\n\n.ace-github-light-default .ace_meta.ace_tag {\n    color: #22863A;\n}\n\n.ace-github-light-default .ace_markup.ace_heading {\n    color: #005CC5;\n}\n\n.ace-github-light-default .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-github-light-default .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n}\n';
  });
  ace.define("ace/theme/github_light_default", ["require", "exports", "module", "ace/theme/github_light_default-css", "ace/lib/dom"], function(require2, exports2, module2) {
    exports2.isDark = false;
    exports2.cssClass = "ace-github-light-default";
    exports2.cssText = require2("./github_light_default-css");
    var dom = require2("../lib/dom");
    dom.importCssString(exports2.cssText, exports2.cssClass, false);
  });
  (function() {
    ace.require(["ace/theme/github_light_default"], function(m) {
      if (module) {
        module.exports = m;
      }
    });
  })();
})(themeGithub_light_default);
const initialCode = `use "lib:io";

function start() {

    println("---------");
    println("WELCOME!!");
    println("---------");
    println("");

    print("Your name: ");
    var name1: string = readln();
    println("Hello, " + name1 + "!");

    print("Other name: ");
    var name2: string = readln();
    println(makeGoodbyeText(name1, name2));

}

function makeGoodbyeText(a: string, b: string): string {
    return "Goodbye, " + a + " and " + b + "!";
}
`;
function Custom({ element }) {
  const containerRef = reactExports.useRef(null);
  reactExports.useLayoutEffect(() => {
    const container2 = containerRef.current;
    if (element) {
      container2.appendChild(element);
      return () => {
        container2.removeChild(element);
      };
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "100%", height: "100%" }, ref: containerRef });
}
const codeEditorTabId = allocateTabId();
const _parserResultTab = { id: allocateTabId(), title: "Abstract Syntax Tree", show: 0 };
const _codegenResultTab = { id: allocateTabId(), title: "Generated Code" };
const _initialSize = window.innerWidth * 0.4;
function App() {
  const codeEditorTabRef = reactExports.useRef(null);
  const parserResultTabRef = reactExports.useRef(null);
  const codegenResultTabRef = reactExports.useRef(null);
  const [loading, setLoading] = reactExports.useState(false);
  const [parserResultTab, setParserResultTab] = reactExports.useState(_parserResultTab);
  const [runnerTabs, setRunnerTabs] = reactExports.useState([]);
  reactExports.useLayoutEffect(() => {
    codeEditorTabRef.current.getEditor().setValue(initialCode);
  }, []);
  const onResetClick = async () => {
    codeEditorTabRef.current.getEditor().setValue(initialCode);
    localStorage.setItem("sourceCode", initialCode);
  };
  const onRunClick = async () => {
    var _a;
    let r;
    setLoading(true);
    try {
      r = await compile(((_a = codeEditorTabRef.current) == null ? void 0 : _a.getEditor().getValue()) ?? "", {
        debugTree: true
      });
      parserResultTabRef.current.getEditor().setValue(r.parserOutput);
      codegenResultTabRef.current.getEditor().setValue(r.codegenPrettyOutput);
      if (r.errors.length > 0) {
        setParserResultTab((prv) => ({ ...prv, show: prv.show + 1 }));
        return;
      }
    } finally {
      setLoading(false);
    }
    const controller = {
      createTab(title, content, { onShow } = {}) {
        setRunnerTabs((prv) => [
          ...prv.filter((e) => e.title !== title),
          tab({ id: allocateTabId(), title, show: true, onShow }, /* @__PURE__ */ jsxRuntimeExports.jsx(Custom, { element: content }))
        ]);
      }
    };
    const _runner = await getSingleBean(runner);
    await _runner.run(r.codegenOutput, controller);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classes$6.container, children: [
    loading && /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Toolbar, { className: classes$6.toolbar, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ToolButton, { icon: RefreshCcw, text: "Reset", onClick: onResetClick }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ToolButton, { variant: "run", icon: Play, text: "Run!", onClick: onRunClick })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ResizePanel, { className: classes$6.area, direction: "row-reverse", children: [
      resizePanelItem(
        { initialSize: _initialSize },
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabPanel, { stretch: true, children: [
          tab(
            parserResultTab,
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Editor,
              {
                stretch: true,
                handle: parserResultTabRef,
                mode: "ace/mode/yaml",
                theme: "ace/theme/github_light_default"
              }
            )
          ),
          tab(
            _codegenResultTab,
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Editor,
              {
                stretch: true,
                handle: codegenResultTabRef,
                mode: "ace/mode/javascript",
                theme: "ace/theme/github_light_default"
              }
            )
          ),
          ...runnerTabs
        ] })
      ),
      resizePanelItem(
        {},
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabPanel, { stretch: true, children: [
          tab(
            { id: codeEditorTabId, title: "main" },
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Editor,
              {
                stretch: true,
                handle: codeEditorTabRef,
                mode: "ace/mode/typescript",
                theme: "ace/theme/github_light_default"
              }
            )
          )
        ] })
      )
    ] })
  ] });
}
const rootDiv = document.getElementById("root-div");
clientExports.createRoot(rootDiv).render(/* @__PURE__ */ jsxRuntimeExports.jsx(App, {}));
export {
  Bean as B,
  ERROR as E,
  INVALID as I,
  ModuleInput as M,
  __vitePreload as _,
  declareBeanInterface as a,
  combinePos as b,
  codegen as c,
  declareBean as d,
  getSingleBean as e,
  fallbackPos as f,
  getOneBean as g,
  Base as h,
  INTERNAL as i,
  list as l,
  parser as p,
  runner as r,
  single as s
};
